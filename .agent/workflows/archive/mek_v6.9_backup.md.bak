---
description: S2 Mekhanē（方法配置）を発動し、スキル/ワークフローを生成・診断する。tekhne-maker 統合。
hegemonikon: Schema
modules: [S2]
skill_ref: ".agent/skills/schema/s2-mekhane/SKILL.md"
triggers:
  - "スキルを作る"
  - "ワークフローを作る"
  - "プロンプト"
  - "mekhane"
  - "ccl"
version: "6.9"
lineage: "v6.8 + SEL (Semantic Enforcement Layer) 統合 → v6.9"
anti_skip: enabled
derivatives: [comp, inve, adap, model, simulation, observability, substitute, yagni, dry, nudge, visual, manual]
modes:
  meta_optimize: "Meta-Prompting: プロンプト自己最適化 (self-refine loop)"
  lit: "Prompt Literacy: プロンプト教養教育・フィードバック"
cognitive_algebra:
  "+": "詳細生成：全ステップ展開、設計根拠記載"
  "-": "高速生成：最小限の構造、すぐ使える形"
  "*": "メタ生成：生成プロセス自体を問う"
sel_enforcement:
  "+":
    description: "MUST expand all steps with design rationale"
    minimum_requirements:
      - "全ステップ展開"
      - "設計根拠 必須"
      - "Information Absorption Layer 必須"
      - "SE早期失敗 必須"
      - "Quality Assurance 必須"
  "-":
    description: "MAY generate minimal structure, immediately usable"
    minimum_requirements:
      - "最小限の構造"
      - "即座に使える形"
  "*":
    description: "MUST meta-analyze: is this generation method correct?"
    minimum_requirements:
      - "生成プロセスを問う"
      - "代替手法の検討"
ccl_signature: "[WF]/mek+"
---

# /mek: 方法配置ワークフロー (Mekhanē) v6.2

> **正本参照**: [tekhne-maker SKILL.md](file:///home/makaron8426/oikos/hegemonikon/mekhane/ergasterion/tekhne/SKILL.md)
> **目的**: スキル・ワークフローの生成、診断、改善
> **発動条件**: 新規プロンプト作成、既存プロンプト診断

---

## Cognitive Algebra

| Operator | Meaning | Output |
|:---------|:--------|:-------|
| `/mek+` | **Deepening** | 詳細生成: 全ステップ展開、設計根拠 |
| `/mek-` | **Reduction** | 高速生成: 最小限構造、即座に使える |
| `/mek*` | **Expansion** | メタ生成: 「この生成方法は正しいか」 |

---

## CCL 複雑度ポイント制 (v6.45)

> **参照**: [operators.md Section 12](file:///home/makaron8426/oikos/hegemonikon/ccl/operators.md)

生成した CCL のポイントを計算し、帯域内に収めよ:

| 帯域 | pt | 用途 |
|:-----|:---|:-----|
| **Standard** | 15-30pt | `/mek` |
| **Enhanced** | 30-45pt | `/mek+` |
| **Warning** | 60pt+ | 分割推奨 |

### クイックリファレンス

| pt | 演算子 |
|:--:|:-------|
| 1 | `+`, `-`, `_` |
| 2 | `>>`, `E:{}`, `let` |
| 3 | `^`, `√`, `'`, `∂`, `E[]`, `*` |
| 4 | `~`, `Σ`, `V[]`, `I:[]{}` |
| 5 | `\`, `∫`, `F:[]{}` |
| 6 | `!`, `W:[]{}` |
| +4/+10/+18 | ネスト Lv1/Lv2/Lv3 |

---

## 派生モード

> **v6.0 新機能**: 方法の性質に応じた3つの生成モード

| 派生 | 適用場面 | 生成特性 |
|:-----|:---------|:---------|
| **comp** | 既存部品を組み立てる | 組合せ、統合、合成 |
| **inve** | 新規に創出する | 発明、革新、着想 |
| **adap** | 既存を適応させる | 調整、カスタマイズ、最適化 |
| **lit** | プロンプト教養を教える | 言葉遣い解説、履歴フィードバック |
| **visual** | 視覚的成果物を生成 🍌 | 画像、モックアップ、インフォグラフィック |
| **manual** | 作業マニュアルを生成 | Gemini/Jules向け補完防止レベルの手順書 |

### 自動提案の出力形式

> **「/mek だけで自動的に派生が提案される」** — これが美しい

```text
┌─[S2 Mekhanē: モード自動選択]───────────────────────┐
│ 要件: {生成要件}                                   │
│ 推奨派生: {derivative} ({confidence}%)            │
│ 理由: {rationale}                                  │
│ 代替: {alternatives}                               │
│                                                    │
│ → このまま {derivative} で生成？ [y/代替/n]         │
└────────────────────────────────────────────────────┘
```

### FEP 派生選択

```python
from mekhane.fep.derivative_selector import select_derivative

result = select_derivative("S2", "新しいワークフローを作りたい")
# → comp: 既存部品を組み立てる
# → inve: 新規に創出する
# → adap: 既存を適応させる
```

---

## 発動条件

| トリガー | 説明 |
|:---------|:-----|
| `/mek` | **Hegemonikón Mode (デフォルト)** — 定理体系に馴染む「聖」な生成 |
| `/mek vulg` | **俗モード** — 例外的に体系外の生成が必要な場合のみ |
| `/mek [要件]` | 指定要件でスキル生成（従来動作） |
| `/mek diagnose [file]` | 既存プロンプトを診断 |
| `/mek improve [file]` | 既存プロンプトを改善 |
| `/mek ccl "意図"` | **CCL生成モード** — 自然言語から CCL v2.0 式を生成 |

---

## --mode=comp (組立方法)

> **CCL**: `/mek.comp` = `/mek+{method=compose}`
> **目的**: 既存部品を組み合わせて新しいものを作る
> **Scale**: 🔭 Meso

**発動**: `/mek comp` または「組み合わせ」「統合」「合成」

**プロセス**:

```text
1. 利用可能な部品を列挙
   ↓
2. 部品間の互換性を評価
   ↓
3. 組み合わせパターンを設計
   ↓
4. インターフェースを定義
   ↓
5. 出力: 組立設計 + 統合手順
```

**出力形式**:

```text
┌─[S2 Mekhanē: Comp]────────────────────────────────────┐
│ 目的: {作りたいもの}                                  │
│                                                       │
│ 部品リスト:                                           │
│   [A] {部品1} — {役割}                                │
│   [B] {部品2} — {役割}                                │
│   [C] {部品3} — {役割}                                │
│                                                       │
│ 組み合わせ:                                           │
│   A ──┬── B ──── 結果                                 │
│       └── C                                           │
│                                                       │
│ インターフェース: {接続方法}                          │
└───────────────────────────────────────────────────────┘
```

---

## --mode=inve (創出方法)

> **CCL**: `/mek.inve` = `/mek+{method=invent}`
> **目的**: 新規に発明・創造する
> **Scale**: 🌍 Macro

**発動**: `/mek inve` または「新規」「発明」「創造」

**プロセス**:

```text
1. 解決すべき問題を定義
   ↓
2. 既存解法の限界を分析
   ↓
3. 新しいアプローチを発想
   ↓
4. プロトタイプを設計
   ↓
5. 出力: 新規設計 + 検証計画
```

**出力形式**:

```text
┌─[S2 Mekhanē: Inve]────────────────────────────────────┐
│ 問題: {解決すべき課題}                                │
│                                                       │
│ 既存解法の限界:                                       │
│   - {限界1}                                           │
│   - {限界2}                                           │
│                                                       │
│ 新しいアプローチ:                                     │
│   「{革新的な解法}」                                  │
│                                                       │
│ プロトタイプ:                                         │
│   {最小限の実装案}                                    │
│                                                       │
│ 検証計画: {成功を測る方法}                            │
└───────────────────────────────────────────────────────┘
```

---

## --mode=adap (適応方法)

> **CCL**: `/mek.adap` = `/mek+{method=adapt}`
> **目的**: 既存のものを新しい文脈に適応させる
> **Scale**: 🔭 Meso

**発動**: `/mek adap` または「適応」「カスタマイズ」「調整」

**プロセス**:

```text
1. 元のコンポーネントを特定
   ↓
2. 新しい文脈の要件を分析
   ↓
3. 必要な変更を特定
   ↓
4. 互換性を維持しながら変更
   ↓
5. 出力: 適応版 + 変更点
```

**出力形式**:

```text
┌─[S2 Mekhanē: Adap]────────────────────────────────────┐
│ 元: {適応元のコンポーネント}                          │
│ 新文脈: {適応先の環境}                                │
│                                                       │
│ 要件差分:                                             │
│   元: {元の要件}                                      │
│   新: {新しい要件}                                    │
│                                                       │
│ 変更点:                                               │
│   1. {変更1}                                          │
│   2. {変更2}                                          │
│                                                       │
│ 互換性: {保持/破壊}                                   │
└───────────────────────────────────────────────────────┘
```

---

## CCL 生成モード (v6.3 新機能)

> 自然言語の意図を CCL v2.0 プログラムに変換する。
> **v2.0**: 4層フォールバック (LLM → Doxa → Heuristic → User)

### トリガー

```text
/mek ccl "ブログ記事を分析して改善案を出す"
```

### 処理フロー

```text
入力: 自然言語の意図
  ↓
[Layer 1] LLM Parser (Gemini API)
  - CCL v2.0 構文で直接生成
  - 失敗時 → Layer 2
  ↓
[Layer 2] Doxa Patterns (H4 連携)
  - 過去に学習したパターンから検索
  - 失敗時 → Layer 3
  ↓
[Layer 3] Heuristic (静的パターン)
  - キーワードマッチング
  - ループ検出 (N回 → F:×N{})
  - 失敗時 → Layer 4
  ↓
[Layer 4] User Inquiry
  - /u を返して Creator に問い合わせ
  ↓
[VALIDATION] 構文検証
  - CCL v2.0 準拠チェック
  ↓
[OUTPUT] 結果提示
  - CCL 式 + 解釈
  - 成功時 → Doxa に学習記録
```

### 出力形式

```text
┌─[/mek ccl: CCL v2.0 Generated]─────────────────────────────┐
│ 意図: "{入力意図}"                                         │
│ CCL式: {生成された CCL}                                    │
│ Source: {llm|doxa|heuristic|user}                         │
│                                                            │
│ 解釈:                                                      │
│   - Step 1: {演算子説明}                                   │
│   - Step 2: {演算子説明}                                   │
│                                                            │
│ → 実行しますか？ [y/n/edit]                                │
└────────────────────────────────────────────────────────────┘
```

### 実装参照

```python
from mekhane.ccl import CCLGenerator

gen = CCLGenerator()
result = gen.generate("3回分析して実行")
# result.ccl   -> "F:×3{ /s_/ene }"
# result.source -> "heuristic" or "llm" or "doxa"
```

> `/tek` 単体で Hegemonikón Mode 開始。定理体系に馴染む生成物を作る。

### 質問フロー

```text
Q1: カテゴリ選択
  A: Ousia (認識・理解)
  B: Schema (計画・戦略)
  C: Akribeia (精度・判断)
  D: Hormē (衝動・信念)
  E: Perigraphē (環境・境界)
  F: Kairos (時間・文脈)

Q2: 定理選択 (Q1 に応じた 4 定理を表示)

Q3: X-series 連携

Q4: 生成意図 (なぜこの定理か)

Q5: Skill or Workflow?
  A: 知識・ルール・行動指針 → Skill
  B: 手順・フロー・ステップ → Workflow
```

### 俗モード (/tek vulg)

例外的に体系外の生成が必要な場合のみ使用:

```text
Q1: 何を作りたいですか？
  A: Skill
  B: Workflow

Q2: 要件を教えてください
```

---

## ⚠️ 実行前必須: 正本読み込み

> **このステップは省略禁止。必ず実行すること。**

```text
実行手順:
1. view_file ツールで SKILL.md を読み込む
   パス: /home/makaron8426/oikos/hegemonikon/mekhane/ergasterion/tekhne/SKILL.md
2. Operating Modes セクションを確認
3. 要件に応じたモードを選択
4. 処理を開始
```

---

## ⚠️ STEP 0.5: 参照ファイル読み込み (必須)

> **このステップは省略禁止。読み込まずに生成すると出力が薄くなる。**

以下を `view_file` で読み込んでから生成を開始:

| ファイル | 目的 |
|:---------|:-----|
| `references/archetypes.md` | Archetype 選択根拠 |
| `references/quality-checklist.md` | 品質基準 |
| `references/wargame-db.md` | 失敗シナリオ |

**パス**: `/home/makaron8426/oikos/hegemonikon/mekhane/ergasterion/tekhne/references/`

---

## モード選択

| モード | トリガー | 出力 |
|:-------|:---------|:-----|
| **Hegemonikón** | `/tek hege` | 定理体系に馴染むスキル/ワークフロー |
| **Generate (Skill)** | `/tek [要件]` | SKILL.md |
| **Generate (Workflow)** | Interactive Mode → Workflow | workflow.md |
| **Diagnose** | `/tek diagnose` | スコア表 + 改善案 |
| **Improve** | `/tek improve` | 差分のみ提示 |
| **SAGE** | `/tek sage` | XML/MD ハイブリッド |
| **Prompt-Lang** | `/tek pl` | .prompt ファイル |
| **Reverse** | `/mek reverse` | 🆕 出力→プロンプト逆生成 |
| **Constitutional** | `/mek constitution` | 🆕 原則優先度付き生成 |
| **YAML** | `/mek yaml` | 🆕 YAML+MD ハイブリッド出力 |
| **Multi-expert** | `/mek multi` | 🆕 並列専門家対話 |

---

## 処理フロー

```text
入力: 要件 / 対象ファイル
  ↓
[STEP 0] SKILL.md を view_file で読み込む ← 必須
  📊 出力: 「✅ STEP 0 完了」
  ↓
[STEP 1] モード判定 ⏱️ 1分
  - 明示的指定がない場合 → Generate
  - diagnose/improve 指定 → 対象ファイル読み込み
  📊 出力: 「✅ STEP 1: モード = {mode}」
  ↓
[STEP 1.5] Information Absorption Layer (@ce) ⏱️ 3分 ← 2026年CE革命
  ┌───────────────────────────────────────────────────┐
  │ 🧠 Context Engineering 原則                       │
  │ 「指示品質 < 背景情報品質」を構造的に強制          │
  │                                                   │
  │ Q1: Creator が「当たり前」と思っている知識は何か？ │
  │ Q2: 対象ドメインの暗黙の前提は何か？               │
  │ Q3: 過去の関連 KI/Handoff は何か？                 │
  │                                                   │
  │ 📐 背景情報3倍則:                                  │
  │   指示トークン × 3 = 必要な背景情報トークン       │
  │                                                   │
  │ → 背景情報が不十分な場合、/zet で追加調査         │
  └───────────────────────────────────────────────────┘
  📊 出力: 「✅ STEP 1.5: Context = {sufficient/insufficient}」
  ↓
[STEP 2] M1 OVERLORD: Semantic Audit ⏱️ 2分
  - 曖昧性検出
  - Hidden Agenda 抽出
  📊 出力: 「✅ STEP 2: 曖昧性 = {N}件」
  ↓
[STEP 3] M2 RECURSIVE_CORE: 3層処理 ⏱️ 5分
  - Layer 1: EXPANSION (拡散)
  - Layer 2: CONFLICT (対立) ← SE早期失敗原則 🔴
    ┌───────────────────────────────────────────────────┐
    │ ⚠️ 失敗シナリオ先行 (Fail Fast)                    │
    │ Q1: この生成物が失敗するとしたら、なぜ？           │
    │ Q2: 最悪のケースは何か？                          │
    │ Q3: その失敗を今の時点で回避できるか？             │
    │ → 答えられない場合、生成を中断して再設計           │
    └───────────────────────────────────────────────────┘
  - Layer 3: CONVERGENCE (収束)
  📊 出力: 「✅ STEP 3: 失敗シナリオ = {検討済/未検討}」
  ↓
[STEP 4] M3 ARCHETYPE_ENGINE: アーキタイプ選択 ⏱️ 2分
  - 5 Diagnostic Questions
  - Precision / Speed / Autonomy / Creative / Safety
  📊 出力: 「✅ STEP 4: Archetype = {type}」
  ↓
[STEP 5] M4 RENDERING_CORE: 出力生成 ⏱️ 5分
  - BLUF Rule 適用
  - Visual Logic Rule 適用
  📊 出力: 「✅ STEP 5: 生成完了」
  ↓
[STEP 6] M5 QUALITY_ASSURANCE: 検証 ⏱️ 2分
  - Pre-Mortem Simulation
  - WARGAME_DB Check
  📊 出力: 「✅ STEP 6: 品質 = {PASS/WARN/FAIL}」
  ↓
[STEP 7] SE反復原則: 初版確認 🔄
  ┌───────────────────────────────────────────────────┐
  │ 🔄 反復原則 (Iteration First)                      │
  │ この生成物は「初版」です。完成品ではありません。    │
  │                                                     │
  │ 次のアクション:                                     │
  │   /dia-  → クイックレビュー（推奨）                 │
  │   /dia+  → 詳細レビュー                            │
  │   継続   → そのまま使用（非推奨）                   │
  └───────────────────────────────────────────────────┘
  ↓
最終出力: 成果物 → ファイル保存
  📊 総括: 「/mek 完了 | 所要時間: {N}分 | 次: /dia- 推奨」
```

---

## --mode=model (モデル構築)

> **CCL**: `/mek.model` = `/mek+{output=model}`
> **目的**: 問題のモデルを構築する
> **Scale**: 🔭 Meso

**発動**: `/mek model` または「モデル」「抽象化」「構造化」

**プロセス**:

```text
1. 対象を観察
   ↓
2. 構成要素を抽出
   ↓
3. 関係を定義
   ↓
4. モデルを検証
   ↓
5. 出力: モデル図 + 定義
```

**出力形式**:

```text
┌─[S2 Mekhanē: Model]──────────────────────────────────┐
│ 対象: {モデル化対象}                                  │
│                                                       │
│ 構成要素:                                             │
│   - {要素1}: {定義}                                   │
│   - {要素2}: {定義}                                   │
│                                                       │
│ 関係:                                                 │
│   {要素1} → {要素2}: {関係の種類}                     │
│                                                       │
│ 検証: {モデルが現実を反映しているか}                  │
└───────────────────────────────────────────────────────┘
```

---

## --mode=simulation (シミュレーション)

> **CCL**: `/mek.simulation` = `/mek+{method=simulate}`
> **目的**: モデルを動かして振る舞いを予測
> **Scale**: 🔭 Meso

**発動**: `/mek simulation` または「シミュレーション」「動かす」「予測」

**プロセス**:

```text
1. モデルを入力
   ↓
2. 初期条件を設定
   ↓
3. シナリオを定義
   ↓
4. 実行して結果を観察
   ↓
5. 出力: シミュレーション結果 + 洞察
```

**出力形式**:

```text
┌─[S2 Mekhanē: Simulation]─────────────────────────────┐
│ モデル: {使用するモデル}                              │
│                                                       │
│ 初期条件:                                             │
│   {パラメータ1} = {値}                                │
│   {パラメータ2} = {値}                                │
│                                                       │
│ シナリオ: {何をシミュレートするか}                    │
│                                                       │
│ 結果:                                                 │
│   T+0: {初期状態}                                     │
│   T+1: {変化}                                         │
│   T+N: {最終状態}                                     │
│                                                       │
│ 洞察: {シミュレーションから得た知見}                  │
└───────────────────────────────────────────────────────┘
```

---

## --mode=yagni (不要機能排除)

> **CCL**: `/mek.yagni` = `/mek-{filter=unnecessary}`
> **目的**: 不要な機能を排除する
> **Scale**: 🔬 Micro

**発動**: `/mek yagni` または「YAGNI」「いらない」「過剰」

**プロセス**:

```text
1. 現在の機能一覧を確認
   ↓
2. 各機能の使用頻度を評価
   ↓
3. 使われていない機能を特定
   ↓
4. 削除の影響を評価
   ↓
5. 出力: 削除候補 + 理由
```

**出力形式**:

```text
┌─[S2 Mekhanē: YAGNI]──────────────────────────────────┐
│ 対象: {評価対象}                                      │
│                                                       │
│ 削除候補:                                             │
│   ✂️ {機能1}: 使用頻度 0%                             │
│   ✂️ {機能2}: 「いつか使うかも」                      │
│                                                       │
│ 保持:                                                 │
│   ✅ {機能3}: アクティブに使用中                      │
│                                                       │
│ 削減効果: 複雑度 -{N}%                                │
└───────────────────────────────────────────────────────┘
```

---

## --mode=dry (重複排除)

> **CCL**: `/mek.dry` = `/mek-{filter=duplicate}`
> **目的**: 重複コード・ロジックを排除
> **Scale**: 🔬 Micro

**発動**: `/mek dry` または「DRY」「重複」「共通化」

**プロセス**:

```text
1. 重複箇所を検出
   ↓
2. 共通パターンを抽出
   ↓
3. 抽象化の方法を決定
   ↓
4. リファクタリング実施
   ↓
5. 出力: 共通化後 + 削減効果
```

**出力形式**:

```text
┌─[S2 Mekhanē: DRY]────────────────────────────────────┐
│ 重複検出:                                             │
│   📍 {ファイル1}:{行} ≈ {ファイル2}:{行}              │
│   📍 {ファイル3}:{行} ≈ {ファイル4}:{行}              │
│                                                       │
│ 共通化案:                                             │
│   {抽出した共通関数/モジュール}                       │
│                                                       │
│ Before: {重複行数}行                                  │
│ After: {共通化後行数}行                               │
│ 削減: {N}% (LOC)                                      │
└───────────────────────────────────────────────────────┘
```

---

## --mode=observability (可観測性)

> **CCL**: `/mek.observability` = `/mek+{feature=monitoring}`
> **目的**: システムの可観測性を設計する
> **Scale**: 🔭 Meso

**発動**: `/mek observability` または「可観測性」「ログ」「メトリクス」「トレース」

**プロセス**:

```text
1. 観測対象を特定
   ↓
2. ログ設計（何を記録するか）
   ↓
3. メトリクス設計（何を計測するか）
   ↓
4. トレース設計（どう追跡するか）
   ↓
5. 出力: 可観測性設計
```

**出力形式**:

```text
┌─[S2 Mekhanē: Observability]──────────────────────────┐
│ 対象: {システム/コンポーネント}                       │
│                                                       │
│ ログ (Logs):                                          │
│   📝 {イベント1}: レベル → {INFO/WARN/ERROR}         │
│   📝 {イベント2}: レベル → {INFO/WARN/ERROR}         │
│                                                       │
│ メトリクス (Metrics):                                 │
│   📊 {メトリクス1}: 単位 → {count/ms/bytes}          │
│                                                       │
│ トレース (Traces):                                    │
│   🔍 {スパン1} → {スパン2} → {スパン3}               │
└───────────────────────────────────────────────────────┘
```

---

## --mode=substitute (代替手段)

> **CCL**: `/mek.substitute` = `/mek+{strategy=alternative}`
> **目的**: 既存の方法の代替手段を発見する
> **Scale**: 🔭 Meso

**発動**: `/mek substitute` または「代替」「別の方法」「置き換え」

**プロセス**:

```text
1. 現在の方法を特定
   ↓
2. 代替候補を列挙
   ↓
3. トレードオフを比較
   ↓
4. 代替の適合度を評価
   ↓
5. 出力: 代替候補 + 比較
```

**出力形式**:

```text
┌─[S2 Mekhanē: Substitute]─────────────────────────────┐
│ 現在の方法: {現在使用している方法}                    │
│                                                       │
│ 代替候補:                                             │
│   🔄 {代替1}: {長所} / {短所}                        │
│   🔄 {代替2}: {長所} / {短所}                        │
│                                                       │
│ 推奨: {代替N} — 理由: {なぜ}                          │
└───────────────────────────────────────────────────────┘
```

---

## --mode=nudge (行動誘導)

> **CCL**: `/mek.nudge` = `/mek+{focus=behavior}`
> **目的**: ユーザー行動を誘導する設計を行う
> **Scale**: 🔬 Micro

**発動**: `/mek nudge` または「ナッジ」「行動誘導」「デフォルト設計」

**プロセス**:

```text
1. 望ましい行動を定義
   ↓
2. 現在のバリアを分析
   ↓
3. ナッジ手法を選択
   ↓
4. 倫理的考慮を確認
   ↓
5. 出力: ナッジ設計
```

**出力形式**:

```text
┌─[S2 Mekhanē: Nudge]──────────────────────────────────┐
│ 望ましい行動: {誘導したい行動}                        │
│                                                       │
│ 現在のバリア:                                         │
│   ❌ {障壁1}                                          │
│   ❌ {障壁2}                                          │
│                                                       │
│ ナッジ設計:                                           │
│   💡 デフォルト: {デフォルト値の設計}                 │
│   💡 フレーミング: {情報の見せ方}                     │
│   💡 社会的証明: {他者の行動を示す}                   │
│                                                       │
│ 倫理的考慮: {操作的でないことの確認}                  │
└───────────────────────────────────────────────────────┘
```

---

## --mode=reverse (逆プロンプト生成) 🆕

> **CCL**: `/mek.reverse` = `/mek*{direction=backward}`
> **Origin**: 2026-02-01 Perplexity Task 4 — Reverse Prompting
> **目的**: 高品質な出力例から、それを再現するプロンプトを逆生成
> **Scale**: 🔭 Meso

**発動**: `/mek reverse` または「この出力を再現」「プロンプト逆生成」

**理論的背景**:

- 良い出力があるが、そのプロンプトがわからない
- 「出力→入力」の逆方向推論
- SAGE Mode のポスト処理として有効

**プロセス**:

```text
┌─────────────────────────────────────────────────────────────┐
│            Reverse Prompting Flow                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [入力: 高品質な出力例]                                      │
│         ↓                                                   │
│  [構造分析]                                                  │
│    - フォーマット抽出                                        │
│    - 論理構造分析                                           │
│    - トーン・スタイル特定                                    │
│         ↓                                                   │
│  [プロンプト要素推定]                                        │
│    - 必須制約（FORMAT）                                     │
│    - 背景情報（CONTEXT）                                    │
│    - 意図（INTENT）                                         │
│         ↓                                                   │
│  [プロンプト生成]                                           │
│         ↓                                                   │
│  [検証: 生成プロンプトで同等出力が得られるか？]              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**出力形式**:

```text
┌─[S2 Mekhanē: Reverse]───────────────────────────────────┐
│ 入力: {出力例の概要}                                     │
│                                                          │
│ 抽出した構造:                                            │
│   FORMAT: {フォーマット特性}                             │
│   TONE: {トーン・スタイル}                               │
│   STRUCTURE: {論理構造}                                  │
│                                                          │
│ 生成したプロンプト:                                      │
│   ```                                                    │
│   {推定されたプロンプト}                                 │
│   ```                                                    │
│                                                          │
│ 信頼度: {HIGH/MEDIUM/LOW}                                │
│ 検証方法: {再実行して比較}                               │
└──────────────────────────────────────────────────────────┘
```

---

## --mode=constitutional (原則優先度付き生成) 🆕

> **CCL**: `/mek.constitutional` = `/mek+{governance=principles}`
> **Origin**: 2026-02-01 Perplexity Task 4 — Constitutional AI 2.0
> **目的**: 原則に優先度を付け、優先原則に反しない生成を保証
> **Scale**: 🔭 Meso

**発動**: `/mek constitution` または「原則に従って」「Constitutional」

**理論的背景**:

- 複数の原則が衝突する場合の解決
- 優先度明示による一貫性担保
- Internal Council に PRINCIPLE 層を追加

**プロセス**:

```text
┌─────────────────────────────────────────────────────────────┐
│            Constitutional AI 2.0 Flow                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [STEP 1: 原則定義]                                         │
│    P1 (最優先): {絶対に守る原則}                            │
│    P2 (重要): {基本的に守る原則}                            │
│    P3 (望ましい): {可能なら守る原則}                        │
│         ↓                                                   │
│  [STEP 2: 草案生成]                                         │
│    通常の生成プロセスを実行                                  │
│         ↓                                                   │
│  [STEP 3: 原則チェック]                                     │
│    P1 違反？ → 全面書き直し                                 │
│    P2 違反？ → 該当部分修正                                 │
│    P3 違反？ → 可能なら調整                                 │
│         ↓                                                   │
│  [STEP 4: 最終出力]                                         │
│    + 「この出力は P1-P3 を満たす」証明付き                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**出力形式**:

```text
┌─[S2 Mekhanē: Constitutional]────────────────────────────┐
│ 原則:                                                    │
│   P1 (必須): {原則1}                                     │
│   P2 (重要): {原則2}                                     │
│   P3 (望ましい): {原則3}                                 │
│                                                          │
│ 生成物:                                                  │
│   {原則に準拠した成果物}                                 │
│                                                          │
│ 準拠証明:                                                │
│   ✅ P1: {準拠理由}                                      │
│   ✅ P2: {準拠理由}                                      │
│   ⚠️ P3: {部分的準拠 or トレードオフ}                    │
└──────────────────────────────────────────────────────────┘
```

---

## --mode=yaml (YAML+MD ハイブリッド出力) 🆕

> **CCL**: `/mek.yaml` = `/mek+{format=yaml_hybrid}`
> **Origin**: 2026-02-01 Perplexity Task 4 — YAML Structured Prompting
> **目的**: 構造化データは YAML、説明文は Markdown のハイブリッド出力
> **Scale**: 🔬 Micro

**発動**: `/mek yaml` または「YAML 形式」「構造化出力」

**理論的背景**:

- XML より人間可読性が高い
- LLM との親和性が高いフォーマット
- 構造データと説明文の分離

**出力形式**:

```yaml
---
# ヘッダー部：YAML
title: "{タイトル}"
version: "1.0"
created: "2026-02-01"
metadata:
  scale: "Meso"
  archetype: "Precision"
  confidence: "HIGH"
---

# 本文部：Markdown

## 概要

{説明文はMarkdownで記述}

## 構造データ

```yaml
items:
  - name: "{項目1}"
    value: "{値1}"
  - name: "{項目2}"
    value: "{値2}"
```

## 結論

{結論・推奨事項}

```

---

## --mode=multi (並列専門家対話) 🆕

> **CCL**: `/mek.multi` = `/mek+{actors=parallel_experts}`
> **Origin**: 2026-02-01 Perplexity Task 4 — Multi-expert Prompting
> **目的**: 複数専門家を並列実行し、統合見解を生成
> **Scale**: 🔭 Meso

**発動**: `/mek multi` または「複数専門家」「並列エキスパート」

**理論的背景**:
- 単一視点の限界を超える
- CONFLICT フェーズの強化版
- `/dia.deliberative` との補完関係

**プロセス**:

```text
┌─────────────────────────────────────────────────────────────┐
│            Multi-expert Prompting Flow                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [並列実行]                                                 │
│    ┌─────────┐  ┌─────────┐  ┌─────────┐                   │
│    │Expert A │  │Expert B │  │Expert C │                   │
│    │技術専門 │  │ビジネス │  │ユーザー │                   │
│    └────┬────┘  └────┬────┘  └────┬────┘                   │
│         ↓            ↓            ↓                        │
│    {出力A}       {出力B}       {出力C}                      │
│         └────────────┼────────────┘                        │
│                      ↓                                      │
│  [衝突検出]                                                 │
│    A vs B: {衝突点1}                                        │
│    B vs C: {衝突点2}                                        │
│                      ↓                                      │
│  [統合見解]                                                 │
│    調停案 + トレードオフ明示                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**出力形式**:

```text
┌─[S2 Mekhanē: Multi-expert]──────────────────────────────┐
│ 課題: {分析対象}                                         │
│                                                          │
│ 【Expert A: {専門分野1}】                                │
│   見解: {見解A}                                          │
│                                                          │
│ 【Expert B: {専門分野2}】                                │
│   見解: {見解B}                                          │
│                                                          │
│ 【Expert C: {専門分野3}】                                │
│   見解: {見解C}                                          │
│                                                          │
│ 衝突点:                                                  │
│   ⚡ A vs B: {衝突内容}                                  │
│   ⚡ B vs C: {衝突内容}                                  │
│                                                          │
│ 統合見解:                                                │
│   「{調停された最終見解}」                               │
│                                                          │
│ トレードオフ: {何を優先し、何を犠牲にしたか}             │
└──────────────────────────────────────────────────────────┘
```

---

## Artifact 自動保存

> **標準参照**: [workflow_artifact_standard.md](file:///home/makaron8426/oikos/.agent/standards/workflow_artifact_standard.md)
> **SE原則強制**: 必須フィールドがないとブロック（Standard 参照）

### 必須フィールド（SE原則）

| フィールド | 必須条件 | 違反時 |
|:-----------|:---------|:-------|
| `## 失敗シナリオ` | Meso 以上 | ⛔ ブロック |
| `→ 初版` マーカー | 全 Scale | ⛔ ブロック |
| `⏱️ 所要時間` | Meso 以上 | ⚠️ 警告 |

### 出力テンプレート [必須]

> **参照**: [mek_output.md](file:///home/makaron8426/oikos/.agent/templates/mek_output.md)

出力は上記テンプレートに従うこと。フィールドが欠けているとブロック。

### 検証 (validator)

```bash
python hegemonikon/mekhane/fep/se_principle_validator.py <output.md> --workflow mek
```

### 保存先

```
/home/makaron8426/oikos/mneme/.hegemonikon/workflows/mek_<purpose>_<date>.md
```

例: `mek_code_review_skill_20260129.md`

### チャット出力規則

**チャットには最小限の出力のみ。詳細は全てファイルに保存。**

```text
✅ /mek 完了
📄 /mneme/.hegemonikon/workflows/mek_{purpose}_{date}.md
要約: {生成物タイプ} ({モード})
→ {推奨次ステップ}
```

### 保存する理由

1. **コンテキスト節約**: チャット履歴を汚さない
2. **参照可能**: 生成物を後から確認できる
3. **蓄積可能**: 生成パターンの分析に活用

---

## 計算コスト試算

| ステップ | トークン数 | 時間目安 |
|:---------|:-----------|:---------|
| STEP 1-2 | 200-400 | 1-2秒 |
| STEP 3 | 800-1500 | 5-10秒 |
| STEP 4-5 | 500-1000 | 3-5秒 |
| STEP 6 | 300-500 | 2-3秒 |
| **合計** | **1800-3400** | **11-20秒** |

---

## 使用例

### 例1: 新規スキル生成

```text
/tek 「Perplexity への調査依頼を高精度化するスキル」

→ tekhne-maker が:
  1. 5 Diagnostic Questions で Precision Archetype 選択
  2. RECURSIVE_CORE で構造設計
  3. SKILL.md 形式で出力
```

### 例2: 既存スキル診断

```text
/tek diagnose /home/makaron8426/oikos/.agent/skills/ousia/o1-noesis/SKILL.md

→ tekhne-maker が:
  1. Quality Checklist で5項目スコア算出
  2. 弱点と改善案を提示
```

### 例3: 既存スキル改善

```text
/tek improve /home/makaron8426/oikos/.agent/skills/ousia/o1-noesis/SKILL.md

→ tekhne-maker が:
  1. Diagnose 実行
  2. 改善差分のみを提示
```

---

## --mode=visual (視覚的成果物生成) 🍌くん

> **CCL**: `/mek.visual` = `/mek+{output=image}`
> **目的**: 視覚的成果物（UI画像、インフォグラフィック）を生成する
> **Scale**: 🔭 Meso
> **Origin**: 2026-02-06 /sop 調査ベース

**発動**: `/mek visual` または「画像」「モックアップ」「スクショ」「インフォグラフィック」

### プロンプト構造テンプレート

#### ソフトウェアUI再現

```text
A realistic screenshot of [ソフトウェア名] [バージョン] on [OS],
showing [画面の状態]. Japanese interface.

EXACT WINDOW STRUCTURE (top to bottom):

1. TITLE BAR: "[タイトル]" with [OS] minimize/maximize/close buttons
2. MENU BAR (exact order): [メニュー項目...]
3. TOOLBAR: [ツールバー要素...]
4. MAIN CONTENT AREA:
   - TOP SECTION: [上部]
   - LEFT SIDE (X% width): [左側]
   - RIGHT SIDE (Y% width): [右側]
5. FOOTER: [ステータスバー]

Style: Photorealistic [OS] screenshot. NOT a mockup.
```

#### ワークフローガイド/インフォグラフィック

```text
A professional Japanese workflow guide infographic.
TITLE: "[日本語タイトル]"
TIMELINE showing [N] steps with icons and times:
STEP 1 ([時間]) [アイコン]: "[手順名]" - [詳細]
...
Design: Clean, minimalist Japanese infographic.
```

### 精度向上原則

| 要因 | 低精度 | 高精度 |
|:-----|:-------|:-------|
| **抽象度** | 「UIを作って」 | 「FileMaker Pro 2024のWindows画面」 |
| **構造** | 「ボタンを配置」 | 「TITLE BAR → MENU BAR → TOOLBAR → CONTENT」 |
| **スタイル** | 「きれいに」 | 「photorealistic screenshot, NOT a mockup」 |

### 日本語テキスト対策

**制限**: 25文字以下が最適（Imagen調査）

| 状況 | 推奨アプローチ |
|:-----|:---------------|
| **短いラベル（5文字以下）** | そのまま日本語で指示 |
| **中程度（6-15文字）** | 英語で生成→後から画像編集 |
| **長いテキスト（16文字以上）** | テキストなしで生成 |

### 必須テクニック

1. **Critical Constraint Repetition**: 冒頭と末尾に制約を繰り返す
2. **Negative Prompts**: 「DO NOT include: device frames, watermarks...」
3. **Weighted Style Blending**: 「60% photorealistic, 30% minimalist」

**出力形式**:

```text
┌─[S2 Mekhanē: Visual]─────────────────────────────────┐
│ 生成対象: {何を生成するか}                            │
│ プロンプト: {構造化プロンプト}                        │
│ 出力: {画像ファイルパス}                              │
│ 品質確認: {日本語精度/構造再現度}                     │
└───────────────────────────────────────────────────────┘
```

---

## --mode=manual (マニュアル生成)

> **CCL**: `/mek.manual` = `/mek+{output=procedure}`
> **目的**: Gemini/Jules向けの作業マニュアルを生成する
> **Scale**: 🔭 Meso
> **Origin**: /manual ワークフロー統合

**発動**: `/mek manual` または「マニュアル」「手順書」「作業指示」

### コア原則（粒度ルール）— Gemini補完防止

> **Geminiは「言われていないこと」を補完する。**
> マニュアルは**補完の余地がない粒度**でなければならない。

| # | ルール | ❌ NG | ✅ OK |
|---|--------|-------|-------|
| 1 | **行番号を指定** | 「表を更新」 | 「58行目〜64行目の表を更新」 |
| 2 | **完全コピー可能** | 「Taxis行を追加」 | 「以下を貼り付け: `│ **Taxis** │...`」 |
| 3 | **before/after** | 「表記を統一」 | 「【変更前】Kairos → 【変更後】K-series」 |
| 4 | **禁止事項明記** | （記載なし） | 「列順を変更しない」 |

### オプション

| オプション | 出力形式 | 用途 |
|:-----------|:---------|:-----|
| (デフォルト) | Markdown マニュアル | Gemini同期作業 |
| `--jules` | GitHub Issue形式 | Jules夜間バッチ |

### 各ファイル変更の記述形式

```markdown
### ファイル: [パス]

#### 変更1: [変更内容]

**位置**: [行番号]
**操作**: [追加/更新/削除]

**追加コンテンツ（完全コピー）**:
[コピペ可能なコンテンツ]

**変更後の完全形**:
[変更後の全体像]

**禁止事項**:
- [具体的な禁止事項]
```

**出力形式**:

```text
┌─[S2 Mekhanē: Manual]─────────────────────────────────┐
│ 入力: {設計ドキュメントパス}                          │
│ 生成: docs/update_manual_{name}.md                   │
│ 影響: {N}ファイル                                     │
│ 対象: Gemini / Jules                                 │
└───────────────────────────────────────────────────────┘
```

---

## Hegemonikon Status

| Module | Workflow | Skill (正本) | Status |
|:-------|:---------|:-------------|:-------|
| tekhne-maker | /tek | [SKILL.md](file:///home/makaron8426/oikos/hegemonikon/mekhane/ergasterion/tekhne/SKILL.md) | v5.0 Ready |

---

*v5.0 — Hegemonikón Mode デフォルト化 (2026-01-28)*
*v6.10 — visual, manual モード追加 (2026-02-06)*
