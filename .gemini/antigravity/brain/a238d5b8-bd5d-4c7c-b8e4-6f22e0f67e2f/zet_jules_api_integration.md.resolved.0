# 調査依頼書（深掘り版）

テーマ: Claude から Jules API を呼び出し、18並列コード生成ワーカーとして活用する方法

---

## 0. あなた（調査者）への依頼（最重要）

私は **Claude（Antigravity IDE内）を親エージェント、Jules API（Gemini）を子ワーカー** として活用し、18並列でコード生成タスクを処理するシステムを設計している。

以下について、**一般論で終わらせず**、2025-2026時点の最新仕様・挙動・制約を**一次情報と再現性のある検証情報**で裏付けてほしい:

1. **Jules API の正確な仕様**（エンドポイント、認証方式、リクエスト形式）
2. **Claude から外部 API を呼び出す方法**（MCP Server 経由 vs HTTP 直接 vs その他）
3. **18並列実行のオーケストレーション設計**（並列数制限、レート制限、エラーハンドリング）

結論は「どっちが上」ではなく、**用途ごとの最適選択**と**運用設計（併用時の役割分担）**まで落とし込んで提示してほしい。

---

## 1. 調査対象の定義（用語の揺れに対応）

### 1-1. 製品名・モード名の確認

まず以下を確定してください（曖昧なまま比較しないこと）:

- **Jules**: Google の AI コーディングエージェント。Jules = WEB UI版 と Jules API は同一か？
- **Jules API**: GitHub と連携するアシンク実行か、同期API呼び出しか？
- **Gemini API との関係**: Jules は Gemini API の上位レイヤーか、独立サービスか？

### 1-2. 比較対象

- Claude から MCP Server 経由で Jules API を呼び出す
- Claude から HTTP 直接で Jules API を呼び出す
- Claude から GitHub Actions 経由で Jules を起動する
- その他のアプローチ（あれば）

---

## 2. 調査すべき論点（抜け漏れ禁止）

### A. Jules API 仕様（2025-2026 最新）

**A1. エンドポイント**
- 公開 API エンドポイントは存在するか？
- 認証方式（API キー? OAuth? GitHub App token?）
- リクエスト/レスポンス形式（REST? gRPC?）

**A2. 実行モデル**
- 同期（リクエスト→即レスポンス）か非同期（task submission→polling）か
- コンテキスト渡し方法（ファイル指定? リポジトリ全体? 差分?）
- 出力形式（コード差分? 完成ファイル? PR?）

**A3. 制限**
- レート制限（RPM, 並列数）
- コンテキストサイズ上限
- 実行時間制限

### B. Claude からの呼び出し方法

**B1. MCP Server 経由**
- Antigravity IDE で MCP Server を作成し、そこから Jules API を呼び出す設計は可能か
- 実装例（既存の MCP Server パターン参照）
- メリット/デメリット

**B2. HTTP 直接呼び出し**
- Claude は `run_command` で `curl` を実行できる
- HTTP クライアントスクリプト（Python `requests`）を Claude に実行させる
- メリット/デメリット

**B3. GitHub Actions 経由**
- Claude が GitHub Actions workflow をトリガー
- Actions 内で Jules を起動
- 非同期だが、多数のジョブを並列起動可能
- メリット/デメリット

### C. 18並列オーケストレーション

**C1. 並列実行パターン**
- Fan-out/Fan-in パターン
- タスクキュー + ワーカープール
- 単純並列（全タスク同時投入）

**C2. エラーハンドリング**
- Retry 戦略
- Partial failure 時の処理
- タイムアウト設計

**C3. コスト最適化**
- 18 API キーを効率的にローテーションする方法
- レート制限を回避しつつ最大スループットを達成

### D. 製品・運用上の制約

- 料金体系（Jules API は従量? 固定?）
- API キーの発行方法と管理
- GitHub リポジトリとの連携要件（public/private）
- セキュリティ（コード流出リスク、API キー管理）

---

## 3. 成果物（この構成で必ず提出）

1. **結論サマリー**（10行以内）
2. **Jules API 仕様まとめ**（エンドポイント、認証、制限）
3. **呼び出し方法比較表**（MCP / HTTP / Actions）
4. **推奨アーキテクチャ**（具体的な設計図）
5. **18並列オーケストレーション設計案**
6. **根拠リンク**（必須）:
   - Google/Jules 公式ドキュメント
   - GitHub Marketplace / Actions ドキュメント
   - 実装者ブログ/技術記事（信頼性評価付き）

---

## 4. 調査ルール（品質担保）

- **新情報優先**: 2025-2026の情報を優先（Jules は新サービスなので2024以前は無視）
- **事実/推測分離**: 必ず明確に分離
- **根拠必須**: 「一般に〜と言われる」で終わらず、根拠・再現例・反例を提示
- **決断可能**: 結論は用途別に必ず決断できる形に

---

## 5. 与件（ユーザー観測データ/背景/制約/目的）

- **目的**: Claude を親、Jules API を子とするマルチエージェントシステムの設計
- **前提条件**:
  - Antigravity IDE（Claude）が動作中
  - JULIUS_API_KEY_1〜18 を GitHub Secrets に設定済み
  - GitHub Actions ワークフロー（Scheduled Tasks 用）は作成済み
- **優先する評価軸**: 
  1. **実装可能性**（今すぐ動くか）
  2. **並列性能**（18並列を活かせるか）
  3. **シンプルさ**（保守しやすいか）

---

*Generated by Hegemonikón O3 Zētēsis*
