# Project Dendron — 存在証明の木探索

> **δένδρον (dendron)** = 木。存在証明を木構造として全階層に展開

---

## プロジェクト概要

| 項目 | 内容 |
|------|------|
| **名称** | Dendron (デンドロン) |
| **目的** | 全リポジトリに存在証明を注入 |
| **手法** | 木探索 (深さ優先) |
| **粒度** | 4層 |

---

## 4層構造

```
Layer 0: ディレクトリ   → PROOF.md
Layer 1: ファイル       → PROOF ヘッダー
Layer 2: コード/文      → 関数・クラス docstring
Layer 3: 字句/単語      → 変数・パラメータ命名
```

### 現状

| Layer | 状態 | 完了率 |
|-------|------|--------|
| **L0 ディレクトリ** | ✅ 完了 | 100% |
| **L1 ファイル** | ✅ 完了 | 100% (203 files) |
| **L2 コード** | ❌ 未着手 | 0% |
| **L3 字句** | ❌ 未着手 | 0% |

---

## 実行計画: Layer 2 (コード/文)

### 2.1 対象

各ファイル内の:
- 関数 ([def](file:///home/laihuip001/oikos/hegemonikon/mekhane/fep/fep_agent.py#115-169))
- クラス (`class`)
- 重要なコードブロック

### 2.2 証明形式

```python
def example_function():
    """
    PROOF: [L2/関数]
    
    呼び出し元 → この機能が必要
              → この関数が担う
    
    Args:
        ...
    """
```

### 2.3 優先順位

1. **L1 ファイル (29件)** — 定理コア: 最重要
2. **L2 ファイル (86件)** — インフラ: 重要
3. **L3 ファイル (87件)** — テスト: 省略可

### 2.4 自動化案

```python
# ast でパース → docstring なき関数を検出
# LLM で存在証明を生成 → 挿入
```

---

## 実行計画: Layer 3 (字句/単語)

### 3.1 対象

- 変数名
- パラメータ名
- 定数名

### 3.2 証明形式

命名規則自体が証明。「なぜこの名前か」が自明であること。

```python
# 良い例: 名前が証明
prediction_error  # 予測誤差であることが自明

# 悪い例: 証明不在
pe  # 意味不明
```

### 3.3 アプローチ

- 命名規則チェッカー (ruff + custom rules)
- 略語辞書の整備

---

## 長期ビジョン (/tak+ 登録)

| 層 | 状態 | 次の一手 |
|---|------|---------|
| 表層 | ✅ PROOF 完了 | — |
| 構造層 | ❓ 依存関係未整理 | import graph 可視化 |
| 機能層 | ❓ 重複未検出 | 機能類似度マトリクス |
| 実証層 | ❌ 未着手 | 削除テスト (L3 → L2 → L1) |

---

## 次のステップ

> **承認待ち**: 以下のいずれかを選択

1. **Layer 2 実行**: L1 ファイル (29件) の関数 docstring に PROOF 追加
2. **自動化優先**: Layer 2 用のスクリプト開発
3. **長期ビジョン優先**: import graph 可視化へ移行

---

*Project Dendron — ccl/mek+ generated plan*
