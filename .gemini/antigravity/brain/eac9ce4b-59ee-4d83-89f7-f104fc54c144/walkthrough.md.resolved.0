# Walkthrough: è»¸ A - Handoff æ´»ç”¨å¼·åŒ–

> **å®Œäº†æ—¥**: 2026-01-31
> **å¯¾è±¡**: [handoff_search.py](file:///home/laihuip001/oikos/hegemonikon/mekhane/symploke/handoff_search.py)

---

## å®Ÿè£…å†…å®¹

### æ–°è¦ API

| é–¢æ•° | ç”¨é€” |
|:-----|:-----|
| [get_boot_handoffs(mode, context)](file:///home/laihuip001/oikos/hegemonikon/mekhane/symploke/handoff_search.py#63-108) | /boot çµ±åˆ API |
| [format_boot_output(result, verbose)](file:///home/laihuip001/oikos/hegemonikon/mekhane/symploke/handoff_search.py#110-133) | å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ |

### CLI ã‚ªãƒ—ã‚·ãƒ§ãƒ³

```bash
# /boot- (é«˜é€Ÿ)
python handoff_search.py --boot fast

# /boot (æ¨™æº–)
python handoff_search.py --boot standard

# /boot+ (è©³ç´°)
python handoff_search.py --boot detailed
```

---

## æ¤œè¨¼çµæœ

### /boot (standard)

```
ğŸ“‹ æœ€æ–° Handoff:
  ID: handoff-handoff_final_2026-01-29
  ä¸»é¡Œ: Unknown
  æ™‚åˆ»: 2026-01-31T09:31:31.595667

ğŸ”— é–¢é€£ Handoff (3ä»¶):
  â€¢ Unknown (2026-01-28T20:19:00)
  â€¢ Unknown (2026-01-28T18:35:00)
  â€¢ H3 SymplokÄ“ å®Ÿè£…å®Œäº† + Handoff v2 è¨­è¨ˆ (2026-01-27)
```

### /boot+ (detailed)

```
ğŸ”— é–¢é€£ Handoff (10ä»¶):
  â€¢ Unknown
  â€¢ H3 SymplokÄ“ å®Ÿè£…å®Œäº† + Handoff v2 è¨­è¨ˆ
  â€¢ Wishlist æ®‹é …ç›®æ¶ˆåŒ– (W6â†’W8â†’W9â†’W11)
  â€¢ /boot v3.0 åˆ†æãƒ»æ”¹å–„ + å„ªå…ˆé †ä½ç­–å®š
  â€¢ FEP Integration & Jules 59-Branch Completion
  â€¢ Jules 6ãƒšãƒ«ã‚½ãƒŠã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ â†’ 18 API æ è¨­è¨ˆ
  â€¢ Ï„-Workflow è¦ªå­ãƒ‘ã‚¿ãƒ¼ãƒ³å¾©å…ƒ + å“è³ªåˆ†æ
  â€¢ Skill description æœ€é©åŒ– + å…¨ä½“ã‚·ã‚¹ãƒ†ãƒ ç›£æŸ»
  ... (10ä»¶)
```

---

## å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«

```diff:handoff_search.py
#!/usr/bin/env python3
# PROOF: [L2/ã‚¤ãƒ³ãƒ•ãƒ©] A0â†’çŸ¥è­˜ç®¡ç†ãŒå¿…è¦â†’handoff_search ãŒæ‹…ã†
"""
Handoff Search - /boot æ™‚ã«é–¢é€£ Handoff ã‚’æ¤œç´¢

Usage:
    python handoff_search.py "query"                # Similar handoffs
    python handoff_search.py --latest               # Show latest handoff
    python handoff_search.py --recent 3             # Show 3 most recent
"""

import sys
import argparse
from pathlib import Path
from typing import List, Tuple

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from mekhane.symploke.kairos_ingest import get_handoff_files, parse_handoff
from mekhane.symploke.adapters.embedding_adapter import EmbeddingAdapter
from mekhane.symploke.indices import Document


def load_handoffs() -> List[Document]:
    """Load all handoffs as documents."""
    files = get_handoff_files()
    return [parse_handoff(f) for f in files]


def search_handoffs(query: str, top_k: int = 5) -> List[Tuple[Document, float]]:
    """Search handoffs by semantic similarity."""
    docs = load_handoffs()
    if not docs:
        return []
    
    # Initialize embedding adapter
    adapter = EmbeddingAdapter(model_name="all-MiniLM-L6-v2")
    
    # Encode all docs
    texts = [d.content for d in docs]
    doc_vectors = adapter.encode(texts)
    
    # Create index and add vectors
    adapter.create_index(dimension=doc_vectors.shape[1])
    metadata = [{"doc_id": d.id, "primary_task": d.metadata.get("primary_task", "")} for d in docs]
    adapter.add_vectors(doc_vectors, metadata=metadata)
    
    # Search
    query_vector = adapter.encode([query])[0]
    results = adapter.search(query_vector, k=top_k)
    
    # Match results to docs
    matched = []
    for r in results:
        idx = r.id
        if idx < len(docs):
            matched.append((docs[idx], r.score))
    
    return matched


def show_latest(n: int = 1):
    """Show N most recent handoffs."""
    docs = load_handoffs()[:n]
    for doc in docs:
        print(f"\n{'='*60}")
        print(f"ğŸ“„ {doc.id}")
        print(f"ä¸»é¡Œ: {doc.metadata.get('primary_task', 'Unknown')}")
        print(f"æ™‚åˆ»: {doc.metadata.get('timestamp', 'Unknown')}")
        print("-"*60)
        print(doc.content[:500] + "..." if len(doc.content) > 500 else doc.content)


def main():
    parser = argparse.ArgumentParser(description="Search handoffs for /boot")
    parser.add_argument("query", nargs="?", help="Search query")
    parser.add_argument("--latest", action="store_true", help="Show latest handoff")
    parser.add_argument("--recent", type=int, help="Show N most recent handoffs")
    parser.add_argument("-k", type=int, default=3, help="Number of results")
    args = parser.parse_args()
    
    if args.latest:
        show_latest(1)
    elif args.recent:
        show_latest(args.recent)
    elif args.query:
        print(f"ğŸ” Searching: \"{args.query}\"\n")
        results = search_handoffs(args.query, top_k=args.k)
        
        if not results:
            print("No matching handoffs found.")
            return
        
        for doc, score in results:
            print(f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
            print(f"ğŸ“Š Score: {score:.3f}")
            print(f"ğŸ“„ {doc.id}")
            print(f"ä¸»é¡Œ: {doc.metadata.get('primary_task', 'Unknown')}")
            print(f"æ™‚åˆ»: {doc.metadata.get('timestamp', 'Unknown')}")
            print()
    else:
        # Default: show latest
        show_latest(1)


if __name__ == "__main__":
    main()
===
#!/usr/bin/env python3
# PROOF: [L2/ã‚¤ãƒ³ãƒ•ãƒ©] A0â†’çŸ¥è­˜ç®¡ç†ãŒå¿…è¦â†’handoff_search ãŒæ‹…ã†
"""
Handoff Search - /boot æ™‚ã«é–¢é€£ Handoff ã‚’æ¤œç´¢

Usage:
    python handoff_search.py "query"                # Similar handoffs
    python handoff_search.py --latest               # Show latest handoff
    python handoff_search.py --recent 3             # Show 3 most recent
"""

import sys
import argparse
from pathlib import Path
from typing import List, Tuple

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from mekhane.symploke.kairos_ingest import get_handoff_files, parse_handoff
from mekhane.symploke.adapters.embedding_adapter import EmbeddingAdapter
from mekhane.symploke.indices import Document


def load_handoffs() -> List[Document]:
    """Load all handoffs as documents."""
    files = get_handoff_files()
    return [parse_handoff(f) for f in files]


def search_handoffs(query: str, top_k: int = 5) -> List[Tuple[Document, float]]:
    """Search handoffs by semantic similarity."""
    docs = load_handoffs()
    if not docs:
        return []
    
    # Initialize embedding adapter
    adapter = EmbeddingAdapter(model_name="all-MiniLM-L6-v2")
    
    # Encode all docs
    texts = [d.content for d in docs]
    doc_vectors = adapter.encode(texts)
    
    # Create index and add vectors
    adapter.create_index(dimension=doc_vectors.shape[1])
    metadata = [{"doc_id": d.id, "primary_task": d.metadata.get("primary_task", "")} for d in docs]
    adapter.add_vectors(doc_vectors, metadata=metadata)
    
    # Search
    query_vector = adapter.encode([query])[0]
    results = adapter.search(query_vector, k=top_k)
    
    # Match results to docs
    matched = []
    for r in results:
        idx = r.id
        if idx < len(docs):
            matched.append((docs[idx], r.score))
    
    return matched


def get_boot_handoffs(mode: str = "standard", context: str = None) -> dict:
    """
    /boot çµ±åˆ API: ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ãŸ Handoff ã‚’è¿”ã™
    
    Args:
        mode: "fast" (/boot-), "standard" (/boot), "detailed" (/boot+)
        context: ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆï¼ˆæ¤œç´¢ã‚¯ã‚¨ãƒªã«ä½¿ç”¨ï¼‰
    
    Returns:
        dict: {
            "latest": Document,           # æœ€æ–°ã® Handoff
            "related": List[Document],    # é–¢é€£ã™ã‚‹ Handoff
            "count": int                  # é–¢é€£ä»¶æ•°
        }
    """
    # ãƒ¢ãƒ¼ãƒ‰ã«ã‚ˆã‚‹é–¢é€£ä»¶æ•°
    related_count = {
        "fast": 0,       # /boot- : æœ€æ–°ã®ã¿
        "standard": 3,   # /boot  : æœ€æ–° + é–¢é€£ 3
        "detailed": 10   # /boot+ : æœ€æ–° + é–¢é€£ 10
    }.get(mode, 3)
    
    docs = load_handoffs()
    if not docs:
        return {"latest": None, "related": [], "count": 0}
    
    latest = docs[0]
    
    # é–¢é€£æ¤œç´¢
    related = []
    if related_count > 0 and context:
        results = search_handoffs(context, top_k=related_count + 1)
        # æœ€æ–°ã‚’é™¤å¤–
        related = [doc for doc, score in results if doc.id != latest.id][:related_count]
    elif related_count > 0:
        # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãªã—ã®å ´åˆã¯æœ€æ–°ã‹ã‚‰æŠ½å‡º
        query = latest.metadata.get("primary_task", latest.content[:200])
        results = search_handoffs(query, top_k=related_count + 1)
        related = [doc for doc, score in results if doc.id != latest.id][:related_count]
    
    return {
        "latest": latest,
        "related": related,
        "count": len(related)
    }


def format_boot_output(result: dict, verbose: bool = False) -> str:
    """
    /boot ç”¨ã®å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
    """
    lines = []
    
    if result["latest"]:
        doc = result["latest"]
        lines.append("ğŸ“‹ æœ€æ–° Handoff:")
        lines.append(f"  ID: {doc.id}")
        lines.append(f"  ä¸»é¡Œ: {doc.metadata.get('primary_task', 'Unknown')}")
        lines.append(f"  æ™‚åˆ»: {doc.metadata.get('timestamp', 'Unknown')}")
        if verbose:
            lines.append(f"  å†…å®¹: {doc.content[:300]}...")
        lines.append("")
    
    if result["related"]:
        lines.append(f"ğŸ”— é–¢é€£ Handoff ({result['count']}ä»¶):")
        for doc in result["related"]:
            lines.append(f"  â€¢ {doc.metadata.get('primary_task', doc.id)}")
            lines.append(f"    æ™‚åˆ»: {doc.metadata.get('timestamp', 'Unknown')}")
    
    return "\n".join(lines)


def show_latest(n: int = 1):
    """Show N most recent handoffs."""
    docs = load_handoffs()[:n]
    for doc in docs:
        print(f"\n{'='*60}")
        print(f"ğŸ“„ {doc.id}")
        print(f"ä¸»é¡Œ: {doc.metadata.get('primary_task', 'Unknown')}")
        print(f"æ™‚åˆ»: {doc.metadata.get('timestamp', 'Unknown')}")
        print("-"*60)
        print(doc.content[:500] + "..." if len(doc.content) > 500 else doc.content)


def main():
    parser = argparse.ArgumentParser(description="Search handoffs for /boot")
    parser.add_argument("query", nargs="?", help="Search query")
    parser.add_argument("--latest", action="store_true", help="Show latest handoff")
    parser.add_argument("--recent", type=int, help="Show N most recent handoffs")
    parser.add_argument("-k", type=int, default=3, help="Number of results")
    parser.add_argument("--boot", choices=["fast", "standard", "detailed"], 
                       help="/boot mode: fast (-), standard, detailed (+)")
    parser.add_argument("--context", type=str, help="Context for /boot search")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")
    args = parser.parse_args()
    
    # /boot mode
    if args.boot:
        result = get_boot_handoffs(mode=args.boot, context=args.context)
        print(format_boot_output(result, verbose=args.verbose))
        return
    
    if args.latest:
        show_latest(1)
    elif args.recent:
        show_latest(args.recent)
    elif args.query:
        print(f"ğŸ” Searching: \"{args.query}\"\n")
        results = search_handoffs(args.query, top_k=args.k)
        
        if not results:
            print("No matching handoffs found.")
            return
        
        for doc, score in results:
            print(f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
            print(f"ğŸ“Š Score: {score:.3f}")
            print(f"ğŸ“„ {doc.id}")
            print(f"ä¸»é¡Œ: {doc.metadata.get('primary_task', 'Unknown')}")
            print(f"æ™‚åˆ»: {doc.metadata.get('timestamp', 'Unknown')}")
            print()
    else:
        # Default: show latest
        show_latest(1)


if __name__ == "__main__":
    main()
```

---

## æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

1. **è»¸ B**: Sophia ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³
2. **è»¸ C**: äººæ ¼æ°¸ç¶šåŒ–
3. **/boot.md ã¸ã®çµ±åˆ**: æ–° API ã‚’ /boot ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«çµ„ã¿è¾¼ã¿
