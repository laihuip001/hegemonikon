# CCL 演算子仕様 v6.55

> **正本**: この文書は ccl/operators.md であり、全演算子仕様を定義する

## 1. 単項演算子

### 1.1 強度演算子

| 記号 | 名称 | 作用 | 例 |
|:-----|:-----|:-----|:---|
| `+` | 深化 | 出力規模 3-5倍。詳細な根拠を追加。 | `/noe+` |
| `-` | 縮約 | 出力規模 0.3-0.5倍。要点のみ。 | `/bou-` |

### 1.2 次元演算子

| 記号 | 名称 | 作用 | 例 |
|:-----|:-----|:-----|:---|
| `^` | 上昇 | メタ前提の検証。メタ化。 | `/dia^` |
| `√` | 下降 | 次元を下げる。具体的アクション。 | `√/noe` |

### 1.3 制御演算子

| 記号 | 名称 | 作用 | 例 |
|:-----|:-----|:-----|:---|
| `\` | 反転 | 位相反転（Antistrophē）。構造的否定。 | `\a` |
| `!` | 全展開 | 封印解除。全派生を並列展開。 | `/s!` |

### 1.4 FEP 演算子 (v6.5)

| 記号 | 名称 | FEP 意味 | 例 |
|:-----|:-----|:---------|:---|
| `'` | 微分 | 予測誤差の変化率 ($d\epsilon/dt$) | `/bou'` |
| `∂` | 偏微分 | 特定次元の変化率 ($\partial f/\partial x$) | `∂s1/bou` |
| `∫` | 積分 | 履歴統合、累積 ($\int\epsilon dt$) | `∫/dox` |
| `Σ` | 総和 | 複数結果の集約 ($\Sigma x_i$) | `Σ[results]` |
| `lim[cond]{}` | 収束 | 極限、予測誤差最小化の終着点 | `lim[ε=0]{/s~dia}` |

### 1.5 型記法 (Pythōsis Phase 3) v6.51

> **Origin**: Python `typing` モジュールの消化
> **目的**: CCL 出力に型制約を宣言し、/epi.typed で静的検証

| 記号 | 名称 | Python 対応 | 例 |
|:-----|:-----|:------------|:---|
| `?T` | 不確実型 | `Optional[T]` | `/noe+{out: ?string}` |
| `[T]` | 複数型 | `List[T]` | `/zet+{out: [question]}` |
| `A\|B` | 選択型 | `Union[A, B]` | `/dia{out: pass\|fail}` |
| `:T` | 型注釈 | Type hint | `/ene{task: string}` |

**使用例**:

```ccl
# 出力型を宣言
/noe+{out: ?insight}  # Optional[insight] — 洞察が得られないかもしれない

# リスト出力
/zet+{out: [question]}  # List[question] — 複数の問いを生成

# 選択型
/dia{out: pass|fail}    # Union[pass, fail] — 二択

# /epi.typed で検証
/epi.typed{expect: string} /noe+  # /noe+ の出力が string であることを検証
```

### 1.6 最適化演算子 (シングルスレッド) 🧪 PROVISIONAL

> ⚠️ **暫定**: 実験による検証待ち。効果値は仮設定。

| 記号 | 名称 | 効果 | 例 |
|:-----|:-----|:-----|:---|
| `@cache` | キャッシュ | **-10pt** | `@cache[L1]{/noe+}` |
| `@compact` | 圧縮 | **-8pt** | `@compact{long_ctx}` |
| `@fault_tolerant` | 自動回復 | **+2pt** | `@fault_tolerant{/noe+ @fallback{/noe-}}` |

### 1.6 分散実行演算子 (マルチスレッド) v6.48

> **目的**: 複雑なCCLを外部エージェントに委譲し、長時間実行を実現

| 記号 | 名称 | 意味 | 例 |
|:-----|:-----|:-----|:---|
| `\|>` | パイプライン | 前段→後段への順次実行 | `/noe+ \|> /dia+ \|> /ene+` |
| `\|\|` | 並列 | 独立処理の同時実行 | `/sop+ \|\| /zet+` |
| `@batch` | バッチ | 非同期並列処理 | `@batch{F:[×100]{/s}}` |
| `@thread` | スレッド指定 | 実行エージェント指定 | `@thread[perplexity]{/sop+}` |
| `@delegate` | 委譲 | 長時間タスクを外部へ | `@delegate[openmanus]{/ene+}` |

**即時利用可能なスレッド**:

| スレッド | 役割 | pt上限 |
|:---------|:-----|:------:|
| Antigravity (私) | 認知・判断 | 60pt |
| Claude Code | 長時間自律実行 | 60pt |
| Gemini Code Assist | IDE統合コード生成 | 60pt |
| Gemini CLI | CLIベース処理 | 60pt |
| Jules API | Googleコード生成Agent | 60pt |
| OpenManus (自宅PC) | マルチエージェント基盤 | 無制限 |

**分散実行ポイント**: 各スレッドが60pt以下なら、全体は**300pt+**。

---

## 2. 二項演算子

| 記号 | 名称 | 認知的意味 | タスク構造 |
|:-----|:-----|:-----------|:-----------|
| `*` | 融合 | 不可分な統合。一瞬の結合。 | シングルタスク |
| `~` | 振動 | 動的な往復。対話による洗練。 | マルチタスク |
| `_` | シーケンス | 思考の連鎖。Aの後にBを実行。 | 逐次処理 |
| `>>` | 射 | X-series 構造的変換。A が B に変わる。 | 変換 |
| `>*` | 射的融合 | X-series を通じた変容。A が B の視点で変容。 | 変容 |

> **指向性**: 全ての二項演算子は**左が主、右が従**。`A*B` = A のための B。

### 区別

```
_   = 「Aの次にBをやってくれ」         → 手続き (時間的順序)
>>  = 「Aを構造的にBに変換してくれ」   → 変換 (X-series morphism)
>*  = 「AをBの視点で変容させてくれ」   → 変容 (射的融合)
*   = 「両方踏まえて一つの答えをくれ」 → 統合 (不可分)
~   = 「両方の対話を見せてくれ」       → プロセス (往復)
```

### 結合度階層

```
_  < >>  < >*  < *  < ~
弱   中弱   中強   強   動的
```

---

## 3. Series 積演算 (v6.38)

> **Series WF** (/a, /h, /k, /o, /p, /s) に適用される認知演算

| 位相 | 演算 | 意味 | 例 | 出力 |
|:-----|:-----|:-----|:---|:-----|
| `/` | 内積 (·) | 統合・収束 | `/a` | 精度スコア (スカラー) |
| `\` | 外積 (⊗) | 展開・発散 | `\a` | 派生群 (テンソル) |

### 数学的定義

```
内積 (Inner Product):
  /a = ⟨A1, A2, A3, A4⟩
  結果: 1次元スカラー (統合スコア)
  Hegemonikón哲学: デフォルト=収束

外積 (Outer Product):
  \a = A1 ⊗ A2 ⊗ A3 ⊗ A4
  結果: 4^n 次元テンソル (全組み合わせ)
  Hegemonikón哲学: 反転=展開
```

### 派生生成

```
\a の派生 = 外積から自然生成
例: 12派生 = 4定理 × 3レベル (確実/暫定/保留)
```

---

## 4. 関数演算子 (Tier 4)

| 記号 | 名称 | FEP 意味 |
|:---:|:---|:---|
| `E[]` | 期待値 | 予測値。平均的な成果。 |
| `V[]` | 分散 | 不確実性・エントロピー。 |
| `P()` | 順列 | 全順序パターン探索。 |
| `C()` | 組合せ | 構成要素の選択探索。 |

---

## 5. 定理修飾子

単項演算子の直後に定理IDを付記し、特定の方向（次元）へ深化・縮約する。

### Series別一覧

#### Akribeia (A) — 精度軸

| 記号 | 定理 | 作用 |
|:-----|:-----|:-----|
| `+a1` | Pathos | 感情・主観を精緻化 |
| `+a2` | Krisis | 判断・決定を厳密化 |
| `+a3` | Gnōmē | 原則・格言を抽出 |
| `+a4` | Epistēmē | 知識として固定 |

#### Horme (H) — 動機軸

| 記号 | 定理 | 作用 |
|:-----|:-----|:-----|
| `+h1` | Propatheia | 初期直感を評価 |
| `+h2` | Pistis | 確信度を評価 |
| `+h3` | Orexis | 欲求・価値を評価 |
| `+h4` | Doxa | 信念として記録 |

#### Kairos (K) — 文脈軸

| 記号 | 定理 | 作用 |
|:-----|:-----|:-----|
| `+k1` | Eukairia | 好機判定 |
| `+k2` | Chronos | 時間軸を拡大 |
| `+k3` | Telos | 目的整合を確認 |
| `+k4` | Sophia | 知恵・経験を適用 |

#### Ousia (O) — 認知軸

| 記号 | 定理 | 作用 |
|:-----|:-----|:-----|
| `+o1` | Noēsis | 深層認識 |
| `+o2` | Boulēsis | 意志・目的を明確化 |
| `+o3` | Zētēsis | 問いを発見 |
| `+o4` | Energeia | 行為に移行 |

#### Perigraphe (P) — 空間軸

| 記号 | 定理 | 作用 |
|:-----|:-----|:-----|
| `+p1` | Khōra | 領域・スコープを拡大 |
| `+p2` | Hodos | 経路を定義 |
| `+p3` | Trokhia | 軌道・サイクルを定義 |
| `+p4` | Tekhnē | 技法を選択 |

#### Schema (S) — 設計軸

| 記号 | 定理 | 作用 |
|:-----|:-----|:-----|
| `+s1` | Metron | スケールを拡大 (Micro→Macro) |
| `+s2` | Mekhanē | 方法を配置 |
| `+s3` | Stathmos | 基準を設定 |
| `+s4` | Praxis | 実践方法を選択 |

### レベルパラメータ `:N`

| 表記 | 意味 | スケール |
|:-----|:-----|:---------|
| `+s1:1` | 1段階拡大 | 月/中域 |
| `+s1:2` | 2段階拡大 | 年/広域 |
| `+s1:3` | 3段階拡大 | 人生/大域 |
| `+s1:4` | 4段階拡大 | 永劫/全体 |

---

## 6. 特殊パターン

### 6.1 融合メタ表示 `*^`

```
/noe*dia    → 融合結果のみ
/noe*^dia   → 融合結果 + どう融合したかのメタ解説
```

---

## 7. 五層アーキテクチャ (v6.55)

| 層 | 役割 | 演算子 |
|:---|:-----|:-------|
| **骨格** | 量の変化 | `+`, `-` |
| **次元** | 抽象度の変化 | `^`, `√` |
| **合成** | 定理の結合 | `*`, `~`, `_` |
| **射** | 定理間の構造的変換 | `>>`, `>*` |
| **位相反転** | 否定的検証 / 展開 | `\` |
| **肉** | 文脈提供 | P/K/A/X シリーズ |

---

## 8. 構文規則 (v1.2)

1. **評価順序**: 左から右へ（思考の順序）
2. **先頭単項**: 式全体にかかる
3. **末尾単項**: 直前のWFにかかる
4. **括弧**: 複雑な式でスコープを明示

---

## 9. 封印 (使用注意)

| 記号 | 名称 | 作用 | 状態 |
|:-----|:-----|:-----|:-----|
| `!` | 展開 | 全派生を並列展開 | ⚠️ 高負荷 |

---

## 9.5 Lambda 式 (Pythōsis Phase 2b) v6.52

> **Origin**: Python `lambda` の消化
> **目的**: 高階マクロへの匿名 WF 受け渡し、動的認知操作の即時定義

### 9.5.1 構文

| 記法 | 説明 | 推奨 |
|:-----|:-----|:----:|
| `L:[x]{WF}` | 引数 x を受け取り WF を実行 | ★ |
| `L:{WF}` | 引数なし Lambda | ★ |

### 9.5.2 設計根拠

```
λ   → ギリシャ語起源（CCL と一貫）
L:  → ASCII で入力可能、λ の代替
[]  → セレクタ（引数）
{}  → 処理ブロック
```

### 9.5.3 用途

| 用途 | 例 | 説明 |
|:-----|:---|:-----|
| **高階マクロ** | `@retry(3, on_fail=L:{/dia^})` | 失敗時にメタ分析 |
| **動的パイプライン** | `@chain(L:[x]{/noe+{x}}, L:[x]{/dia{x}})` | 操作を順次適用 |
| **マッピング** | `F:[tasks]{L:[t]{/noe+{target=t}}}` | 各タスクに認識適用 |
| **アドホック定義** | `L:{/bou*zet}` | 一時的な認知操作 |

### 9.5.4 @partial との使い分け

| 状況 | 推奨 |
|:-----|:-----|
| 文脈を固定したい | `@partial(ctx="Heg") /zet+` |
| 動的に引数を受け取りたい | `L:[x]{/noe+{target=x}}` |
| 名前をつけずに即時使用 | `L:{...}` |

### 9.5.5 複雑度

| 演算子 | pt |
|:-------|:--:|
| `L:[]{}` (Lambda) | 4 |

> **設計方針**: Lambda は `@partial` で表現できない場合にのみ使用。シンプルさを優先。

---

## 9.6 Mixin 合成 (Pythōsis B2) v6.53

> **Origin**: Python 多重継承・デコレータの消化
> **目的**: 複数の「能力」を認知操作に合成

### 9.6.1 構文

| 記法 | 説明 |
|:-----|:-----|
| `@with(Mixin)` | 単一 Mixin 適用 |
| `@with(M1, M2)` | 複数 Mixin 合成 (左→右) |
| `@with(M{param})` | パラメータ付き Mixin |

### 9.6.2 合成ルール

```
@with(A, B) f ≡ A(B(f))
# 前の Mixin が後の Mixin をラップ
# 順序が重要: @with(A, B) ≠ @with(B, A)
```

### 9.6.3 標準 Mixin

| Mixin | 機能 | Python 対応 |
|:------|:-----|:------------|
| `Tracing` | 実行ログ記録 | `logging` |
| `Caching` | 結果キャッシュ | `@cache` |
| `Retry` | 失敗時リトライ | `tenacity` |
| `Validation` | 事前/事後検証 | `pydantic` |
| `Timing` | 実行時間計測 | `time` |

### 9.6.4 使用例

```ccl
# 基本
@with(Tracing) /noe+

# 複数合成
@with(Tracing, Caching) /zet+

# パラメータ付き
@with(Retry{max_attempts=5}) /sop

# Lambda との組み合わせ
@with(Timing) L:[x]{/noe+{target=x}}
```

### 9.6.5 複雑度

| 演算子 | pt |
|:-------|:--:|
| `@with(M)` | 3 |
| `@with(M1, M2)` | 4 |
| `@with(M{p})` | 4 |

> **設計方針**: Mixin は「横断的関心事」(ログ、キャッシュ等) に限定。認知ロジックには使用しない。

---

## 9.7 デコレータマクロ (Pythōsis B3) v6.54

> **Origin**: Python `@decorator` パターンの消化
> **目的**: Mixin の簡潔な構文糖衣

### 9.7.1 一覧

| マクロ | 展開先 Mixin | 用途 |
|:-------|:-------------|:-----|
| `@memoize` | `Caching` | 結果キャッシュ |
| `@retry` | `Retry` | 失敗時リトライ |
| `@log` | `Tracing` | 実行ログ |
| `@validate` | `Validation` | 事前/事後検証 |
| `@timed` | `Timing` | 実行時間計測 |
| `@scoped` | (特殊) | スコープ限定 |
| `@async` | (特殊) | 非同期実行 |

### 9.7.2 使用例

```ccl
# 基本形
@memoize /sop{query="重い検索"}
@retry /ene
@log /noe+

# パラメータ付き
@memoize(ttl="1h") /zet+
@retry(max=5) /sop
@validate(pre=L:{$x != null}) /noe+

# 非同期
@async /sop{query="バックグラウンド"}
```

### 9.7.3 複雑度

| マクロ | pt |
|:-------|:--:|
| 単純 (`@log`, `@timed`) | 2 |
| パラメータ付き | 3 |
| 特殊 (`@scoped`, `@async`) | 4 |

> **詳細**: [ccl/macros/README.md](macros/README.md)

---

## 10. 制御構文 (CPL v2.0)

知的作業を「プログラム」として制御するための構文体系。

### 10.1 基本形: `<メタ>:[対象]{ 処理 }`

```
F:[2_3]{ /s+ }   → 2〜3回反復で /s+ を実行
I:[cond]{ /dia } → 条件 cond が真なら /dia を実行
W:[cond]{ /zet } → 条件 cond が真の間反復
let @think = /noe+_/dia  → マクロ定義
```

### 10.2 構造一覧

| 構造 | 構文例 | 内容 |
|:-----|:-------|:-----|
| **基本形** | `<メタ>:[対象]{ 処理 }` | 統一構造 |
| **反復 (FOR)** | `F:[×N]{}` / `F:[A,B]{}` | N回反復 / 各対象に適用 |
| **条件 (IF)** | `I:[cond]{}` | 条件分岐 |
| **ELSE IF** | `EI:[cond]{}` | 追加条件分岐 |
| **ELSE** | `E:{}` | 上記以外 |
| **ループ (WHILE)** | `W:[cond]{}` | 条件が真の間反復 |
| **定義 (LET)** | `let @name = CCL` | マクロ定義 |
| **セレクタ** | `[target]/wf` | 対象指定 |
| **振動** | `~` | 2点間を往復 |
| **マクロ** | `@macro` | 既定義の複合プログラム |
| **ネスト制限** | `[depth:3]` | 最大3レベル推奨 |

### 10.3 条件構文 (IF/ELSE IF/ELSE)

```ccl
# 完全な条件分岐
I:[V[/s] > 0.7]{
    /noe+       # 高確信度
}
EI:[V[/s] > 0.3]{
    /zet+       # 中確信度
}
E:{
    /dia+       # 低確信度
}
```

### 10.4 ネスト制限 (推奨3レベル)

```ccl
# 推奨 (2-3レベル)
F:[×3]{                  # Level 1
  I:[cond]{              # Level 2
    W:[loop]{            # Level 3
      /s+
    }
  }
}

# 4+レベル → マクロに分解を推奨
let @inner = W:[loop]{ /s+ }
F:[×3]{
  I:[cond]{ @inner }
}
```

### 10.5 反復構文 (FOR)

```ccl
# N回反復 (×N セレクタ)
F:[×3]{ /dia }

# 範囲指定 (2〜5回)
F:[2_5]{ /s+ }

# 各タスクに適用 (リストセレクタ)
F:[taskA, taskB]{ /dia }

# 全対象に適用
F:[ALL]{ /sta }
```

**セレクタ判定ルール**:

| セレクタ | 解釈 | 例 |
|:---------|:-----|:---|
| `×N` | N回反復 | `F:[×3]{}` |
| `N_M` | N〜M回反復 | `F:[2_5]{}` |
| `A, B` | 各対象に適用 | `F:[t1, t2]{}` |
| `ALL` | 全対象に適用 | `F:[ALL]{}` |

---

## 11. マクロ (@)

### 11.1 itertools 由来

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@chain` | `A_B_C` (continue) | 直列化 (エラー継続) |
| `@cycle` | `~:cond{A~B}` | 収束まで無限ループ |
| `@repeat(n)` | `F:[×N]{A}` | N回反復 |

### 11.2 functools 由来

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@reduce(op)` | `((A op B) op C)` | 累積融合 |
| `@partial(p=v)` | `/kho{ctx}_WF` | 部分適用 |

### 11.3 Context Engineering

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@ce` | `/mek{ctx>inst}` | 背景優先プロンプト |
| `@ce+` | `/kho{broad}_@ce` | 広範文脈CE |

### 11.4 Metaprompt Strategy

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@optimize` | `/mek{metaprompt}` | 推論モデル最適化 |
| `@refine(n)` | `F:[×N]{@optimize}` | N回洗練 |

### 11.5 Recoverable Autonomy

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@risk(lv)` | `/ene{risk=lv}` | リスクタグ付与 |
| `@checkpoint` | `/ene{checkpoint}` | 保存ポイント |
| `@rollback` | `/rollback@last` | ロールバック |

### 11.6 Memory-First Architecture

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@memory(layer)` | `/zet{memory=layer}` | 指定層検索 |
| `@recall` | `@memory(episodic)` | 経験想起 |
| `@lookup` | `@memory(semantic)` | 知識検索 |

### 11.7 Graduated Supervision

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@supervise(lv)` | `/dia` / `/syn` | 監視レベル |
| `@selfcheck` | `@supervise(low)` | 自己検証 |
| `@premortem` | `@supervise(mid)` | 失敗事前検討 |
| `@council` | `@supervise(high)` | 外部評議会 |

### 11.8 Zero-Trust Enforcement

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@enforce(lv)` | Anti-Skip/Schema | 強制レベル |
| `@antiskip` | `@enforce(soft)` | 最小強制 |
| `@schema` | `@enforce(medium)` | JSON Schema |
| `@guardrails` | `@enforce(hard)` | 厳格検証 |

### 11.9 Continuing Me Identity

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@identity` | `/boot{out=id}` | Identity Stack |
| `@reflect` | `/noe.nous{self}` | メタ認知 |
| `@values` | `@identity{L1}` | 価値観 |
| `@persona` | `@identity{L2}` | 人格 |

### 11.10 X-series Integration

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@next` | `/x{from=cur}` | 推奨次ステップ |
| `@route(name)` | Sacred Routes | 黄金経路 |
| `@connect(s)` | `/x{to=s}` | シリーズ接続 |

### 11.11 特殊

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@u` | `/bou+*^zet+` | 主観的意志決定 |

### 11.12 Tier 1 標準マクロ

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@tak` | `/s1_F:3{/sta~/chr}_?gap{/sop}_/bou` | タスク構造化 |
| `@dig` | `/s+~(/p*/a)_/dia*/o+` | 深掘り分析 |
| `@go` | `/s+_/ene+` | 戦略即時実行 |
| `@ground` | `/tak-*/bou_6w3h` | 現実への接地 (6W3H) |
| `@fix` | `/dia+_/ene+_/dia` | 修正サイクル |
| `@kyc` | `~(/sop_/noe_/ene_/dia-)` | κύκλος (観察→推論→行動→判定) |

### 11.13 認知マクロ (Cognitive Macros)

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@think` | `(/noe~\noe)*dia ^ /u+` | 深層思考 (認識振動→判定融合→メタ統合) |
| `@plan` | `lim[/ene+]{(/bou~zet)*(/s~\s)_/kho*hod}` | 計画立案 (意志探求振動→戦略融合→詳細実行に収束) |
| `@verify` | `lim[/epi]{(/dia~\dia)*(/sta^)}` | 厳密検証 (判定振動→メタ基準融合→知識化に収束) |
| `@complete` | `{result} _ /x.trigonon _ ?confirm` | WF完了 (結果出力→射提案→確信度確認) |

> **`@complete` 使用義務**: 24定理WF完了時、暗黙的に `@complete` が発動する。
> BC-8 (射出力義務) と連動。`/x.trigonon` が frontmatter を読み射を提案。

### 11.14 Scope Management (Pythōsis Phase 3) v2.0

> **Origin**: Python `contextlib` モジュールの消化
> **目的**: CCL 実行にスコープ境界と setup/teardown を提供

| マクロ | CCL 展開 | 意味 |
|:-------|:---------|:-----|
| `@scoped(s,t){}` | `/kho{s}_WF_t` | スコープ限定実行 (setup/teardown) |
| `@suppress(e)` | `I:[error=e]{continue}` | エラー抑制 |

**パラメータ**:

| パラメータ | 型 | 説明 | Python 対応 |
|:-----------|:---|:-----|:------------|
| `setup:` | CCL | 事前処理 | `__enter__` |
| `teardown:` | CCL | 事後処理 (例外時も実行) | `__exit__` |
| `suppress:` | list | 抑制するエラー種別 | `suppress()` |

**使用例**:

```ccl
# 基本: スコープ付き実行
@scoped(
  setup: /kho.scope{domain: "Pythōsis"},
  teardown: /bye-
) {
  /noe+ _/s+ _/dia
}

# エラー抑制付き
@scoped(
  setup: /kho{ctx: "test"},
  teardown: /sta.done,
  suppress: [timeout]
) {
  /sop+{query: "..."}
}

# 簡略形: setup のみ
@scoped(setup: /boot-) { /ene+ }
```

## 12. CCL 複雑度ポイント制 (Complexity Point System)

> **目的**: AI の認知負荷を定量化し、品質と処理限界のバランスを取る

### 12.1 ポイント表

| カテゴリ | 演算子 | pt |
|:---------|:-------|:--:|
| **単純** | `+`, `-`, `_` | 1 |
| **射・収束** | `>>`, `E:{}`, `let` | 2 |
| **次元・微分** | `^`, `√`, `'`, `∂`, `E[]`, `EI:[]{}` | 3 |
| **合成** | `*`, `>*` | 3 |
| **Lambda・振動** | `L:[]{}`, `~`, `Σ`, `V[]`, `I:[]{}`, `lim[]{}`, `C()` | 4 |
| **反転・積分** | `\`, `∫`, `F:[]{}`, `P()` | 5 |
| **展開・WHILE** | `!`, `W:[]{}` | 6 |

### 12.2 構造コスト

| 構造 | pt |
|:-----|:--:|
| ネスト Lv1 | +4 |
| ネスト Lv2 | +10 |
| ネスト Lv3 | +18 |

### 12.3 ポイント帯域

| 帯域 | pt | 用途 | 確信度目安 |
|:-----|:---|:-----|:-----------|
| **Minimal** | 5-15 | クイック応答 | 0.90+ |
| **Standard** | 15-30 | `/mek` | 0.80-0.90 |
| **Enhanced** | 30-45 | `/mek+` | 0.70-0.80 |
| **Maximum** | 45-60 | 複雑設計 | 0.60-0.70 |
| **Warning** | 60+ | 分割推奨 | <0.60 |

### 12.4 例

```ccl
# 4pt (Minimal)
/noe+ _ /dia _ /u+

# 15pt (Standard下限)
lim[/ene]{(/bou ~ \bou) * /s+}

# 12pt (射を使った変換)
/noe >> /met >* /dia

# 38pt (Enhanced)
I:[V[/ctx] > 0.5]{
  F:[×3]{ (/noe+s1 ~ \noe) * /dia }
}
lim[E[/u+]]{}
```

---

*v6.55 | 2026-02-07 | `>>` を射 (morphism) に転用、`>*` (射的融合) 追加。収束は `lim` に一本化。X-series 圏論的構造の正式導入。*
