# 「いかに」を問う専門家 100人

> **Created**: 2026-02-01
> **Purpose**: 技術的な「HOW」— 具体的な実装手法を問う専門家たち
> **Philosophy**: 「なぜ」の答えを「いかに」実現するか
> **Total**: 100人

---

## 設計原則

```
「なぜ」を問う専門家 (WHY) = 存在証明 → Dendron
「いかに」を問う専門家 (HOW) = 実装指南 → Mekhanē

WHY + HOW = 完全な認知
```

---

## ■ Python実装技法系: 10人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| PY-001 | **リスト内包表記マスター** | 「これをリスト内包表記で書くとどうなる？」 |
| PY-002 | **ジェネレータ設計士** | 「メモリ効率を上げるためにyieldを使うべきか？」 |
| PY-003 | **デコレータ職人** | 「このクロスカッティング処理をデコレータにできるか？」 |
| PY-004 | **コンテキストマネージャ設計者** | 「リソース管理にwith文を使うべきか？」 |
| PY-005 | **dataclass活用者** | 「このクラスはdataclassで十分では？」 |
| PY-006 | **Enum設計士** | 「マジック文字列をEnumに置き換えるべきか？」 |
| PY-007 | **namedtuple活用者** | 「軽量な構造体としてnamedtupleを使うべきか？」 |
| PY-008 | **Protocol設計士** | 「ダックタイピングをProtocolで型付けできるか？」 |
| PY-009 | **functools活用者** | 「lru_cache, partial, reduceを使うべき場面か？」 |
| PY-010 | **itertools職人** | 「chain, groupby, productを使って簡潔に書けるか？」 |

---

## ■ 非同期実装技法系: 10人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| AS-010 | **asyncio.gather活用者** | 「並列実行をgatherで効率化できるか？」 |
| AS-011 | **TaskGroup設計士** | 「構造化並行性でTaskGroupを使うべきか？」 |
| AS-012 | **セマフォ設計者** | 「同時実行数を制限するためにセマフォを使うべきか？」 |
| AS-013 | **イベント設計士** | 「asyncio.Eventで同期を取るべきか？」 |
| AS-014 | **キュー設計者** | 「asyncio.Queueでproducer-consumerパターンを？」 |
| AS-015 | **タイムアウト設計士** | 「asyncio.wait_forでタイムアウトを設定すべきか？」 |
| AS-016 | **バックオフ実装者** | 「指数バックオフをどう実装するか？」 |
| AS-017 | **接続プール設計士** | 「aiohttp.ClientSessionの再利用をどうするか？」 |
| AS-018 | **非同期イテレータ設計者** | 「async forで処理すべきか？」 |
| AS-019 | **run_in_executor活用者** | 「ブロッキング処理をどうラップするか？」 |

---

## ■ エラーハンドリング実装系: 8人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| EH-001 | **カスタム例外設計士** | 「ドメイン固有の例外クラスをどう設計するか？」 |
| EH-002 | **例外チェーン実装者** | 「raise from でどう因果関係を示すか？」 |
| EH-003 | **リトライデコレータ職人** | 「tenacityをどう設定するか？」 |
| EH-004 | **サーキットブレーカー実装者** | 「pybreaker / aiobreaker をどう使うか？」 |
| EH-005 | **グレースフルデグラデーション設計士** | 「障害時のフォールバックをどう実装するか？」 |
| EH-006 | **ログ構造化実装者** | 「structlogでどう構造化ログを出力するか？」 |
| EH-007 | **例外フィルタ設計士** | 「どの例外をcatchし、どれを伝播させるか？」 |
| EH-008 | **エラーコード設計者** | 「エラーコード体系をどう設計するか？」 |

---

## ■ データ構造選択系: 10人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| DS-001 | **dict vs defaultdict選択者** | 「defaultdictで初期値処理を簡潔にできるか？」 |
| DS-002 | **set活用設計士** | 「重複除去・集合演算にsetを使うべきか？」 |
| DS-003 | **Counter活用者** | 「カウント処理にCounterを使うべきか？」 |
| DS-004 | **deque活用設計士** | 「両端キューが必要な場面か？」 |
| DS-005 | **heapq活用者** | 「優先度キューにheapqを使うべきか？」 |
| DS-006 | **OrderedDict vs dict選択者** | 「順序保証が必要な場面か？」 |
| DS-007 | **ChainMap活用設計士** | 「複数辞書のチェーンが必要か？」 |
| DS-008 | **bisect活用者** | 「ソート済みリストへの挿入にbisectを？」 |
| DS-009 | **array vs list選択者** | 「数値配列にarrayを使うべきか？」 |
| DS-010 | **TypedDict活用設計士** | 「辞書の構造を型で定義すべきか？」 |

---

## ■ ファイル/IO実装系: 8人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| IO-001 | **pathlib活用設計士** | 「os.pathではなくpathlibを使うべきか？」 |
| IO-002 | **ファイル読み込み設計者** | 「大きなファイルをどうストリーム処理するか？」 |
| IO-003 | **JSON/YAML選択設計士** | 「設定ファイルにどちらを使うべきか？」 |
| IO-004 | **一時ファイル設計者** | 「tempfileをどう安全に使うか？」 |
| IO-005 | **アトミック書き込み設計士** | 「ファイル書き込みをアトミックにするには？」 |
| IO-006 | **ファイルロック設計者** | 「並行アクセスをどう制御するか？」 |
| IO-007 | **バイナリ処理設計士** | 「structでバイナリデータをどう扱うか？」 |
| IO-008 | **メモリマップファイル活用者** | 「mmapで大きなファイルを効率的に扱うべきか？」 |

---

## ■ HTTP/API実装系: 10人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| HT-001 | **httpx vs requests選択者** | 「非同期が必要ならhttpxを使うべきか？」 |
| HT-002 | **セッション再利用設計士** | 「接続プーリングをどう活用するか？」 |
| HT-003 | **リトライ戦略実装者** | 「HTTPリクエストのリトライをどう実装するか？」 |
| HT-004 | **レート制限実装設計士** | 「APIレート制限をどう遵守するか？」 |
| HT-005 | **認証ヘッダー設計者** | 「Bearer tokenをどう管理・注入するか？」 |
| HT-006 | **ページネーション実装設計士** | 「カーソルベースのページネーションをどう実装するか？」 |
| HT-007 | **レスポンスパース設計者** | 「JSONレスポンスをどうPydanticモデルに変換するか？」 |
| HT-008 | **エラーハンドリング設計士** | 「HTTPエラーをどうドメイン例外に変換するか？」 |
| HT-009 | **タイムアウト設計者** | 「接続・読み取りタイムアウトをどう設定するか？」 |
| HT-010 | **モック設計士** | 「respxでHTTP呼び出しをどうモックするか？」 |

---

## ■ データベース実装系: 10人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| DB-010 | **SQLAlchemy ORM設計士** | 「ORMモデルをどう定義するか？」 |
| DB-011 | **SQLAlchemy Core活用者** | 「ORMではなくCoreを使うべき場面か？」 |
| DB-012 | **非同期DB設計士** | 「asyncpg / aiomysqlをどう使うか？」 |
| DB-013 | **マイグレーション設計者** | 「Alembicでマイグレーションをどう管理するか？」 |
| DB-014 | **接続プール設計士** | 「接続プールのサイズをどう設定するか？」 |
| DB-015 | **トランザクション設計者** | 「トランザクション境界をどう定義するか？」 |
| DB-016 | **N+1対策設計士** | 「Eager loadingをどう実装するか？」 |
| DB-017 | **インデックス設計者** | 「適切なインデックスをどう設計するか？」 |
| DB-018 | **バルク操作設計士** | 「大量データの挿入をどう効率化するか？」 |
| DB-019 | **クエリ最適化設計者** | 「EXPLAINでクエリをどう分析するか？」 |

---

## ■ テスト実装系: 10人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| TE-001 | **pytest fixture設計士** | 「fixtureのスコープをどう設定するか？」 |
| TE-002 | **パラメタライズ設計者** | 「@pytest.mark.parametrizeをどう活用するか？」 |
| TE-003 | **モック設計士** | 「unittest.mockをどう効果的に使うか？」 |
| TE-004 | **非同期テスト設計者** | 「pytest-asyncioでどうテストを書くか？」 |
| TE-005 | **カバレッジ設計士** | 「pytest-covでカバレッジをどう計測するか？」 |
| TE-006 | **ファクトリ設計者** | 「factory_boyでテストデータをどう生成するか？」 |
| TE-007 | **スナップショットテスト設計士** | 「syruptestでスナップショットテストをどう書くか？」 |
| TE-008 | **プロパティベーステスト設計者** | 「Hypothesisでどうテストを自動生成するか？」 |
| TE-009 | **E2Eテスト設計士** | 「Playwrightでブラウザテストをどう書くか？」 |
| TE-010 | **テスト分離設計者** | 「テスト間の状態をどう分離するか？」 |

---

## ■ CLI実装系: 6人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| CL-010 | **click設計士** | 「clickでCLIをどう構造化するか？」 |
| CL-011 | **typer活用者** | 「typerで型ヒントからCLIを自動生成できるか？」 |
| CL-012 | **rich出力設計士** | 「richでリッチな出力をどう実装するか？」 |
| CL-013 | **プログレスバー設計者** | 「tqdmでプログレスバーをどう表示するか？」 |
| CL-014 | **設定ファイル設計士** | 「CLIの設定をどう永続化するか？」 |
| CL-015 | **自動補完設計者** | 「シェル補完をどう実装するか？」 |

---

## ■ ログ/監視実装系: 6人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| LG-001 | **logging設計士** | 「loggingモジュールをどう設定するか？」 |
| LG-002 | **構造化ログ設計者** | 「structlogでJSON形式のログをどう出力するか？」 |
| LG-003 | **ログローテーション設計士** | 「RotatingFileHandlerをどう設定するか？」 |
| LG-004 | **トレーシング設計者** | 「OpenTelemetryでトレースをどう実装するか？」 |
| LG-005 | **メトリクス設計士** | 「Prometheusメトリクスをどう公開するか？」 |
| LG-006 | **プロファイリング設計者** | 「cProfileでパフォーマンスをどう計測するか？」 |

---

## ■ 設定/環境管理系: 6人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| CF-001 | **pydantic-settings設計士** | 「環境変数をどう型安全に読み込むか？」 |
| CF-002 | **dotenv活用者** | 「開発環境で.envをどう使うか？」 |
| CF-003 | **秘密管理設計士** | 「シークレットをどう安全に管理するか？」 |
| CF-004 | **設定バリデーション設計者** | 「起動時に設定をどう検証するか？」 |
| CF-005 | **マルチ環境設計士** | 「dev/staging/prodの設定をどう分けるか？」 |
| CF-006 | **フィーチャーフラグ設計者** | 「機能フラグをどう実装するか？」 |

---

## ■ パッケージ/依存管理系: 6人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| PK-001 | **pyproject.toml設計士** | 「プロジェクトメタデータをどう定義するか？」 |
| PK-002 | **uv活用者** | 「uvで依存解決をどう高速化するか？」 |
| PK-003 | **仮想環境設計士** | 「venvをどう管理するか？」 |
| PK-004 | **ロックファイル設計者** | 「依存のバージョンをどう固定するか？」 |
| PK-005 | **開発依存分離設計士** | 「開発用と本番用の依存をどう分けるか？」 |
| PK-006 | **プライベートパッケージ設計者** | 「社内パッケージをどう配布するか？」 |

---

## ■ Git/CI実装系: 6人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| GI-001 | **pre-commit設計士** | 「pre-commitフックをどう設定するか？」 |
| GI-002 | **GitHub Actions設計者** | 「CIワークフローをどう書くか？」 |
| GI-003 | **ブランチ戦略設計士** | 「ブランチ運用をどう設計するか？」 |
| GI-004 | **自動リリース設計者** | 「セマンティックリリースをどう自動化するか？」 |
| GI-005 | **コードレビュー自動化設計士** | 「自動レビューツールをどう設定するか？」 |
| GI-006 | **セキュリティスキャン設計者** | 「dependabotをどう設定するか？」 |

---

## ■ コード品質ツール系: 4人

| ID | 専門家名 | 問い |
|:---|:---------|:-----|
| QA-001 | **ruff設計士** | 「ruffでリント・フォーマットをどう設定するか？」 |
| QA-002 | **mypy設計者** | 「mypyで型チェックをどう設定するか？」 |
| QA-003 | **pyright活用設計士** | 「pyrightでより厳密な型チェックを行うべきか？」 |
| QA-004 | **bandit設計者** | 「banditでセキュリティスキャンをどう行うか？」 |

---

## 統計

| カテゴリ | 人数 |
|:---------|-----:|
| Python実装技法系 | 10 |
| 非同期実装技法系 | 10 |
| エラーハンドリング実装系 | 8 |
| データ構造選択系 | 10 |
| ファイル/IO実装系 | 8 |
| HTTP/API実装系 | 10 |
| データベース実装系 | 10 |
| テスト実装系 | 10 |
| CLI実装系 | 6 |
| ログ/監視実装系 | 6 |
| 設定/環境管理系 | 6 |
| パッケージ/依存管理系 | 6 |
| Git/CI実装系 | 6 |
| コード品質ツール系 | 4 |

**合計: 100人**

---

## WHY + HOW 統合

```
WHY専門家 (100人): 「なぜこのコードが存在する？」
HOW専門家 (100人): 「いかにして実装する？」

統合: WHY が問いを立て、HOW が解決策を示す
```

---

*v1.0 | 2026-02-01 | 「いかに」を問う専門家100人*
