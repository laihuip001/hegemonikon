#!/usr/bin/env python3
"""Enrich O-series WFs with BC-15 compliant detailed data."""
import json, re

RICH_DATA = {
  "noe": {
    "desc": "「本質は何か？」を問う最深層の思考ツール。表面的な理解を拒否し、暗黙の前提を掘り起こして、余分も不足もない普遍的な解（Kalon）を発見する。設計の根本を見直したい時、パラダイム転換が必要な時に使う。",
    "phases": [
      {"id":"STEP 0","name":"SKILL.md読込","detail":"ワークフローの正本（設計書）をファイルから読み込む。省略すると劣化出力になるため環境が強制する。view_file コマンドで実際にファイルを開く。"},
      {"id":"STEP 0.5","name":"Gnōsis検索","detail":"27,000件の論文知識ベースから、関連する学術知見を事前取得する。「自分の記憶だけで考える」ことを防ぎ、エビデンスに基づく思考を保証する。"},
      {"id":"Ph0","name":"Prolegomena（前限定）","detail":"「何について考えるか」の範囲を決める。分析対象の圏（カテゴリ）を特定し、議論の土俵を定義する。ここを間違えると全フェーズが無駄になる。"},
      {"id":"Ph1","name":"Excavation（前提の掘り起こし）","detail":"「当然だと思っていること」を全て列挙する。暗黙の仮定、無意識の前提、疑われていない常識を表面化させる。このフェーズが/noeの核心。"},
      {"id":"Ph2","name":"Genesis（仮説生成）","detail":"複数の視点から仮説を構成する。Analogy(生物からの連想)、10x(目標10倍化)、Gap(未成熟なたたき台)、Art(芸術からの示唆)など6つの発想モードを使い、多角的に候補解を生成する。"},
      {"id":"Ph3","name":"Kalon（普遍性検証）","detail":"/noe+ (L3) のみ実行。候補解同士を比較し「AはBの特殊ケースか？」をLLMに判定させる。最も多くの候補を包含する普遍的な解を特定し、Kalonスコア(0-1)で美しさを数値化する。"},
      {"id":"Ph4","name":"Synthesis（射の合成）","detail":"/noe+ (L3) のみ実行。複数の洞察を統合し、経路を辿って整合性を確認する。個別の発見がシステム全体で矛盾しないかを検証する。"},
      {"id":"Ph5","name":"Dokimasia（忠実性テスト）","detail":"結論が元の問題に忠実かを検証する。「抽象化しすぎて元の問題と解離していないか」「具体的な指示に落とせるか」をチェックする。全レベルで必須。"},
      {"id":"Ph6","name":"Theoria（Yoneda完全性）","detail":"/noe+ (L3) のみ実行。結論の完全性を最終確認する。「考慮されていない射（関係性）はないか」「この結論で全ての観点がカバーされているか」を問う。"}
    ],
    "derivatives": [
      {"name":"nous","when":"抽象的・原理的な問い。「なぜ〜か」「本質は何か」","output":"普遍的な原理・法則。具体例から抽出された構造的パターン","example":"「FEPとは何か」→ 予測誤差最小化という普遍原理を、生物/AI/組織の3文脈で導出"},
      {"name":"phro","when":"具体的・文脈依存の判断。「この状況でどうすべきか」","output":"状況に適応した実践的判断。条件付きの行動指針","example":"「このPRをマージすべきか」→ リスク/テストカバレッジ/依存関係を考慮した判断"},
      {"name":"meta","when":"自分の思考過程に疑問がある時。「なぜそう考えたか」","output":"認識の認識。バイアスの検出、推論の跳躍の特定","example":"「前回のセッションで間違えた原因は何か」→ 確証バイアスによるINPUT TAINTを検出"},
      {"name":"separate","when":"複合的な問題が絡み合って解けない時","output":"独立した部分問題のリスト。それぞれの解決順序","example":"「アプリが遅い」→ DB/API/レンダリング/ネットワークの4問題に分離、DB優先で解決"},
      {"name":"align","when":"複数の設計判断が矛盾している時","output":"整合状態の定義と、矛盾解消の提案","example":"「パフォーマンスとセキュリティが矛盾」→ 第3の選択肢を発見し両立させる"},
      {"name":"metalearning","when":"学習方法自体を改善したい時","output":"より効果的な学習戦略の設計","example":"「なぜ新技術の習得が遅いか」→ 学習ループの構造的問題を特定し、戦略を再設計"},
      {"name":"scaffold","when":"自由な発想だけでは収束しない時","output":"骨格を固定→創発を許容→整流するPGH型フレームワーク","example":"「ブレストの結果がまとまらない」→ 構造(骨格)を先に定義してから自由領域を設定"}
    ],
    "usecases": [
      {"situation":"体系の根本設計を見直したい","trigger":"「この構造は本当に正しいのか？」という疑問が生じた時","action":"/noe+ で全ての暗黙の前提を掘り起こし、普遍性検証(Kalon)まで実行。根本からの再設計を行う","result":"余分な仮定が除去され、より単純で美しい設計が得られる"},
      {"situation":"パラダイム転換が必要","trigger":"既存のアプローチでは解決不可能な問題に直面した時","action":"/noe で前提を全て疑い、Ph2の発想モード(Analogy/10x/Alien)で異質な視点を取り入れる","result":"従来とは全く異なるアプローチが発見される"},
      {"situation":"複数の選択肢があり本質が見えない","trigger":"「AとBどちらが良いか」ではなく「そもそもこの問いの立て方が正しいか」を問いたい時","action":"/noe --derivative=meta で問いそのものを再検討。/noe --derivative=separate で問題を分離","result":"真の問題が特定され、偽の二項対立から脱出できる"},
      {"situation":"外部レビューの指摘を根本的に理解したい","trigger":"表面的な修正ではなく、構造的な欠陥の原因を追求したい時","action":"/noe --derivative=nous でレビュー指摘の背後にある原理を抽出","result":"個別の指摘ではなく、設計原則レベルの改善が得られる"},
      {"situation":"新しいフレームワークの本質を理解したい","trigger":"ドキュメントを読んだだけでは「なぜそう設計されたか」がわからない時","action":"/noe で設計の前提を掘り起こし、Ph3 Kalonで「このフレームワーク固有の普遍性」を特定","result":"表面的な使い方ではなく、設計思想の深い理解が得られる"}
    ],
    "algebra_detail": {
      "+": "/noe+（L3 Deep）: 全7フェーズを完全実行。Ph3 Kalon（普遍性検証）、Ph4 Synthesis（射の合成）、Ph6 Theoria（Yoneda完全性）を含む。各フェーズで標準の3倍の出力量。GoT分岐3つ以上。結果はファイルに保存必須",
      "-": "/noe-（L1 Quick）: 結論+理由1つのみ、5行以内。軽い確認や素早い判断に使う",
      "*": "/noe*（メタ分析）: 分析そのものの前提を問い直す。「なぜこの分析をしているのか」「分析の枠組み自体にバイアスはないか」を検証"
    }
  },
  "bou": {
    "desc": "「何を望むか？」を問う意志明確化ツール。まずClaudeが自分の望みをたたき台として提示し、Creatorの反応から対話的に真の望みを引き出す。純粋な理想（望み）から実用的な目標（行動計画）への変換を行う。",
    "phases": [
      {"id":"STEP 0","name":"SKILL.md読込","detail":"ワークフローの正本を読み込む。省略不可。"},
      {"id":"Ph0","name":"私の望み提示","detail":"Claudeが現在の文脈から3-5個の望みをたたき台として提示する。単に「何がしたいですか？」と聞くのではなく、先に自分の望みを見せることで、Creatorの反応を引き出す。各望みに「なぜそれを望むか」と「Creatorにとっての価値（推測）」を添える。"},
      {"id":"Ph1-2","name":"対話+深掘り","detail":"Creatorの反応を受け、5 Whys（なぜを5回繰り返す）で望みの根源に到達する。さらに多面的な問い: 「達成後に何が変わるか」「ないと何が困るか」「誰のためか（自己/他者/社会）」で望みを多角的に照射する。"},
      {"id":"Ph3","name":"衝動vs熟慮判定","detail":"各望みに衝動スコア(0-100)を付与する。判定基準: (1)今だけか長期的か (2)1週間後も同じか (3)理性でも望むか感情だけか。高スコア=衝動的（慎重に扱う）、低スコア=熟慮された意志（信頼できる）。"},
      {"id":"Ph4","name":"実現可能性評価","detail":"リソース（時間/お金/スキル）と制約（障害）から実現可能性スコア(0-100)を算出。2×2マトリクスで分類: 高純粋×高実現→即実行、高純粋×低実現→長期目標、低純粋×高実現→再検討、低純粋×低実現→棄却候補。"},
      {"id":"Ph4.5","name":"6W3H具体化","detail":"「即実行」と判定された望みのみ実施。What/Why/Who/Whom/Where/When/How/How much/How many の9つの問いに具体的な値・名前で回答。曖昧な回答は許可しない。"},
      {"id":"Ph5","name":"優先順位+行動計画","detail":"全フェーズの結果を統合し最終優先順位を決定。最優先の望みに: 具体的次アクション + 期限 + 達成基準を設定。出力を /ene（実行WF）に渡す準備をする。"}
    ],
    "derivatives": [
      {"name":"desir","when":"明確な葛藤がなく、素直に望みを探したい時","output":"純粋な望みリスト + 各望みの純粋度(HIGH/MED/LOW) + 5 Whysの結果 + 優先順位","example":"セッション開始時に「今日は何をやりたいか」→ 3つの望みを純粋度順に整理"},
      {"name":"voli","when":"「AもやりたいしBもやりたい、でも両立できない」という複数欲動の競合時","output":"Frankfurt階層分析: 第1次欲動（直接的欲求）と第2次欲動（欲求についての意志）を区別し、上位意志で統合","example":"「新機能開発」vs「技術的負債返済」→ 共通根源は「プロダクトの長期的健全性」と特定し、両方を含む統合意志を構成"},
      {"name":"akra","when":"「わかっているのにできない」「先延ばししている」という意志-行為の乖離時","output":"乖離の原因分析 + 実装意図（「{状況}のとき{行動}する」形式） + 環境設計（障害除去+トリガー設置）","example":"「テストを書くべきだが書かない」→ 原因:即座のフィードバックがない → 実装意図:「PR作成前にpytest実行」→ 環境:pre-commitフックに追加"}
    ],
    "usecases": [
      {"situation":"セッション開始時の方向性設定","trigger":"「今日は何をやるか」が明確でない時","action":"/bou でClaudeが先に3-5個の望みを提示 → Creatorの反応で対話 → 最優先を決定","result":"具体的な行動計画と優先順位が得られ、/ene で実行に移れる"},
      {"situation":"複数のやりたいことが競合","trigger":"「AとBどちらを先にやるべきか」で決められない時","action":"/bou --derivative=voli でFrankfurt階層分析 → 上位意志を特定 → 統合的解決策を構成","result":"二者択一ではなく、両方の根源的な欲求を満たす統合的な方針が得られる"},
      {"situation":"先延ばしを克服したい","trigger":"やるべきとわかっているのに手がつかない時","action":"/bou --derivative=akra で乖離の原因を特定 → 実装意図を設計 → 環境を変えて障害を除去","result":"意志力に頼らず、環境の力で自然に行動できる仕組みが構築される"},
      {"situation":"長期プロジェクトの方向性確認","trigger":"「まだこの方向で良いのか？」と定期的に振り返りたい時","action":"/bou で現在の望みを再評価 → 初期の望みとの差分を分析 → 方向修正 or 継続を判断","result":"目的の漂流（Drift）を早期検出し、手段の目的化を防ぐ"}
    ],
    "algebra_detail": {
      "+": "/bou+: 全フェーズ実行。5 Whys完全実行 + 6W3H具体化必須 + トレードオフ分析必須。詳細な意志の地図を作る",
      "-": "/bou-: 最優先1つのみ。端的に「今一番やりたいこと」を特定する。数分で完了",
      "*": "/bou*: 意志のメタ分析。「なぜそれを望むのか」「その望みは本当に自分のものか」を問う。Frankfurt的に欲求の欲求を分析"
    }
  },
  "zet": {
    "desc": "「何を問うべきか？」を発見する探求ツール。答えを出すのではなく、正しい問いを見つける。違和感や摩擦点から問いの種を発見し、具体的で扱える形に変換する。/noe が答えを深掘りするなら、/zet は問いを発掘する。",
    "phases": [
      {"id":"STEP 0","name":"SKILL.md読込","detail":"ワークフローの正本を読み込む。省略不可。"},
      {"id":"Ph1(η)","name":"問い生成（Unit）","detail":"3つのソースから問いの種を見つける: (1)摩擦点 — うまくいっていないこと (2)成功の裏 — うまくいっているが理由不明なこと (3)前提の棚卸し — 疑われていない仮定。メタ問い（問いの問い）も含めて候補を列挙する。"},
      {"id":"Ph2(μ)","name":"平坦化（Multiplication）","detail":"メタ問い（抽象的な問い）を具体的で扱える問いに変換する。「なぜうまくいかないか」→「どのステップで失敗しているか」→「テストのステップ3で何が起きているか」のように、行動可能なレベルまで具体化する。"},
      {"id":"Ph3","name":"問い候補の提示","detail":"発見した問いをランク付けしてCreatorに提示する。各問いに「重要度」「緊急度」「答えが得られた場合のインパクト」を付与。Creatorが選択する。"},
      {"id":"Ph4","name":"Kleisli Bind","detail":"Creator が選んだ問いを次のWFに接続する。典型的には /noe で深掘り、または /sop で外部調査。問いが行動に変わる接続点。"}
    ],
    "derivatives": [
      {"name":"anom","when":"「何かおかしい」という違和感はあるが言語化できない時","output":"違和感の正体を具体的な問いに変換。異常の位置と性質を特定","example":"「ビルドが最近遅い気がする」→ 「v2.3以降でCIの所要時間が40%増加。原因はdependency解決か？テストか？」"},
      {"name":"hypo","when":"仮説を複数立てて比較したい時","output":"「もし〜なら」のシナリオ群。各仮説の検証方法と予想結果","example":"「ユーザー離脱の原因は何か」→ 3つの仮説(UI/パフォーマンス/機能不足)と各々の検証方法を並列生成"},
      {"name":"eval","when":"生成した仮説の妥当性を検証したい時","output":"各仮説の確信度スコアと根拠。最も蓋然性の高い仮説の特定","example":"3つの仮説をエビデンスと照合 → パフォーマンスが最有力(確信度75%)と判定"},
      {"name":"abduction","when":"観察結果から最も蓋然性の高い原因を推定したい時","output":"最良説明の推論。「この結果を最もよく説明する原因は何か」","example":"「テスト通過率が急落」→ abductionで「先週のDB移行が原因」と推定 → 検証計画を策定"}
    ],
    "usecases": [
      {"situation":"違和感があるが言語化できない","trigger":"「何か引っかかる」「なんとなく不安」という感覚がある時","action":"/zet --derivative=anom で違和感を具体的な問いに変換。摩擦点を3つ以上列挙し、各々を行動可能な問いに変換","result":"曖昧な不安が「この具体的な問いに答えれば解決する」という明確な形になる"},
      {"situation":"設計前に問いを整理したい","trigger":"新しい機能やプロジェクトを始める前に「本当に必要か」を確認したい時","action":"/zet で前提の棚卸しを実行。「これは必要」と思い込んでいる仮定を全て列挙し、各々を問いに変換","result":"不要な前提が発見され、より本質的な設計が可能になる"},
      {"situation":"デバッグの方向性を決めたい","trigger":"バグの原因がわからず、どこから調べるべきか迷っている時","action":"/zet --derivative=hypo で複数の仮説を立て → --derivative=eval で各仮説を評価 → 最有力を /noe で深掘り","result":"最も蓋然性の高い原因が特定され、効率的なデバッグが可能になる"},
      {"situation":"新しいアイデアが浮かんだ","trigger":"面白そうなアイデアだが、実現性や価値が不明な時","action":"/zet で「このアイデアが解決する問題は何か」「既存の解決策と何が違うか」を問いとして構成","result":"アイデアが検証可能な問いの形になり、/noe や /sop で評価できる状態になる"}
    ],
    "algebra_detail": {
      "+": "/zet+: 3つのソース(摩擦点/成功の裏/前提棚卸し)を全て実行。各問いに重要度/緊急度/インパクトのスコアを付与。最低5つの問い候補を生成",
      "-": "/zet-: 最も気になる1つの問いだけを即座に特定する。深い分析なし、直感ベース",
      "*": "/zet*: 問いの問い。「なぜこの問いを問おうとしているのか」「この問いの前提は何か」を分析。問い自体のバイアスを検出"
    }
  },
  "ene": {
    "desc": "計画を実行に移すツール。意志（/bou）で決めたことを実際にコードや文書として具現化する。リスク判定→実行→品質検証→偏差検知の4段階で、安全かつ確実に変更を行う。計画の承認後に「y」で暗黙発動する。",
    "phases": [
      {"id":"Ph0.1","name":"Risk Tag（リスク判定）","detail":"操作の破壊度を🟢低(読み取りのみ)/🟡中(可逆的変更)/🔴高(不可逆的変更)で判定する。🔴の場合はスナップショットを必ず取得してから実行する。"},
      {"id":"Ph0.2","name":"Graduated Supervision（監督レベル）","detail":"リスクに応じた監督方式を選択: Self(自己監査/🟢)、Premortem(事前失敗分析/🟡)、External(外部検証要求/🔴)。"},
      {"id":"Ph0.3","name":"Graduated Enforcement（品質保証レベル）","detail":"Anti-Skip(ステップ省略禁止)、Schema(出力形式の検証)、Guardrails(安全制約の適用)を選択。"},
      {"id":"Ph1","name":"実行+Self-Audit","detail":"計画に基づきファイルを変更する。各ファイルについて: (1)現在の内容を読み込み (2)変更を適用 (3)変更が意図通りかを自己監査。変更理由をコミットメッセージ形式で記録する。"},
      {"id":"Ph1.5","name":"Quality Gate（品質ゲート）","detail":"変更されたファイルに対して自動検証を実行: Metrika(コード品質メトリクス)、Chreos(技術的負債チェック)、Palimpsest(既存テストとの整合性)。"},
      {"id":"Ph2","name":"Early Catch検証","detail":"4段階の検証を順に実行: (1)Build — ビルドが通るか (2)Lint — 静的解析エラーがないか (3)Unit — 単体テスト通過 (4)Integration — 統合テスト通過。各段階で失敗したら即座に修正。"},
      {"id":"Ph3","name":"偏差検知","detail":"計画と成果物の差分を3軸で確認: (1)スコープ — 計画外の変更がないか (2)完全性 — 計画した変更が全て反映されたか (3)トレーサビリティ — 各変更が計画のどの項目に対応するか。"},
      {"id":"Ph3.5","name":"動的リプランニング","detail":"偏差検出時に4つの対応から選択: 修正(元の計画に戻す)、迂回(別の方法で同じ目標)、縮小(スコープを狭める)、中断(Creatorに相談)。テスト3回連続失敗→Creatorに報告。"},
      {"id":"Ph4","name":"完了確認","detail":"変更サマリー + 全ゲート結果 + コミット提案(Conventional Commits形式: feat/fix/refactor等)をCreatorに提示する。"},
      {"id":"Ph5","name":"安全弁（ロールバック準備）","detail":"復元ポイント + 変更一覧 + 影響範囲を記録。万が一の場合に元に戻せる状態を保証する。"}
    ],
    "derivatives": [
      {"name":"flow","when":"没入して集中的に作業を進めたい時。中断を最小化したい","output":"中断なしの連続実行。フェーズ間の確認を最小化し、最後にまとめて報告","example":"「この5ファイルの修正を一気にやって」→ 全ファイルを連続修正、最後にまとめてレビュー"},
      {"name":"constructive","when":"批判やレビュー指摘を受けた後、それを改善に変換したい時","output":"批判→構造的改善計画→実行。否定的フィードバックを成長の材料に変換","example":"「コードが汚い」→ 具体的なリファクタリング計画を策定し実行"},
      {"name":"prax","when":"成果物より実行プロセスの質を重視したい時","output":"過程の記録を重視した実行。各判断の理由と代替案を文書化","example":"「学習目的でゼロから書きたい」→ ライブラリ使わずに手動実装、途中の判断を全記録"},
      {"name":"pois","when":"具体的な成果物の完成を最優先にしたい時","output":"最短経路での成果物完成。Must/Should/Could基準で優先度を管理","example":"「デモ用にとにかく動くものが欲しい」→ Mustのみ実装、Should/Couldは後回し"}
    ],
    "usecases": [
      {"situation":"計画承認後の実装","trigger":"「y」と答えた時、または/planの結果を承認した時","action":"/ene が暗黙発動。リスク判定 → 実行 → 品質検証 → 偏差検知 → 完了確認の順に実行","result":"計画通りの変更が安全に適用され、テストも通過した状態で完了"},
      {"situation":"リスクの高い変更を行う時","trigger":"データベース移行、本番環境変更、大規模リファクタリング等","action":"/ene+ でPh0.1のRisk Tag🔴を適用。スナップショット取得 → Premortem → 段階的実行 → 各段階でCreator確認","result":"不可逆的な失敗を防ぎ、問題があれば即座にロールバック可能"},
      {"situation":"テストが連続失敗する時","trigger":"Ph2のEarly Catch検証で3回連続失敗した時","action":"自動的にCreatorに報告し判断を委任する。自力で無限ループに陥ることを防ぐ","result":"人間の判断が介入し、根本原因の特定と方針転換が行われる"},
      {"situation":"外部フィードバックを反映したい","trigger":"レビューコメントや障害報告を受けた時","action":"/ene --derivative=constructive で批判を構造的改善計画に変換し実行","result":"感情的な反応ではなく、建設的な改善が行われる"}
    ],
    "algebra_detail": {
      "+": "/ene+: 全フェーズ完全実行。リスク判定必須、Quality Gate必須、偏差検知必須。安全性を最大限に保証する詳細実行",
      "-": "/ene-: 最小限の実行。リスク🟢のタスクのみ。軽微な修正やドキュメント更新に使う",
      "*": "/ene*: 実行プロセス自体のメタ分析。「この実行方法は効率的か」「もっと良い実行手順はないか」を検証"
    }
  }
}

# Read and patch wf-data.js
with open('/home/makaron8426/oikos/hegemonikon/docs/wf-data.js', 'r') as f:
    content = f.read()

import re
m = re.search(r'const WF_DATA = ({.*?});\s*\n', content, re.DOTALL)
if not m:
    print("ERROR: WF_DATA not found")
    exit(1)

wf_obj = json.loads(m.group(1))

for cmd, rich in RICH_DATA.items():
    if cmd not in wf_obj:
        print(f"SKIP: {cmd} not in WF_DATA")
        continue
    
    wf_obj[cmd]['desc'] = rich['desc']
    wf_obj[cmd]['phases'] = rich['phases']
    wf_obj[cmd]['derivatives'] = rich['derivatives']
    wf_obj[cmd]['usecases'] = rich['usecases']
    if 'algebra_detail' in rich:
        wf_obj[cmd]['algebra'] = rich['algebra_detail']

new_wf = json.dumps(wf_obj, ensure_ascii=False, indent=1)
content = content[:m.start(1)] + new_wf + content[m.end(1):]

with open('/home/makaron8426/oikos/hegemonikon/docs/wf-data.js', 'w') as f:
    f.write(content)

# Stats
for cmd in ['noe','bou','zet','ene']:
    d = wf_obj[cmd]
    p = len(d.get('phases',[]))
    dr = len(d.get('derivatives',[]))
    u = len(d.get('usecases',[]))
    print(f"  /{cmd}: {p} phases, {dr} derivatives, {u} usecases")
print("O-series enrichment complete!")
