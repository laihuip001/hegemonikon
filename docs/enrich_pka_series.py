#!/usr/bin/env python3
"""Enrich P/K/A series WFs with BC-15 compliant detailed data."""
import json, re

RICH_DATA = {
  "kho": {
    "desc": "場・文脈・環境を認識するツール。「今どこにいるか」ではなく「この場がどういう場か」を理解する。安全な場(sandbox)か聖域(kernel)か作業場(workspace)かで、取るべき行動の安全レベルが変わる。ファイルパスやgit状態から場の性質を自動判定する。",
    "phases": [
      {"id":"Ph1","name":"場の同定","detail":"操作対象のパスやコンテキストから場の種類を判定する。kernel/(聖域)、experiments/(遊び場)、mekhane/(作業場)、外部API(外界)の4分類。"},
      {"id":"Ph2","name":"安全レベル決定","detail":"場の性質に応じた安全レベルを設定。聖域→LBYL(事前確認必須)、遊び場→EAFP(失敗OK)、作業場→EAFP+レビュー、外界→LBYL。"},
      {"id":"Ph3","name":"制約の適用","detail":"決定した安全レベルに基づき、操作に対する制約を適用する。commit前レビュー、スナップショット取得、Creator承認などの条件を自動設定。"}
    ],
    "derivatives": [
      {"name":"scan","when":"作業前に環境を確認したい時","output":"場の分類+安全レベル+適用される制約のリスト","example":"作業開始時にgit status + ファイルパスから「作業場/可逆/EAFP」と判定"},
      {"name":"guard","when":"危険な操作の前にガードレールを設置したい時","output":"操作のリスク評価+必要な事前措置+ロールバック計画","example":"DB移行前に「外界/不可逆/LBYL」→ バックアップ必須+Creator承認必須"},
      {"name":"navigate","when":"場を移動する時に適切な振る舞いを確認したい時","output":"移動先の場の性質+変更される制約+注意事項","example":"sandbox→kernel移動時に「安全レベルが上がります。変更にはCreator承認が必要です」"}
    ],
    "usecases": [
      {"situation":"安全な変更範囲の確認","trigger":"「この変更はどこまで影響するか」を事前に知りたい時","action":"/kho で場を同定 → 安全レベルに応じた操作方針を設定","result":"場の性質に合った安全策が自動的に適用される"},
      {"situation":"本番環境への操作前","trigger":"不可逆的な操作を行う前","action":"/kho --derivative=guard で操作のリスクを評価 → スナップショット+承認フローを設定","result":"万が一の時にロールバック可能な状態が保証される"},
      {"situation":"新しいプロジェクトへの着手","trigger":"初めてのコードベースで作業を開始する時","action":"/kho --derivative=scan で環境を理解 → 場の構造と制約を把握","result":"「どこが危険でどこが安全か」がわかり、適切な注意力で作業できる"}
    ],
    "algebra_detail": {"+":"/kho+: 全場の詳細マッピング+安全レベル+制約+リスク評価を含む完全な環境分析","-":"/kho-: 現在の場の分類と安全レベルのみ。即座に判定","*":"/kho*: 場の分類基準自体のメタ分析。「この分類は適切か」"}
  },
  "hod": {
    "desc": "全体のロードマップ・進行計画を策定するツール。個々のタスクではなく、プロジェクト全体の方向性と段階を設計する。マイルストーンの設定、依存関係の整理、フェーズ分割を行い、/chr(時系列配置)や/ene(実行)の入力を生成する。",
    "phases": [
      {"id":"Ph1","name":"ゴール定義","detail":"最終的に達成すべき状態を具体的に定義する。/bouの出力を入力として、計測可能な達成基準を設定。"},
      {"id":"Ph2","name":"フェーズ分割","detail":"ゴールまでの道のりを3-5フェーズに分割する。各フェーズの成果物と完了条件を定義。"},
      {"id":"Ph3","name":"依存関係分析","detail":"フェーズ間、タスク間の依存関係を特定する。並列化可能な部分と順序必須な部分を区別。"},
      {"id":"Ph4","name":"リスクポイント特定","detail":"各フェーズの失敗リスクを事前に特定し、対策を準備する。Pre-Mortem的アプローチ。"}
    ],
    "derivatives": [
      {"name":"roadmap","when":"プロジェクト全体の計画を立てたい時","output":"フェーズ分割+マイルストーン+依存関係図+リスクポイント","example":"3ヶ月の開発計画: 4フェーズ、各フェーズに達成基準とリスク対策"},
      {"name":"sprint","when":"短期間の作業計画を立てたい時","output":"1-2週間の具体的タスクリスト+優先順位+完了基準","example":"今週のスプリント: 8タスク、依存関係で3→2→3に分割"},
      {"name":"pivot","when":"計画の方向転換が必要な時","output":"現計画vs新計画の比較+移行コスト+推奨判断","example":"「方針を変えるべきか」→ 現計画のサンクコストvs新計画の期待値を比較"}
    ],
    "usecases": [
      {"situation":"新プロジェクト開始","trigger":"中長期のプロジェクトを始める前に計画を立てたい時","action":"/hod で全体ロードマップを策定 → /chr で時系列に配置 → /ene で実行開始","result":"見通しの良い計画ができ、途中で迷うことが減る"},
      {"situation":"スプリント計画","trigger":"今週の作業を具体的に決めたい時","action":"/hod --derivative=sprint で短期タスクを整理 → 優先順位付け → 実行","result":"「今日何をやるか」が毎朝明確になる"},
      {"situation":"方針転換の判断","trigger":"計画通りに進まず、方向転換を検討している時","action":"/hod --derivative=pivot で現計画と代替計画を比較 → サンクコストを排除して判断","result":"感情ではなくデータに基づいた方針転換の判断ができる"}
    ],
    "algebra_detail": {"+":"/hod+: 全フェーズの詳細計画+依存関係図+リスク分析+マイルストーンを含む完全なロードマップ","-":"/hod-: 主要3フェーズとそれぞれの1行ゴールのみ","*":"/hod*: 計画手法自体のメタ分析。「この計画の立て方は効果的か」"}
  },
  "tro": {
    "desc": "環境の変化・外乱に対する適応戦略を設計するツール。予期しない変化への対応方法を事前に準備する。レジリエンス（回復力）とアダプタビリティ（適応力）の両面から環境変化への耐性を構築する。",
    "phases": [
      {"id":"Ph1","name":"変化の検出","detail":"環境の変化を検出・分類する。技術的変化(依存ライブラリ更新)、組織的変化(チーム再編)、市場変化(競合出現)など。"},
      {"id":"Ph2","name":"影響評価","detail":"検出された変化の影響範囲と深刻度を評価する。直接的影響と間接的影響を区別し、波及効果を予測。"},
      {"id":"Ph3","name":"適応戦略設計","detail":"変化への対応方法を設計: 吸収(変化を内部で処理)、回避(変化の影響を受けない設計)、変換(変化をチャンスに変える)。"},
      {"id":"Ph4","name":"レジリエンス強化","detail":"将来の変化に備えた耐性構築: 疎結合設計、フォールバック機構、段階的デグレーション。"}
    ],
    "derivatives": [
      {"name":"detect","when":"環境変化を早期に検出したい時","output":"変化のリスト+分類+深刻度スコア","example":"依存ライブラリのdeprecation警告を検出 → 移行計画を策定"},
      {"name":"adapt","when":"変化に対する具体的な適応策を立てたい時","output":"適応戦略(吸収/回避/変換)+実行計画+タイムライン","example":"Python 2→3移行: 段階的移行戦略+互換性ラッパー設計"},
      {"name":"harden","when":"将来の変化に備えたい時","output":"レジリエンス設計+フォールバック+デグレーション計画","example":"API依存を抽象化し、提供者が変わっても内部に影響しない設計"}
    ],
    "usecases": [
      {"situation":"依存ライブラリの破壊的変更","trigger":"使用しているライブラリに破壊的変更が予告された時","action":"/tro --derivative=detect で影響評価 → --derivative=adapt で移行戦略を設計 → /ene で実行","result":"破壊的変更に対する段階的な移行計画ができる"},
      {"situation":"予防的なレジリエンス構築","trigger":"まだ問題は起きていないが、将来の変化に備えたい時","action":"/tro --derivative=harden で脆弱点を特定 → 疎結合設計+フォールバック機構を設計","result":"予期しない変化が来ても影響範囲が限定される"},
      {"situation":"計画外の環境変化への対応","trigger":"予期しない技術的・組織的変化が発生した時","action":"/tro で変化を検出・分類 → 影響評価 → 吸収/回避/変換から最適な戦略を選択","result":"パニックではなく構造的な対応ができる"}
    ],
    "algebra_detail": {"+":"/tro+: 全変化の検出+影響評価+適応戦略+レジリエンス設計を含む完全な適応分析","-":"/tro-: 最も差し迫った変化1つとその対応策のみ","*":"/tro*: 適応戦略自体のメタ分析。「この対応方法は適切か」"}
  },
  "tek": {
    "desc": "スキル（技能）の習得・向上を支援するツール。「何を学ぶべきか」「どう学ぶべきか」「今の習熟度はどこか」を構造的に管理する。学習の計画、実行、評価のサイクルを回す。",
    "phases": [
      {"id":"Ph1","name":"スキルマッピング","detail":"現在のスキルセットと目標のスキルセットを可視化する。ギャップを特定し、学習優先順位を決める。"},
      {"id":"Ph2","name":"学習計画","detail":"ギャップを埋めるための具体的な学習計画を立てる。リソース、時間配分、マイルストーンを設定。"},
      {"id":"Ph3","name":"習熟度評価","detail":"学習の進捗を評価する。4段階(初心者/実践者/熟練者/達人)で現在位置を判定。"},
      {"id":"Ph4","name":"知識連関","detail":"新しく学んだスキルと既存スキルの関係性を可視化する。転移学習の可能性を特定。"}
    ],
    "derivatives": [
      {"name":"assess","when":"現在のスキルレベルを評価したい時","output":"スキルマップ+各スキルの習熟度+ギャップ分析","example":"TypeScriptスキル評価: 型システム=熟練、ジェネリクス=実践者、条件型=初心者"},
      {"name":"plan","when":"学習計画を立てたい時","output":"学習ロードマップ+リソースリスト+マイルストーン+期限","example":"Rustを3ヶ月で実践レベルに: Week1-4基礎→Week5-8実践→Week9-12プロジェクト"},
      {"name":"transfer","when":"既存スキルを新領域に転用したい時","output":"転移可能なスキルの特定+転用戦略+差分学習計画","example":"Pythonの経験をRustに転用: 共通概念(イテレータ等)+差分概念(所有権等)を分離"}
    ],
    "usecases": [
      {"situation":"新技術の学習計画","trigger":"新しい言語やフレームワークを学ぶ必要がある時","action":"/tek --derivative=plan で体系的な学習計画を策定 → マイルストーンごとに進捗確認","result":"散漫にならず、計画的に習得できる"},
      {"situation":"スキルギャップの把握","trigger":"「何がわからないのかわからない」状態の時","action":"/tek --derivative=assess で現状のスキルマップを作成 → ギャップを可視化","result":"学ぶべきことの優先順位が明確になる"},
      {"situation":"既存スキルの活用","trigger":"新領域に入る時、既存知識をどう活かせるか知りたい時","action":"/tek --derivative=transfer で転移可能なスキルを特定 → 差分のみの学習計画を策定","result":"ゼロからではなく、既存知識を活用した効率的な学習ができる"}
    ],
    "algebra_detail": {"+":"/tek+: 完全なスキルマッピング+詳細学習計画+転移分析+習熟度評価を含む包括的学習支援","-":"/tek-: 最も重要なスキルギャップ1つとその対策のみ","*":"/tek*: 学習方法自体のメタ分析。「この学び方は効率的か」"}
  },
  "euk": {
    "desc": "好機（チャンス）を発見・評価するツール。タイミングの良い行動（カイロス的判断）を支援する。「今やるべきか」「待つべきか」を判断し、機会の窓が開いている間に行動を起こす。",
    "phases": [
      {"id":"Ph1","name":"機会の探索","detail":"現在の状況から機会を見つける。外部環境の変化、技術的ブレークスルー、組織の空白、リソースの余剰などをスキャン。"},
      {"id":"Ph2","name":"タイミング評価","detail":"各機会の「窓」の大きさと残り時間を評価。今動くべきか、待つべきか、いつまで有効かを判定。"},
      {"id":"Ph3","name":"コスト-機会分析","detail":"机会を逃すコスト(opportunity cost)と行動のコストを比較。「やらないリスク」を定量化する。"},
      {"id":"Ph4","name":"アクション接続","detail":"行動する場合、/ene への接続。待つ場合、監視計画の設定。"}
    ],
    "derivatives": [
      {"name":"scan","when":"現在の機会を広くスキャンしたい時","output":"機会リスト+各機会の窓の大きさ+タイミング評価","example":"新しいOpenAI APIリリース: 早期採用の窓=2ヶ月、先行者メリットありと判定"},
      {"name":"assess","when":"特定の機会を深く評価したい時","output":"機会の価値+リスク+コスト+タイミングの詳細分析","example":"OSS貢献の機会: 価値(学習+認知度)高、コスト(時間)中、窓=Issue公開中"},
      {"name":"time","when":"「いつ行動すべきか」を正確に判断したい時","output":"最適タイミングの判定+根拠+代替タイミング","example":"リファクタリング: 新機能追加の前(今週)がベスト。来月だとコスト2倍"}
    ],
    "usecases": [
      {"situation":"新技術・新ツールの採用判断","trigger":"新しい技術が出た時、「今採用すべきか」を判断したい","action":"/euk --derivative=assess で早期採用のメリット/リスクを評価 → タイミングを判定","result":"「今」「3ヶ月後」「見送り」のいずれかを根拠付きで判断できる"},
      {"situation":"定期的な機会のスキャン","trigger":"現在の環境に利用可能な機会がないか確認したい時","action":"/euk --derivative=scan で機会を広くスキャン → 有望なものを /zet で深掘り","result":"見逃していた機会が発見される"},
      {"situation":"行動のタイミング判断","trigger":"「そろそろやるべきだが、いつが最適か」を決めたい時","action":"/euk --derivative=time で最適タイミングを判定 → /ene で実行開始","result":"早すぎず遅すぎない、最適なタイミングで行動できる"}
    ],
    "algebra_detail": {"+":"/euk+: 全機会のスキャン+詳細評価+タイミング分析+コスト-機会比較を含む完全な機会分析","-":"/euk-: 最も差し迫った機会1つとアクション推奨のみ","*":"/euk*: 機会評価方法自体のメタ分析。「この評価は見落としがないか」"}
  },
  "chr": {
    "desc": "時系列配置ツール。タスクや活動を時間軸上に配置し、スケジュールを作る。/hodのフェーズを具体的な日程に落とし、時間の使い方を最適化する。ガントチャート的な機能。",
    "phases": [
      {"id":"Ph1","name":"タスク列挙","detail":"配置すべきタスクを全て列挙する。/hodのフェーズ分割や/bouの行動計画を入力として使用。"},
      {"id":"Ph2","name":"工数見積もり","detail":"各タスクの所要時間を見積もる。楽観/標準/悲観の3点見積もりで不確実性を表現。"},
      {"id":"Ph3","name":"依存関係適用","detail":"タスク間の依存関係を反映し、実行可能な順序を決定する。並列化可能な部分を特定。"},
      {"id":"Ph4","name":"スケジュール配置","detail":"時間軸上にタスクを配置する。リソース制約（1日の作業可能時間等）を考慮。"}
    ],
    "derivatives": [
      {"name":"schedule","when":"具体的なスケジュールを作りたい時","output":"日程表+マイルストーン+クリティカルパス","example":"来週の開発計画: 月-水でAPI開発、木にテスト、金にデプロイ"},
      {"name":"estimate","when":"作業時間を見積もりたい時","output":"3点見積もり(楽観/標準/悲観)+リスクファクター","example":"新機能開発の見積もり: 楽観3日、標準5日、悲観10日(外部API依存のリスク)"},
      {"name":"replan","when":"スケジュールの再調整が必要な時","output":"現計画vs調整案+影響範囲+トレードオフ","example":"遅延発生: 機能Aを1日遅延→機能Bを並列化して全体は2日遅延に抑制"}
    ],
    "usecases": [
      {"situation":"週次計画の作成","trigger":"来週の作業を具体的にスケジュールしたい時","action":"/chr でタスクを時間軸に配置 → 依存関係を反映 → 実行可能なスケジュールを作成","result":"日ごとの作業計画が明確になり、進捗の追跡が容易になる"},
      {"situation":"見積もりの精度向上","trigger":"「この作業にどれくらいかかるか」を正確に見積もりたい時","action":"/chr --derivative=estimate で3点見積もりを実行 → リスクファクターを加味","result":"過小見積もりによる遅延リスクが低減される"},
      {"situation":"遅延時のリスケジュール","trigger":"計画通りに進んでおらず、調整が必要な時","action":"/chr --derivative=replan で影響範囲を特定 → 並列化/省略/延期の選択肢を提示","result":"遅延の影響を最小限に抑えた調整案が得られる"}
    ],
    "algebra_detail": {"+":"/chr+: 全タスクの3点見積もり+依存関係図+クリティカルパス+リスク分析を含む詳細スケジュール","-":"/chr-: 主要タスクの順序と大まかな日程のみ","*":"/chr*: スケジューリング手法自体のメタ分析。「この計画方法は現実的か」"}
  },
  "tel": {
    "desc": "目的の自問ツール。「そもそも何のためにやっているか」を問い直す。手段の目的化（本来の目的を忘れて手段に没頭する）を検出し、元の目的に立ち返る。定期的に使うことで方向性の漂流(Drift)を防ぐ。",
    "phases": [
      {"id":"Ph1","name":"現在の目的確認","detail":"今追求している目的を明文化する。暗黙的に「当然」と思っている目的も含めて全て列挙。"},
      {"id":"Ph2","name":"手段-目的チェーン","detail":"「なぜそれをやっているか」を遡り、手段→目的→上位目的のチェーンを構築。各レベルで「本当にこの目的が正しいか」を問う。"},
      {"id":"Ph3","name":"目的化検出","detail":"手段が目的化していないかを検出。「この作業は元々何のためだったか」を問い、手段と目的の倒錯がないか確認。"},
      {"id":"Ph4","name":"方向修正","detail":"目的化が検出された場合、元の目的に立ち返り、より効率的な手段を再選択。検出されなかった場合、現在の方向を確認。"}
    ],
    "derivatives": [
      {"name":"check","when":"定期的に目的を確認したい時","output":"目的チェーンの可視化+目的化の有無+方向性の評価","example":"毎週金曜に1分間: 「今週やったことは元々何のためだったか」を確認"},
      {"name":"realign","when":"目的と手段の乖離を修正したい時","output":"乖離の特定+元の目的の再確認+代替手段の提案","example":"「テストフレームワークの改善」に没頭 → 元の目的は「品質向上」→ テスト以外の方法も検討"},
      {"name":"upstream","when":"上位目的から現在の行動を再評価したい時","output":"上位目的からの逆算+現在の行動の妥当性評価+優先順位の再設定","example":"「なぜHGKを作っているか」→ 上位目的「AIとの共創の質を上げる」→ 現在のタスクの妥当性を再評価"}
    ],
    "usecases": [
      {"situation":"作業に没頭しすぎた時","trigger":"長時間同じ作業を続けていて、「これは本当に必要か」と疑問が生じた時","action":"/tel --derivative=check で手段-目的チェーンを構築 → 目的化の検出 → 必要なら方向修正","result":"無駄な作業を早期に発見し、本当に重要なことにリソースを振り向けられる"},
      {"situation":"手段の目的化の疑い","trigger":"「なぜこれをやっているか」に即答できない時","action":"/tel --derivative=realign で乖離を特定 → 元の目的を再確認 → 代替手段を検討","result":"手段と目的の倒錯が解消され、効率的な方法に切り替えられる"},
      {"situation":"プロジェクトの方向性確認","trigger":"定期的（月次等）にプロジェクトの方向性を確認したい時","action":"/tel --derivative=upstream で上位目的から現在の行動を再評価","result":"長期的な方向性の漂流(Drift)を早期に検出できる"}
    ],
    "algebra_detail": {"+":"/tel+: 手段-目的チェーンの全レベル分析+目的化検出+方向修正+上位目的からの再評価を含む詳細な目的自問","-":"/tel-: 「今やっていることは何のため？」への1行回答のみ","*":"/tel*: 目的自問プロセス自体のメタ分析。「この問い方で本当の目的が見えるか」"}
  },
  "sop": {
    "desc": "外部調査依頼書を生成するツール。自分（Claude）では答えられない問いを、Perplexity等の外部検索ツールに委任するための構造化された調査依頼書を作る。問いの設計が調査の質を決めるため、問いの構造化に注力する。",
    "phases": [
      {"id":"Ph1","name":"調査目的の定義","detail":"「何を知りたいか」を明確に定義する。曖昧な好奇心ではなく、行動に繋がる問いに変換する。「これがわかったら何が変わるか」を事前に明確化。"},
      {"id":"Ph2","name":"問いの構造化","detail":"大きな問いを検索可能な小問に分割する。各小問に対してキーワード、期待する回答の形式、判断基準を設定。"},
      {"id":"Ph3","name":"調査依頼書の生成","detail":"Perplexity Pro等で検索するための構造化された依頼書を生成。コピー&ペーストで即座に使える形式。"},
      {"id":"Ph4","name":"結果の統合計画","detail":"調査結果が返ってきた後、どう統合するかの計画を事前に設計。/noeや/diaへの接続点を明示。"}
    ],
    "derivatives": [
      {"name":"shallow","when":"素早く事実確認だけしたい時","output":"1-2問の簡潔な検索クエリ+期待する回答形式","example":"「Tauri v2のfileDialogのAPI名は？」→ 1クエリで回答を得る"},
      {"name":"deep","when":"テーマを深く調査したい時","output":"5-10問の体系的な調査依頼書+文献推薦リクエスト+比較表テンプレート","example":"「FEPの最新研究動向」→ 5つの角度から調査+2024年以降の論文に限定"},
      {"name":"comparative","when":"複数の選択肢を比較調査したい時","output":"比較軸の定義+各選択肢への同一質問群+比較表テンプレート","example":"「React vs Vue vs Svelte」→ 7つの比較軸で統一フォーマットの調査"}
    ],
    "usecases": [
      {"situation":"知識の限界に到達した時","trigger":"Claudeの知識カットオフ以降の情報が必要な時","action":"/sop で構造化された調査依頼書を生成 → Perplexity Proで検索 → 結果を/doxで記録","result":"最新の正確な情報に基づいた判断ができる"},
      {"situation":"技術選択の調査","trigger":"「AとBどちらの技術を採用すべきか」を調査したい時","action":"/sop --derivative=comparative で比較調査依頼書を生成 → 調査 → /dia で評価","result":"統一基準での比較情報が得られ、公平な技術選択ができる"},
      {"situation":"論文・文献の調査","trigger":"学術的な根拠が必要な時","action":"/sop --derivative=deep で体系的な調査依頼書を生成 → 文献検索 → /eat で消化","result":"体系的な学術調査が効率的に行える"}
    ],
    "algebra_detail": {"+":"/sop+: 5-10問の体系的調査依頼書+文献推薦+比較表+結果統合計画を含む詳細調査","-":"/sop-: 1-2問の簡潔な検索クエリのみ","*":"/sop*: 調査方法自体のメタ分析。「この問い方で必要な情報が得られるか」"}
  },
  "pat": {
    "desc": "パターン認識・抽出ツール。経験や事例から再利用可能なパターンを見つけ出す。「これは前にも見たことがある」という直感を構造化し、パターンライブラリとして蓄積する。",
    "phases": [
      {"id":"Ph1","name":"事例収集","detail":"類似する事例を3つ以上収集する。表面的な類似ではなく、構造的な共通点を持つ事例を選ぶ。"},
      {"id":"Ph2","name":"共通構造の抽出","detail":"事例間の共通パターンを抽出する。「何が同じで何が違うか」を構造的に分析。"},
      {"id":"Ph3","name":"パターンの命名・定義","detail":"発見したパターンに名前と定義を与える。適用条件、結果、副作用を明文化。"},
      {"id":"Ph4","name":"パターンの登録","detail":"発見したパターンをpatterns.yamlや KIに登録。将来の参照に備える。"}
    ],
    "derivatives": [
      {"name":"extract","when":"経験からパターンを抽出したい時","output":"パターン定義+適用条件+3つの事例+副作用","example":"「コードレビューで同じ指摘が3回」→ パターン「早期バリデーション不足」を抽出"},
      {"name":"match","when":"現在の状況に適用可能なパターンを探したい時","output":"マッチするパターンリスト+適合度+推奨アクション","example":"新しいバグ報告を受けて → 「NULL参照パターン」にマッチ → 定型的な修正手順を適用"},
      {"name":"evolve","when":"既存パターンを更新・進化させたい時","output":"パターンの変更履歴+更新内容+影響範囲","example":"「早期バリデーション」パターンに「型安全性チェック」を追加"}
    ],
    "usecases": [
      {"situation":"同じ問題に何度も遭遇する時","trigger":"「これ前にもやった」という感覚がある時","action":"/pat --derivative=extract で共通パターンを抽出 → 命名 → パターンライブラリに登録","result":"次回から同じ問題に構造的に対処できる"},
      {"situation":"新しい問題に既存知識を適用したい時","trigger":"問題を見て「何かに似ている」と感じた時","action":"/pat --derivative=match で類似パターンを検索 → 適合するパターンの推奨アクションを適用","result":"ゼロから考えるのではなく、蓄積されたパターンで効率的に解決できる"},
      {"situation":"知見のパターン化","trigger":"プロジェクトの振り返り時に学びを構造化したい時","action":"/pat で振り返り事例からパターンを抽出 → /dox で永続化","result":"暗黙知が形式知に変換され、チームで共有可能になる"}
    ],
    "algebra_detail": {"+":"/pat+: 3事例以上の詳細分析+構造的パターン抽出+命名+登録+副作用分析を含む完全なパターン分析","-":"/pat-: 直感的なパターンマッチのみ。「これは〜パターンに似ている」の1行","*":"/pat*: パターン認識方法自体のメタ分析。「このパターン化は過剰一般化ではないか」"}
  },
  "dia": {
    "desc": "批判的レビュー・判定ツール。コード、設計、文書に対する敵対的レビューを行う。「良い点」ではなく「壊れる点」を積極的に探す。開発者（作者）とは異なる視点で、品質の穴を見つける。",
    "phases": [
      {"id":"Ph1","name":"レビュー対象の確認","detail":"レビュー対象を特定し、スコープを決める。何を見るか(コード/設計/文書)、どの観点で見るか(正確性/効率性/保守性/安全性)を事前に明確化。"},
      {"id":"Ph2","name":"敵対的レビュー","detail":"「この成果物が失敗するとしたらどこか」を積極的に探す。作者の意図を理解した上で、見落としや盲点を特定。"},
      {"id":"Ph3","name":"問題の分類と優先度付け","detail":"発見した問題をCritical/Major/Minor/Nitpickに分類。各問題に修正提案と根拠を添付。"},
      {"id":"Ph4","name":"総合判断","detail":"LGTM(承認)/要修正/要再設計の3段階で判定。修正後の再レビュー条件を明示。"}
    ],
    "derivatives": [
      {"name":"code","when":"コードをレビューしたい時","output":"問題リスト(分類+優先度+修正提案)+テスト提案+総合判定","example":"PR400行のレビュー: Critical 2件(NULL未チェック、SQLインジェクション)、Minor 5件"},
      {"name":"design","when":"設計をレビューしたい時","output":"設計上の懸念+代替案+トレードオフ分析+判定","example":"マイクロサービス分割案のレビュー: 結合度が高すぎる3箇所を指摘+分割案を提示"},
      {"name":"doc","when":"文書をレビューしたい時","output":"正確性/明瞭性/完全性の評価+改善提案+判定","example":"API仕様書のレビュー: 3つのエンドポイントで説明不足、2つの矛盾を検出"},
      {"name":"adversarial","when":"最も厳しいレビューが必要な時","output":"あらゆる観点からの攻撃的レビュー+壊し方の提示+防御策","example":"セキュリティレビュー: 入力バリデーション不足による5つの攻撃ベクトルを特定"}
    ],
    "usecases": [
      {"situation":"PR/MRのレビュー","trigger":"プルリクエストが来た時","action":"/dia --derivative=code で敵対的レビュー → Critical/Major/Minor分類 → 判定","result":"品質の穴が事前に発見され、本番障害のリスクが低減される"},
      {"situation":"設計判断のセカンドオピニオン","trigger":"自分の設計に自信がない時","action":"/dia --derivative=design で設計をレビュー → 懸念点と代替案を提示","result":"盲点が発見され、より堅牢な設計になる"},
      {"situation":"文書の品質確認","trigger":"外部に公開する文書の品質を確認したい時","action":"/dia --derivative=doc で正確性/明瞭性/完全性を評価 → 改善提案","result":"読者にとって理解しやすく正確な文書になる"},
      {"situation":"セキュリティ監査","trigger":"セキュリティが重要なコンポーネントのレビュー時","action":"/dia --derivative=adversarial で攻撃ベクトルを網羅的に特定 → 防御策を設計","result":"攻撃者の視点での脆弱性が発見され、事前に対策できる"}
    ],
    "algebra_detail": {"+":"/dia+: 全観点(正確性/効率性/保守性/安全性)からの詳細レビュー+修正提案+代替案+テスト提案","-":"/dia-: Critical問題の有無のみ即座に判定。3分で完了するクイックレビュー","*":"/dia*: レビュープロセス自体のメタ分析。「このレビュー方法で見落としはないか」"}
  },
  "gno": {
    "desc": "知識構造を構築・管理するツール。個々の知識を体系的に整理し、知識間の関係性を可視化する。百科事典の編集者のように、情報を分類・索引付けし、必要な時に必要な知識に到達できる構造を作る。",
    "phases": [
      {"id":"Ph1","name":"知識の収集","detail":"対象領域の知識を全て収集する。既存のKI、Handoff、コードコメント、文書を横断的にスキャン。"},
      {"id":"Ph2","name":"分類と構造化","detail":"収集した知識をカテゴリに分類し、階層構造を構築する。概念間の関係(is-a, has-a, uses)を定義。"},
      {"id":"Ph3","name":"索引生成","detail":"知識への到達経路を設計する。キーワード索引、概念マップ、クロスリファレンスを作成。"},
      {"id":"Ph4","name":"ギャップ分析","detail":"知識構造の中で欠落している部分を特定する。「何がわかっていないか」を可視化。"}
    ],
    "derivatives": [
      {"name":"organize","when":"既存の知識を整理したい時","output":"分類体系+階層構造+概念マップ","example":"HGK関連の知識を6シリーズ×4定理の構造で整理"},
      {"name":"connect","when":"知識間の関係性を発見したい時","output":"関係マップ+新発見の接続+洞察","example":"FEPとToE(万物の理論)に共通構造を発見 → 新しいKIとして記録"},
      {"name":"audit","when":"知識の正確性・最新性を検証したい時","output":"知識の鮮度チェック+古い情報の特定+更新計画","example":"KI 50件の棚卸し: 10件が6ヶ月以上前の情報→更新 or 廃止を判断"}
    ],
    "usecases": [
      {"situation":"知識ベースの構築","trigger":"新しい領域について体系的な知識基盤を作りたい時","action":"/gno --derivative=organize で知識を収集・分類・構造化 → 索引を生成","result":"散在する知識が体系的に整理され、必要な時に素早く到達できる"},
      {"situation":"知識間の接続発見","trigger":"異なる領域の知識を統合したい時","action":"/gno --derivative=connect で関係マップを作成 → 新しい接続を発見 → /noe で深掘り","result":"異分野の知識が結びつき、新しい洞察が生まれる"},
      {"situation":"知識の保守","trigger":"知識ベースが増えてきて管理が必要な時","action":"/gno --derivative=audit で鮮度と正確性をチェック → 古い情報を更新 or 廃止","result":"常に最新で信頼できる知識ベースが維持される"}
    ],
    "algebra_detail": {"+":"/gno+: 全知識の収集+分類+構造化+索引+ギャップ分析+関係マップを含む完全な知識構造分析","-":"/gno-: 主要カテゴリの一覧と最重要な関係のみ","*":"/gno*: 知識構造化方法自体のメタ分析。「この分類体系は適切か」"}
  },
  "epi": {
    "desc": "信念を知識に昇格させるツール。「思っている」と「知っている」の境界を管理する。十分な根拠と検証を経た信念のみを「知識」として認定し、知識ベースの信頼性を保証する。",
    "phases": [
      {"id":"Ph1","name":"信念の選定","detail":"知識に昇格させる候補の信念を選定する。/doxで保存された信念から、十分な使用実績と検証結果があるものを選ぶ。"},
      {"id":"Ph2","name":"根拠の検証","detail":"信念の根拠を徹底的に検証する。SOURCE/TAINTの追跡、論理的整合性、実証的証拠の3軸で評価。"},
      {"id":"Ph3","name":"反証の試み","detail":"信念を積極的に否定しようとする。反証に耐えた信念のみが知識の候補として残る。"},
      {"id":"Ph4","name":"知識としての認定","detail":"検証と反証を経た信念を「知識」として認定し、KIとして正式に登録する。確信度と根拠を永続化。"}
    ],
    "derivatives": [
      {"name":"justify","when":"信念の根拠を体系的に検証したい時","output":"根拠のリスト+各根拠の質(SOURCE/TAINT)+論理的整合性チェック","example":"「マイクロサービスは複雑」→ 根拠4つ(2がSOURCE、2がTAINT)+論理的に整合"},
      {"name":"falsify","when":"信念を積極的に否定して強度を試したい時","output":"反証の試み+結果(耐えた/崩れた)+修正版の信念","example":"「テストカバレッジ80%で十分」→ 反証: カバレッジ80%でもバグが出た事例3件 → 修正: 「重要パスのカバレッジ95%が必要」"},
      {"name":"promote","when":"十分に検証された信念を正式な知識にしたい時","output":"知識としての認定書+根拠サマリー+KI登録","example":"「Early Return パターンは可読性を上げる」→ 実証5件+反証なし → KIとして正式登録"}
    ],
    "usecases": [
      {"situation":"知識の品質管理","trigger":"KI(Knowledge Item)の信頼性を確認したい時","action":"/epi --derivative=justify で根拠を検証 → --derivative=falsify で反証を試み → 耐えたもののみ維持","result":"知識ベースの中で「本当に確か」なものと「まだ仮説」のものが区別される"},
      {"situation":"設計原則の確立","trigger":"経験則を正式な設計原則に昇格させたい時","action":"/epi で根拠検証+反証テスト+認定 → /dox+ で永続化","result":"チーム共有可能な、根拠付きの設計原則が確立される"},
      {"situation":"古い知識の再検証","trigger":"前提が変わった可能性がある時","action":"/epi --derivative=falsify で既存知識に新しい反証を突きつける → 修正 or 維持","result":"環境変化に対応した最新の知識が維持される"}
    ],
    "algebra_detail": {"+":"/epi+: 全根拠の詳細検証+反証テスト+認定+KI登録を含む完全な知識昇格プロセス","-":"/epi-: 最も確信度の高い1つの信念の簡易検証のみ","*":"/epi*: 知識認定プロセス自体のメタ分析。「この認定基準は厳しすぎるか緩すぎるか」"}
  }
}

with open('/home/makaron8426/oikos/hegemonikon/docs/wf-data.js', 'r') as f:
    content = f.read()

m = re.search(r'const WF_DATA = ({.*?});\s*\n', content, re.DOTALL)
wf_obj = json.loads(m.group(1))

for cmd, rich in RICH_DATA.items():
    if cmd not in wf_obj:
        print(f"SKIP: {cmd}")
        continue
    wf_obj[cmd]['desc'] = rich['desc']
    wf_obj[cmd]['phases'] = rich['phases']
    wf_obj[cmd]['derivatives'] = rich['derivatives']
    wf_obj[cmd]['usecases'] = rich['usecases']
    if 'algebra_detail' in rich:
        wf_obj[cmd]['algebra'] = rich['algebra_detail']

new_wf = json.dumps(wf_obj, ensure_ascii=False, indent=1)
content = content[:m.start(1)] + new_wf + content[m.end(1):]

with open('/home/makaron8426/oikos/hegemonikon/docs/wf-data.js', 'w') as f:
    f.write(content)

for cmd in RICH_DATA:
    d = wf_obj.get(cmd, {})
    print(f"  /{cmd}: {len(d.get('phases',[]))}ph {len(d.get('derivatives',[]))}der {len(d.get('usecases',[]))}uc")
print(f"\nP/K/A series enrichment complete! Total WFs: {len(wf_obj)}")
