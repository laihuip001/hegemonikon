#!/usr/bin/env python3
"""Enrich S-series + H-series WFs with BC-15 compliant detailed data."""
import json, re

RICH_DATA = {
  "met": {
    "desc": "全体構造を俯瞰してシステムの青写真を作るツール。個々の部品ではなく、部品間の関係性（ポリシー・ルール・制約）を設計する。建物でいえば間取り図ではなく都市計画にあたる。",
    "phases": [
      {"id":"Ph1","name":"現状マッピング","detail":"システムの全体像を可視化する。コンポーネント、依存関係、データフロー、制御フローを図示。「何があるか」を漏れなく把握する。"},
      {"id":"Ph2","name":"バランス評価","detail":"システムの各部分の整合性を評価する。過剰な部分、不足している部分、矛盾する部分を特定。4つの軸（一貫性/完全性/冗長性/結合度）で数値化。"},
      {"id":"Ph3","name":"基準策定","detail":"計測可能な品質基準を定義する。「何が良い状態か」を具体的な数値で記述。SLO/SLI的なアプローチで客観的な判断基準を設定。"},
      {"id":"Ph4","name":"ガバナンス設計","detail":"ルール・ポリシー・制約を文書化する。「何をしてよいか/いけないか」を明確化し、個人の判断に依存しない仕組みを作る。"}
    ],
    "derivatives": [
      {"name":"struct","when":"システム構造の全体像を把握したい時","output":"コンポーネント図+依存関係図+データフロー図","example":"新プロジェクト着手時に「何がどう繋がっているか」を可視化"},
      {"name":"balance","when":"システムの整合性に不安がある時","output":"4軸評価(一貫性/完全性/冗長性/結合度)+改善提案","example":"「なぜかバグが多い」→ 結合度が高すぎることを定量的に検出"},
      {"name":"govern","when":"チームのルール・規約を整備したい時","output":"ポリシー文書+判断基準+例外処理規則","example":"コーディング規約策定: 何を強制し何を推奨するかを明文化"}
    ],
    "usecases": [
      {"situation":"新プロジェクトの全体設計","trigger":"「まず何から作るべきか」が不明な時","action":"/met で全体像をマッピング → コンポーネント分割 → 依存関係の順序を決定","result":"開発順序と並列化可能な部分が明確になる"},
      {"situation":"レガシーシステムの理解","trigger":"既存コードベースに入った時、全体像を把握したい","action":"/met --derivative=struct でコンポーネントと依存関係を可視化","result":"どこに手を入れると何に影響するかがわかる"},
      {"situation":"品質基準の策定","trigger":"「何が良いコードか」の認識がチーム内でずれている時","action":"/met --derivative=govern で計測可能な品質基準を定義","result":"主観ではなく客観的な基準で判断できるようになる"}
    ],
    "algebra_detail": {"+":"/met+: 全軸評価+ガバナンス設計を含む詳細分析","-":"/met-: 主要コンポーネントと依存関係のみの簡易マップ","*":"/met*: 設計手法自体のメタ評価。「この設計アプローチは適切か」"}
  },
  "mek": {
    "desc": "スキル・ワークフロー・プロンプトを生成・診断・改善するツール。「方法を作る方法」。既存部品の組合せ(comp)、新規発明(inve)、既存の適応(adap)など複数のモードを持ち、品質スコアリングと自動改善まで一貫して行う。",
    "phases": [
      {"id":"STEP 0","name":"SKILL.md読込","detail":"tekhne-makerの正本を読み込む。生成品質に直結するため省略禁止。"},
      {"id":"STEP 1","name":"モード判定","detail":"要件から最適なモードを判定する(1分)。生成/診断/改善/CCL生成のいずれか。明示指定がなければGenerateモード。"},
      {"id":"STEP 1.5","name":"Information Absorption","detail":"背景情報の吸収(3分)。Creator の暗黙知を3つの問いで引き出す: (1)当たり前と思っている知識 (2)ドメインの暗黙の前提 (3)過去の関連KI/Handoff。背景情報3倍則: 指示トークン × 3 = 必要な背景トークン。"},
      {"id":"STEP 2","name":"Semantic Audit","detail":"M1 OVERLORD — 曖昧性検出(2分)。入力の曖昧な部分を特定し、Hidden Agenda（暗黙の意図）を抽出する。"},
      {"id":"STEP 3","name":"3層処理","detail":"M2 RECURSIVE_CORE (5分): Layer 1拡散 → Layer 2対立(Fail Fast: 失敗シナリオを事前検討) → Layer 3収束。「この生成物が失敗するとしたらなぜか」を必ず問う。"},
      {"id":"STEP 4","name":"Archetype選択","detail":"M3 — 5つの型(Precision/Speed/Autonomy/Creative/Safety)から生成物の特性を選択。5つの診断質問で判定する。"},
      {"id":"STEP 5","name":"出力生成","detail":"M4 RENDERING_CORE (5分)。BLUF Rule(結論先行) + Visual Logic Rule(視覚的構造化)に基づく出力。"},
      {"id":"STEP 6","name":"品質検証","detail":"M5 QUALITY_ASSURANCE (2分)。Pre-Mortem Simulation + 品質スコアリング。スコア80未満→Self-Refineパイプラインで自動改善。"},
      {"id":"STEP 7","name":"初版確認","detail":"SE反復原則: 生成物は「初版」として扱い、/dia-でクイックレビューを推奨する。完璧を目指さず、フィードバックループを回す。"}
    ],
    "derivatives": [
      {"name":"comp","when":"既存の部品やパターンを組み合わせて作りたい時","output":"既存コンポーネントの組合せによる新規生成物。統合設計図","example":"「認証+通知+ログ」を組み合わせた統合ミドルウェアの設計"},
      {"name":"inve","when":"前例のないものを新規に作りたい時","output":"ゼロから設計された新規生成物。根拠と代替案を含む","example":"「HGK独自のプロンプト言語」の設計 — 既存に類似がない"},
      {"name":"adap","when":"既存のツールを別の目的に転用・適応させたい時","output":"既存ツールのカスタマイズ計画。変更点と影響範囲","example":"JestのテストフレームワークをWF品質検証用に適応させる"},
      {"name":"visual","when":"視覚的な成果物が必要な時","output":"モックアップ、インフォグラフィック、図表","example":"WF体系の全体図をMermaidダイアグラムで視覚化"},
      {"name":"manual","when":"Gemini/Jules向けの手順書が必要な時","output":"補完防止の明確な手順書。曖昧さゼロの指示","example":"Jules用のリファクタリング指示書 — 各ステップを明示的に記述"}
    ],
    "usecases": [
      {"situation":"新しいSkillを作りたい","trigger":"繰り返し行う作業をSkillとして定型化したい時","action":"/mek で要件を整理 → Archetype選択 → SKILL.md生成 → /dia- でレビュー","result":"標準形式のSKILL.mdが生成され、即座に利用可能"},
      {"situation":"既存プロンプトの品質を評価したい","trigger":"「このプロンプトは本当に良いのか」と疑問がある時","action":"/mek diagnose [ファイル] で品質スコアリング実行。スコア80未満→自動改善","result":"客観的な品質スコアと具体的な改善提案が得られる"},
      {"situation":"CCLマクロを新規作成したい","trigger":"よく使うワークフローの組合せをCCLで簡潔に表現したい時","action":"/mek ccl \"意図\" でCCLを自動生成 → 複雑度ポイントを計算 → 60pt超なら分割","result":"適切な複雑度のCCL式が生成され、再利用可能になる"},
      {"situation":"チーム向けの作業マニュアルを作りたい","trigger":"AIに作業を依頼するための手順書が必要な時","action":"/mek --derivative=manual で補完防止の手順書を生成。曖昧さゼロ","result":"誰が読んでも同じ結果が得られる明確な手順書"}
    ],
    "algebra_detail": {"+":"/mek+: 全STEP(0-7)展開、設計根拠記載、Pre-Mortem、CCL複雑度計算を含む詳細生成","-":"/mek-: 最小構造のみ、即座に使える形で出力。装飾なし",
"*":"/mek*: 生成プロセス自体を問う。「この方法で生成すべきか」「別のアプローチの方が良いか」"}
  },
  "sta": {
    "desc": "現在の状態を正確に把握するツール。理想との距離（ギャップ）を定量化し、偏差の原因を分析する。/met が青写真なら、/sta は現地調査にあたる。「今どこにいるか」を客観的に知る。",
    "phases": [
      {"id":"Ph1","name":"現状認識","detail":"感覚的な把握ではなく、エビデンス（ファイル内容、テスト結果、メトリクス）に基づいて現在の状態を記述する。"},
      {"id":"Ph2","name":"逸脱検出","detail":"基準値（/met で策定した基準やSLO）からの乖離を検出。偏差の大きさを数値化する。"},
      {"id":"Ph3","name":"原因仮説","detail":"逸脱の原因について仮説を立てる。/zetの問い生成と連携して、最も蓋然性の高い原因を推定。"},
      {"id":"Ph4","name":"是正提案","detail":"原因に対する具体的な改善策を提案する。即座に実行可能なもの(Quick Win)と根本対策を区別して提示。"}
    ],
    "derivatives": [
      {"name":"monitor","when":"定期的に状態を確認したい時","output":"ダッシュボード的な状態サマリー。正常/警告/異常の3段階判定","example":"毎日のビルド状態、テストカバレッジ、技術的負債の定点観測"},
      {"name":"diagnosis","when":"問題が発生して原因を突き止めたい時","output":"症状→原因仮説→検証計画のフロー","example":"「CIが30%遅くなった」→ dependency解決時間の増加が原因と特定"},
      {"name":"forensics","when":"過去の障害を事後分析したい時","output":"タイムライン+根本原因+再発防止策","example":"本番障害の振り返り: 何が起き→なぜ起き→どう防ぐか"}
    ],
    "usecases": [
      {"situation":"プロジェクトの健全性確認","trigger":"「このプロジェクトは順調か？」を客観的に判断したい時","action":"/sta で現状を数値化 → 基準値との比較 → ギャップの大きい項目を特定","result":"感覚ではなくデータに基づいた健全性評価が得られる"},
      {"situation":"バグの原因調査","trigger":"問題が発生したが原因がわからない時","action":"/sta --derivative=diagnosis で症状を記述 → 原因仮説を生成 → 検証計画を策定","result":"効率的な原因調査のロードマップが得られる"},
      {"situation":"障害の振り返り","trigger":"本番障害が収束した後、再発防止策を検討したい時","action":"/sta --derivative=forensics でタイムラインを再構成 → 根本原因を特定 → 再発防止策を設計","result":"同じ障害が二度と起きない仕組みが構築される"}
    ],
    "algebra_detail": {"+":"/sta+: 全軸でのギャップ分析+原因分析+是正提案を含む詳細調査","-":"/sta-: 主要メトリクスの現在値のみ。1分で完了する状態確認","*":"/sta*: 観測方法自体のメタ分析。「この計測方法で本当に状態がわかるか」"}
  },
  "pra": {
    "desc": "実践における価値実現の方法を選択するツール。「何をすべきか」(倫理的/効果的/効率的)を判断し、最適な実行方法を配置する。/ene が「やる」なら、/pra は「どうやるか」を考える。",
    "phases": [
      {"id":"Ph1","name":"価値同定","detail":"実現すべき価値を特定する。目標（/bouの出力）と現状（/staの出力）のギャップから何を実現すべきかを明確にする。"},
      {"id":"Ph2","name":"手段列挙","detail":"価値実現のための手段を複数列挙する。各手段のメリット/デメリット/コスト/リスクを比較表で整理。"},
      {"id":"Ph3","name":"方法選択","detail":"トレードオフを考慮して最適な手段を選択する。選択基準: 効果/コスト/リスク/学習価値のバランス。"},
      {"id":"Ph4","name":"実行配置","detail":"選択した手段を具体的な実行計画に落とす。/ene への入力となる形で、順序/担当/期限を設定。"}
    ],
    "derivatives": [
      {"name":"ethical","when":"倫理的な判断が必要な時。「すべきか/すべきでないか」","output":"倫理的評価+ステークホルダー影響分析+推奨アクション","example":"「ユーザーデータをどこまで収集するか」→ プライバシーと利便性のバランス判定"},
      {"name":"effective","when":"効果を最大化したい時。「最もインパクトのある方法は何か」","output":"効果予測+投資対効果(ROI)分析+推奨手段","example":"「テスト戦略をどうするか」→ コスト対リスクで最適なテスト範囲を選択"},
      {"name":"efficient","when":"効率を最大化したい時。「最小コストでどう達成するか」","output":"リソース最適化計画+ボトルネック特定+改善策","example":"「CI時間を半減させたい」→ 並列化+キャッシュ+不要テスト削除の優先順位"}
    ],
    "usecases": [
      {"situation":"実装方法の選択","trigger":"「どの方法で実装するか」で選択肢が複数ある時","action":"/pra で各方法のメリット/デメリット/コスト/リスクを比較 → 基準に従い選択","result":"根拠のある技術選択ができ、後から「なぜこの方法にしたか」を説明できる"},
      {"situation":"リソース配分の最適化","trigger":"限られた時間/人員で最大の成果を出したい時","action":"/pra --derivative=efficient でボトルネックを特定 → リソース再配分 → 実行計画を/eneに渡す","result":"無駄が排除され、重要な作業にリソースが集中する"},
      {"situation":"トレードオフの判断","trigger":"「速度vs品質」「機能vsシンプルさ」など対立する価値がある時","action":"/pra で両方の価値を定量化 → トレードオフ曲線を描く → 最適点を選択","result":"感覚ではなくデータに基づいたトレードオフ判断ができる"}
    ],
    "algebra_detail": {"+":"/pra+: 全手段の詳細比較+トレードオフ分析+実行計画を含む詳細配置","-":"/pra-: 最も効率的な1手段のみ即座に選択",
"*":"/pra*: 意思決定プロセス自体のメタ分析。「この選択基準は適切か」"}
  },
  "pro": {
    "desc": "最初の直感・第一印象を捉えるツール。分析の前に「まず何を感じたか」を記録する。この初期反応は後の詳細分析で見失われやすいため、先に固定する。感情的な反応ではなく認知的シグナルとして扱う。",
    "phases": [
      {"id":"Ph1","name":"初期反応の捕捉","detail":"対象に触れた瞬間の反応を言語化する。「何が気になったか」「どこに違和感があるか」「何が魅力的か」を3つ以上列挙。分析せず、感じたままを記録する。"},
      {"id":"Ph2","name":"反応の分類","detail":"捕捉した反応を3軸で分類: (1)方向性（接近/回避）(2)強度（強/中/弱）(3)確信度（確信/推定/仮説）。数値化して比較可能にする。"},
      {"id":"Ph3","name":"シグナル抽出","detail":"反応の中から認知的シグナル（構造的違和感、パターン認識、美的判断）を抽出。社交的情緒（「すごい」「大変」）は除外し、情報として有用な反応だけを残す。"}
    ],
    "derivatives": [
      {"name":"quick","when":"素早く第一印象を記録したい時","output":"3つの反応ポイント + 方向性(接近/回避) + 強度(1-10)","example":"新しいPRを見た瞬間の「ここが気になる」を3つ記録"},
      {"name":"deep","when":"直感を丁寧に掘り下げたい時","output":"反応の根拠分析 + 過去の類似経験との比較 + 構造的違和感の特定","example":"「なぜこのコードに違和感があるか」を構造的に分析"},
      {"name":"contrast","when":"複数の選択肢への反応を比較したい時","output":"各選択肢への反応の比較表 + 差分から見える判断基準","example":"3つのデザイン案への第一印象を比較 → 無意識の選好基準を発見"}
    ],
    "usecases": [
      {"situation":"レビュー開始時","trigger":"コードやドキュメントのレビューを始める前","action":"/pro- で第一印象を3つ記録 → その後 /dia で詳細レビュー","result":"詳細分析で見失いがちな「最初の違和感」が保存される"},
      {"situation":"新しいアイデアに触れた時","trigger":"提案や新技術に最初に触れた瞬間","action":"/pro で初期反応を固定 → 後の分析と比較","result":"分析バイアスに汚染されない「素の反応」が残る"},
      {"situation":"意思決定の前","trigger":"重要な判断をする前に直感を確認したい時","action":"/pro でまず直感を記録 → /noe で分析 → 直感と分析の一致/乖離を確認","result":"直感と分析が矛盾する場合、その矛盾自体が重要な情報になる"}
    ],
    "algebra_detail": {"+":"/pro+: 反応の根拠分析+過去経験との比較+構造的違和感の特定を含む詳細な直感分析","-":"/pro-: 3つの反応ポイントだけを即座に記録。30秒で完了","*":"/pro*: 直感の信頼性のメタ分析。「この直感はバイアスか認知的シグナルか」"}
  },
  "pis": {
    "desc": "確信度・信頼性を評価するツール。「どれくらい確かか」を正確に測る。過信（確信度 > 実際の正確性）と過小評価（確信度 < 実際の正確性）の両方を検出し、キャリブレーションを行う。",
    "phases": [
      {"id":"Ph1","name":"確信度測定","detail":"各主張に対して確信度(0-100%)を付与。根拠を1つ以上添える。根拠なき確信は「過信」として警告する。"},
      {"id":"Ph2","name":"エビデンス評価","detail":"根拠の質を評価する。直接観察(SOURCE) vs 間接情報(TAINT)を区別。BC-6のTAINT/SOURCE追跡と連携。"},
      {"id":"Ph3","name":"キャリブレーション","detail":"過去の判断の的中率と照合し、確信度の精度を評価する。「90%確信と言った判断のうち、実際に正しかったのは何%か」を検証。"},
      {"id":"Ph4","name":"不確実性マッピング","detail":"「わかっていること」「わかっていないこと」「わかっていないことすら知らないこと」を区別し、リスクマップを作成。"}
    ],
    "derivatives": [
      {"name":"calibrate","when":"自分の確信度が正確かどうか検証したい時","output":"過去判断の的中率+キャリブレーション曲線+改善提案","example":"「90%確信の判断が実際には60%しか当たっていない」→ 過信傾向を検出"},
      {"name":"evidence","when":"主張の根拠を体系的に評価したい時","output":"エビデンスの質と量の評価+TAINT/SOURCE分類+信頼度スコア","example":"設計判断の根拠を整理: 「テスト結果(SOURCE)」vs「経験則(TAINT)」を区別"},
      {"name":"uncertainty","when":"不確実性を可視化したい時","output":"Known/Unknown/Unknown-UnknownのマッピングTable+リスク評価","example":"新技術採用時: 「確実に動く部分」「不明な部分」「気づいていないリスク」を分類"}
    ],
    "usecases": [
      {"situation":"重要な判断の前","trigger":"取り返しのつかない判断をする前に確信度を確認したい","action":"/pis で確信度を測定 → エビデンスを評価 → 不確実な部分を特定 → リスクに応じた対策","result":"過信による失敗を防ぎ、不確実な部分に適切な安全策を講じられる"},
      {"situation":"情報源の信頼性評価","trigger":"複数の情報源があり、どれを信頼すべきか判断したい時","action":"/pis --derivative=evidence で各情報源をSOURCE/TAINTで分類 → 信頼度スコアを算出","result":"信頼できる情報とそうでない情報が明確に区別される"},
      {"situation":"過信の傾向を自覚したい","trigger":"「いつも自信満々に間違える」パターンを改善したい時","action":"/pis --derivative=calibrate で過去の判断を振り返り → キャリブレーション曲線を作成","result":"自分の確信度の癖がわかり、適切な自信レベルに調整できる"}
    ],
    "algebra_detail": {"+":"/pis+: 全フェーズ実行+キャリブレーション+不確実性マッピングを含む詳細な確信度分析","-":"/pis-: 主要主張の確信度ラベル(確信/推定/仮説)のみ。即座に完了","*":"/pis*: 確信度評価方法自体のメタ分析。「この評価方法は信頼できるか」"}
  },
  "ore": {
    "desc": "欲求・価値傾向を評価するツール。「何に引かれているか」「何を避けているか」を可視化する。動機の構造を分析し、表面的な欲求の下にある深層的な価値観を発見する。",
    "phases": [
      {"id":"Ph1","name":"欲求の捕捉","detail":"現在の欲求・価値傾向を全て列挙する。「やりたいこと」「避けたいこと」「気になること」を分類して記録。"},
      {"id":"Ph2","name":"価値マッピング","detail":"各欲求の背後にある価値観を特定する。「なぜそれを望むのか」を3層で掘り下げ、根源的な価値に到達する。"},
      {"id":"Ph3","name":"傾向分析","detail":"欲求のパターンを分析する。接近傾向(〜がほしい)と回避傾向(〜を避けたい)のバランス、短期vs長期の比率を可視化。"}
    ],
    "derivatives": [
      {"name":"attract","when":"何に引かれているかを分析したい時","output":"接近傾向のリスト+各傾向の強度+根源的価値観","example":"「新しい技術に飛びつく傾向」→ 根源: 知的好奇心+承認欲求"},
      {"name":"avoid","when":"何を避けているかを分析したい時","output":"回避傾向のリスト+各傾向の原因+リスク評価","example":"「テスト記述を後回しにする傾向」→ 根源: 即時報酬の欠如+失敗への恐れ"},
      {"name":"balance","when":"欲求のバランスを評価したい時","output":"接近/回避のバランス分析+偏りの特定+調整提案","example":"「探索(新技術)に偏りすぎ。深化(既存技術の熟達)が不足」→ バランス調整"}
    ],
    "usecases": [
      {"situation":"モチベーションの低下","trigger":"「やる気が出ない」「何をしたいかわからない」時","action":"/ore で現在の欲求を可視化 → 本当にやりたいことを特定 → /bou で意志化","result":"表面的な無気力の下にある本当の欲求が発見される"},
      {"situation":"優先順位の混乱","trigger":"やりたいことが多すぎて整理できない時","action":"/ore で全欲求を列挙 → 価値マッピングで重複を発見 → 統合して整理","result":"見かけ上多い欲求が実は少数の価値観から派生していたことがわかる"},
      {"situation":"習慣的な回避の克服","trigger":"特定の作業を常に後回しにしてしまう時","action":"/ore --derivative=avoid で回避傾向の根源を分析 → /bou akra で意志-行為乖離を克服","result":"回避の原因が特定され、環境設計で克服できる"}
    ],
    "algebra_detail": {"+":"/ore+: 欲求の全リスト+3層価値分析+傾向パターン分析を含む詳細評価","-":"/ore-: 最も強い欲求3つとその方向(接近/回避)のみ","*":"/ore*: 欲求分析方法自体のメタ分析。「この分析で本当の欲求が見えるか」"}
  },
  "dox": {
    "desc": "信念を記録・永続化するツール。セッション中に得た洞察、判断、学びを外部ファイルに保存する。人間のメモに相当し、「忘れないようにする」ための仕組み。Knowledge Item(KI)やHandoffと連携する。",
    "phases": [
      {"id":"Ph1","name":"信念の特定","detail":"セッション中に形成された信念（確信/推定/仮説）を列挙する。暗黙的に形成された判断も含めて可視化する。"},
      {"id":"Ph2","name":"記録形式の選択","detail":"信念の性質に応じた記録先を選択: KI(恒久的知識)、Handoff(セッション間引き継ぎ)、ROM(セッション内記録)、patterns.yaml(行動パターン)。"},
      {"id":"Ph3","name":"永続化","detail":"選択した形式でファイルに書き出す。確信度ラベル(BC-6)とTAINT/SOURCE追跡を付与。後から検証可能な形式で記録する。"}
    ],
    "derivatives": [
      {"name":"capture","when":"セッション中に得た知見を即座に保存したい時","output":"KIファイルまたはHandoffへの記録。確信度ラベル付き","example":"「この設計パターンは有効」(確信:80%, SOURCE: テスト成功) → KI保存"},
      {"name":"review","when":"過去の信念を振り返りたい時","output":"保存済み信念のリスト+現在の評価(依然有効/要修正/無効化)","example":"1ヶ月前の設計判断を振り返り: 3つは有効、1つは前提が変わり無効化"},
      {"name":"prune","when":"古い信念を整理したい時","output":"整理結果: 保持/更新/削除の分類+理由","example":"KIの棚卸し: 20件中5件が古くなっており更新が必要"}
    ],
    "usecases": [
      {"situation":"セッション終了時の学び保存","trigger":"有用な洞察が得られたセッションの終了時","action":"/dox で信念を特定 → 適切な形式で保存 → /bye のHandoffに含める","result":"次回セッションで同じ洞察を再発見する無駄がなくなる"},
      {"situation":"判断の根拠を記録","trigger":"重要な設計判断をした時、後から「なぜそうしたか」を追跡したい","action":"/dox --derivative=capture で判断+根拠+確信度を記録","result":"後からADR(Architecture Decision Record)として参照できる"},
      {"situation":"知識ベースの棚卸し","trigger":"KIやHandoffが増えてきて整理が必要な時","action":"/dox --derivative=prune で全信念を振り返り → 有効/更新/削除に分類 → 実行","result":"知識ベースが最新の状態に保たれ、古い情報による誤判断を防ぐ"}
    ],
    "algebra_detail": {"+":"/dox+: 全信念の特定+記録形式選択+永続化+関連信念との整合性検証を含む詳細記録","-":"/dox-: 最も重要な1-2個の信念のみ即座に保存","*":"/dox*: 信念記録プロセス自体のメタ分析。「何を記録すべきで何を忘れるべきか」"}
  }
}

with open('/home/makaron8426/oikos/hegemonikon/docs/wf-data.js', 'r') as f:
    content = f.read()

m = re.search(r'const WF_DATA = ({.*?});\s*\n', content, re.DOTALL)
wf_obj = json.loads(m.group(1))

for cmd, rich in RICH_DATA.items():
    if cmd not in wf_obj:
        print(f"SKIP: {cmd}")
        continue
    wf_obj[cmd]['desc'] = rich['desc']
    wf_obj[cmd]['phases'] = rich['phases']
    wf_obj[cmd]['derivatives'] = rich['derivatives']
    wf_obj[cmd]['usecases'] = rich['usecases']
    if 'algebra_detail' in rich:
        wf_obj[cmd]['algebra'] = rich['algebra_detail']

new_wf = json.dumps(wf_obj, ensure_ascii=False, indent=1)
content = content[:m.start(1)] + new_wf + content[m.end(1):]

with open('/home/makaron8426/oikos/hegemonikon/docs/wf-data.js', 'w') as f:
    f.write(content)

for cmd in RICH_DATA:
    d = wf_obj[cmd]
    print(f"  /{cmd}: {len(d.get('phases',[]))}ph {len(d.get('derivatives',[]))}der {len(d.get('usecases',[]))}uc")
print("S+H series enrichment complete!")
