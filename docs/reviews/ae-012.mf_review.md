# è¦–è¦šãƒªã‚ºãƒ ã®æŒ‡æ®è€… ãƒ¬ãƒ“ãƒ¥ãƒ¼

## å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«
`mekhane/mcp/sympatheia_mcp_server.py`

## åˆ¤å®š
ç™ºè¨€ï¼ˆè¦æ”¹å–„ï¼‰

## ç™ºè¦‹äº‹é …
- **(Medium) é–¢æ•°ã‚µã‚¤ã‚ºã®ä¸å‡ä¸€**: `call_tool` é–¢æ•°ï¼ˆ145è¡Œï¼‰ãŒä»–é–¢æ•°ï¼ˆå¹³å‡10-30è¡Œï¼‰ã¨æ¯”è¼ƒã—ã¦æ¥µç«¯ã«å·¨å¤§ã§ã‚ã‚Šã€è¦–è¦šçš„ãªãƒªã‚ºãƒ ã‚’ç ´å£Šã—ã¦ã„ã¾ã™ã€‚
- **(Low) è¦–è¦šçš„ãªé‡å¿ƒã®åã‚Š**: `call_tool` å†…ã® `try` > `if/elif` > ãƒ­ã‚¸ãƒƒã‚¯ ã¨ã„ã†ãƒã‚¹ãƒˆæ§‹é€ ã«ã‚ˆã‚Šã€ã‚³ãƒ¼ãƒ‰ã®é‡å¿ƒãŒå³å´ã«åã‚Šã™ãã¦ã„ã¾ã™ã€‚
- **(Low) å¯†åº¦ã®åã‚Š**: å„ãƒ„ãƒ¼ãƒ«ã”ã¨ã®å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯ãŒé€£ç¶šã—ã¦ãŠã‚Šã€è¦–è¦šçš„ãªã€Œä½™ç™½ã€ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚

## ä¿®æ­£ã‚³ãƒ¼ãƒ‰ææ¡ˆ
`call_tool` å†…ã®å„å‡¦ç†ã‚’ç‹¬ç«‹ã—ãŸãƒãƒ³ãƒ‰ãƒ©é–¢æ•°ï¼ˆ`_handle_wbc`, `_handle_attractor` ç­‰ï¼‰ã«æŠ½å‡ºã™ã‚‹ã“ã¨ã§ã€é–¢æ•°ã‚µã‚¤ã‚ºã‚’å‡ä¸€åŒ–ã—ã€ãƒã‚¹ãƒˆã‚’æµ…ãã™ã‚‹ã“ã¨ã‚’ææ¡ˆã—ã¾ã™ã€‚

```python
# ... (imports and setup)

# ============ Handlers ============

async def _handle_wbc(sym, arguments):
    """WBC è„…å¨åˆ†æãƒãƒ³ãƒ‰ãƒ©"""
    req = sym.WBCRequest(
        source=arguments.get("source", "claude"),
        severity=arguments.get("severity", "medium"),
        details=arguments.get("details", ""),
        files=arguments.get("files", []),
    )
    result = await sym.wbc_analyze(req)
    d = result.model_dump()

    lines = [
        "# ğŸ©¸ WBC è„…å¨åˆ†æçµæœ\n",
        f"- **Threat Score**: {d['threatScore']}/15",
        f"- **Level**: {d['level']}",
        f"- **Severity**: {d['severity']}",
        f"- **Source**: {d['source']}",
        f"- **Should Escalate**: {'ğŸš¨ YES' if d['shouldEscalate'] else 'No'}",
        f"- **Recent Alerts (1h)**: {d['recentAlertCount']}",
        f"- **Details**: {d['details']}",
        f"- **Files**: {', '.join(d['files']) or 'N/A'}",
    ]
    return "\n".join(lines)


async def _handle_attractor(sym, arguments):
    """Attractor å®šç†æ¨è–¦ãƒãƒ³ãƒ‰ãƒ©"""
    context = arguments.get("context", "")
    req = sym.AttractorRequest(context=context)
    result = await sym.attractor_dispatch(req)
    d = result.model_dump()

    if d["recommendation"]:
        r = d["recommendation"]
        lines = [
            "# âš¡ Attractor å®šç†æ¨è–¦\n",
            f"- **Theorem**: {r['theorem']} ({r['name']})",
            f"- **Series**: {r['series']}",
            f"- **Command**: `{r['command']}`",
            f"- **Confidence**: {r['confidence']:.1%}",
            f"- **Auto-dispatch**: {'Yes' if d['autoDispatch'] else 'No'}",
            f"\n> Input: {d['context']}",
        ]
    else:
        lines = [
            "# âš¡ Attractor å®šç†æ¨è–¦\n",
            "å¼•åŠ›åœå¤–ã€‚å®šç†ãƒ¬ãƒ™ãƒ«ã§åæŸã—ã¾ã›ã‚“ã€‚",
            f"\n> Input: {d['context']}",
        ]
    return "\n".join(lines)


# ... (Other handlers: _handle_digest, _handle_feedback, _handle_status) ...


@server.call_tool(validate_input=True)
async def call_tool(name: str, arguments: dict):
    """ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œï¼ˆãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ£ï¼‰ã€‚"""
    log(f"call_tool: {name}")
    sym = _get_sympatheia()
    if sym is None:
        return [TextContent(type="text", text="Error: Sympatheia module not available")]

    try:
        if name == "sympatheia_wbc":
            text = await _handle_wbc(sym, arguments)
        elif name == "sympatheia_attractor":
            text = await _handle_attractor(sym, arguments)
        elif name == "sympatheia_digest":
            text = await _handle_digest(sym, arguments)
        elif name == "sympatheia_feedback":
            text = await _handle_feedback(sym, arguments)
        elif name == "sympatheia_status":
            text = _handle_status(sym, arguments) # Sync or async depending on implementation
        else:
            text = f"Unknown tool: {name}"

        return [TextContent(type="text", text=text)]

    except Exception as e:
        log(f"Error in {name}: {e}")
        import traceback
        traceback.print_exc(file=sys.stderr)
        return [TextContent(type="text", text=f"Error: {e}")]
```

## é‡å¤§åº¦
Medium
