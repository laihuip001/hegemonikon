# ネスト深度警報者 レビュー

## 対象ファイル
`mekhane/dendron/checker.py`

## 判定
発言（要改善）

## 発見事項
- **High**: `check` メソッド内のネストが **6段** に達しています (if self.check_files -> for path -> if is_file -> if check_funcs -> try -> if check_funcs)。
- **High**: `_check_functions_from_tree` メソッド内のネストが **5段** に達しています (for node -> if isinstance -> while scan -> if startswith -> if match)。
- **High**: `_check_variables_from_tree` メソッド内のネストが **5段** に達しています (for node -> if isinstance -> for target -> if isinstance -> if not in)。
- **High**: `check_file_proof` メソッド内のネストが **4段** に達しています (for line -> if match -> if parent -> if not valid)。

## 重大度
High

## 修正提案

### 1. `check` メソッドの平坦化 (抽出メソッド化)

ファイルごとの処理を `_process_file` メソッドに抽出することで、ループと条件分岐のネストを解消できます。

```python
    def check(self, root: Path) -> CheckResult:
        # ... (省略) ...
        # ファイルをチェック
        if self.check_files:
            for path in root.rglob("*.py"):
                if path.is_file():
                    self._process_file(path, file_proofs, function_proofs, variable_proofs)
        # ... (省略) ...

    def _process_file(self, path: Path, file_proofs: list, function_proofs: list, variable_proofs: list):
        """単一ファイルのチェック処理 (ネスト解消用)"""
        file_proofs.append(self.check_file_proof(path))

        if (self.check_functions or self.check_variables) and not self.is_exempt(path):
            try:
                content = path.read_text(encoding="utf-8")
                tree = ast.parse(content, filename=str(path))
            except (SyntaxError, UnicodeDecodeError):
                return

            if self.check_functions:
                function_proofs.extend(self._check_functions_from_tree(path, tree, content))
            if self.check_variables:
                variable_proofs.extend(self._check_variables_from_tree(path, tree))
```

### 2. `_check_functions_from_tree` のロジック抽出

Purposeコメント検索ロジックを別メソッド `_find_purpose_comment` に抽出することを推奨します。

```python
    def _find_purpose_comment(self, lines: List[str], start_line: int) -> Optional[str]:
        """指定行から遡って Purpose コメントを検索"""
        scan_idx = start_line - 2
        while scan_idx >= 0 and scan_idx >= start_line - 10:
            line = lines[scan_idx].strip()
            if not line:
                scan_idx -= 1
                continue

            if line.startswith("#"):
                match = PURPOSE_PATTERN.search(line)
                if match:
                    return match.group(1).strip()
                scan_idx -= 1
            else:
                break
        return None
```

### 3. `_check_variables_from_tree` の分割

`ast.FunctionDef` の処理と `ast.Assign` の処理をそれぞれ別のメソッド (`_check_function_node`, `_check_assign_node`) に分けることで、ループ内のネストを浅くできます。

```python
    def _check_variables_from_tree(self, path: Path, tree: ast.Module) -> List[VariableProof]:
        results = []
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                results.extend(self._check_function_node(node, path))
            elif isinstance(node, ast.Assign):
                results.extend(self._check_assign_node(node, path))
        return results
```
