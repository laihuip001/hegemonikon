# 予測誤差審問官 レビュー

## 対象ファイル
`hermeneus/src/dispatch.py`

## 判定
発言（要改善）

## 発見事項
- **Side Effect (High)**: モジュールトップレベルでの `sys.path.insert(0, ...)` は、このモジュールをインポートするだけでグローバルな `sys.path` を変更します。これは予測困難な副作用です。
- **Unpredictable Return Type (Medium)**: `dispatch` 関数の戻り値が `dict` であり、その構造（キーと値の型）が型ヒントから不明です。呼び出し元は何が含まれているかを知るために実装を読む必要があります。`TypedDict` や `dataclass` を使用すべきです。
- **Unpredictable Argument Type (Medium)**: `format_ast_tree` や `extract_workflows` の引数 `node` に型ヒントがなく、どのようなオブジェクトが期待されるか不明です。
- **Hidden Dependencies (Low)**: 関数内で `import` を行っています（`format_ast_tree`, `extract_workflows`, `dispatch`）。これは依存関係を隠蔽し、実行時までインポートエラーが判明しない可能性があります。
- **Hidden Exceptions (Low)**: `dispatch` 関数は `Exception` を捕捉して辞書内の `error` フィールドとして返しますが、これは例外処理の責任を呼び出し元に委譲する形になり、型シグネチャからは成功か失敗かが直感的に分かりません。

## 提案コード（抜粋）

```python
# 改善案: 戻り値の型定義とトップレベル副作用の排除

from dataclasses import dataclass
from typing import Optional, List, Union, TYPE_CHECKING
from pathlib import Path

# 必要に応じて TYPE_CHECKING ブロック内で AST ノードをインポート
if TYPE_CHECKING:
    from hermeneus.src.ast import ASTNode

@dataclass
class DispatchResult:
    """dispatch 関数の戻り値型"""
    success: bool
    ccl: str
    tree: str
    workflows: List[str]
    plan_template: str
    ast: Optional['ASTNode'] = None
    error: Optional[str] = None

def dispatch(ccl_expr: str) -> DispatchResult:
    # ... 実装 (内部ロジックは変更なし、戻り値を DispatchResult に変更) ...
    pass

if __name__ == "__main__":
    import sys
    # sys.path 操作は __main__ ブロック内、または専用の entry point スクリプトに限定する
    sys.path.insert(0, str(Path(__file__).parent.parent.parent))
    # main() の呼び出し
```

## 重大度
High
