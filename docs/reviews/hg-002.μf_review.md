# 予測誤差審問官 レビュー

## 対象ファイル
`mekhane/anamnesis/gnosis_chat.py`

## 判定
発言（要改善）

## 発見事項

- **[High] 副作用非明示: `Reranker.rerank` のインプレース変更**
  - `Reranker.rerank` は引数として渡された `results` リストを直接変更（`_rerank_score` の追加、ソート）しています。関数名は `rerank` であり、新しいリストを返すような印象を与えますが、実際には入力オブジェクトを破壊的に変更しており、呼び出し元にとって予測困難な副作用です。

- **[High] 例外の隠蔽: `GnosisChat._retrieve`**
  - `_retrieve` メソッド内で `try ... except Exception: pass` が多用されており、データベース接続エラーや検索エラーが完全に握りつぶされています。呼び出し元は「検索結果が0件だった」のか「エラーで失敗した」のかを区別できず、システムの振る舞いが予測不能になります。

- **[Medium] 戻り値の型が予測困難: `dict` の多用**
  - `GnosisChat.ask` や `KnowledgeIndexer.discover_knowledge_files` の戻り値が `dict` や `list[dict]` となっています。辞書のキー構成（`answer`, `sources`, `retrieval_time` 等）がシグネチャからは読み取れず、コード内部を読まないと利用できません。`TypedDict` や `dataclass` を使用すべきです。

- **[Medium] 暗黙の状態変更（遅延ロード）**
  - `_retrieve` や `_generate` の内部で `_load_index()` や `_load_model()` が呼ばれています。メソッド名からは単なる検索や生成に見えますが、初回呼び出し時のみ数GBのモデルロードという重い副作用（時間的・メモリ的）が発生します。これは「驚き」の要因です。明示的な初期化メソッドを推奨します。

## 重大度
High

## 修正提案

```python
from dataclasses import dataclass
from typing import List, TypedDict

# 1. 戻り値の型定義
class SourceItem(TypedDict):
    title: str
    source: str
    table: str
    url: str
    relevance: float

@dataclass
class ChatResult:
    answer: str
    sources: List[SourceItem]
    retrieval_time: float
    generation_time: float
    context_docs: int
    turn: int

# 2. Reranker の修正 (新しいリストを返す)
class Reranker:
    def rerank(self, query: str, results: list[dict], top_k: int = 5) -> list[dict]:
        # 入力をコピーして変更 (予測誤差を減らす)
        ranked_results = [r.copy() for r in results]

        # ... logic ...
        # スコアを結果に付与
        for r, score in zip(ranked_results, scores):
            r["_rerank_score"] = float(score)

        # re-rank score でソート
        ranked_results.sort(key=lambda r: r.get("_rerank_score", -999), reverse=True)
        return ranked_results[:top_k]

# 3. 例外処理の改善 (予測可能な失敗)
class GnosisChat:
    def _retrieve(self, query: str) -> list[dict]:
        self._load_index()
        results = []

        # 明示的なエラーハンドリング
        # 特定の例外のみをキャッチする、もしくは呼び出し元に任せる
        if self.search_papers:
            # 予測可能な例外設計: IndexNotLoadedError 等
            paper_results = self._index.search(query, k=fetch_k)
            # ...
```
