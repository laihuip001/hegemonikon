# CCL式美学者 レビュー

## 対象ファイル
`mekhane/dendron/checker.py`

## 判定
発言（要改善）

## 発見事項

### 1. `_check_functions_from_tree` (Medium)
- **CCLスコア**: ~75pt (60pt超過)
- **ネストレベル**: 5 (推奨3以下)
- **問題点**: ASTノードのループ内で、行単位のコメント走査（whileループ）と正規表現マッチングが直接記述されており、認知的負荷が高い。
- **修正提案**: コメント探索ロジックを独立した関数に抽出する。

```python
def _find_purpose_comment(self, lines: List[str], start_line: int) -> Optional[str]:
    """指定行から遡って Purpose コメントを探索"""
    scan_idx = start_line - 2
    limit = max(0, start_line - 12)  # 10行制限

    while scan_idx >= 0 and scan_idx >= limit:
        line = lines[scan_idx].strip()
        if not line:
            scan_idx -= 1
            continue

        if line.startswith("#"):
            match = PURPOSE_PATTERN.search(line)
            if match:
                return match.group(1).strip()
            scan_idx -= 1
        else:
            break
    return None
```

### 2. `_check_variables_from_tree` (Medium)
- **CCLスコア**: ~65pt (60pt超過)
- **ネストレベル**: 5 (推奨3以下)
- **問題点**: 単一のループ内で `FunctionDef`（引数・戻り値チェック）と `Assign`（変数名チェック）の処理が混在しており、条件分岐が深い。
- **修正提案**: ノードタイプごとの処理を分離する。

```python
def _check_variables_from_tree(self, path: Path, tree: ast.Module) -> List[VariableProof]:
    results = []
    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            results.extend(self._check_function_signature(path, node))
        elif isinstance(node, ast.Assign):
            results.extend(self._check_assignment(path, node))
    return results
```

### 3. `check` (Medium)
- **CCLスコア**: ~62pt
- **ネストレベル**: 5
- **問題点**: ディレクトリ走査、ファイルフィルタリング、各チェッカーの呼び出し条件が深くネストしている。
- **修正提案**: ファイル単位の処理を `_process_single_file` メソッドに切り出し、フラットな構造にする。

## 重大度
Medium
