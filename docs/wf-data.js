// Hegemonikón WF Data - Auto-generated
// Generated from 24 theorem WFs + 7 tau WFs + 15 CCL macros

const WF_DATA = {
 "noe": {
  "name": "noe",
  "jp": "O1 Noēsis（深い認識・直観）を発動する最深層思考ワークフロー。7フェーズ (0-6) で圏論的普遍性を追求。",
  "series": "O",
  "pos": "T1",
  "ver": "6.1",
  "desc": "「本質は何か？」を問う最深層の思考ツール。表面的な理解を拒否し、暗黙の前提を掘り起こして、余分も不足もない普遍的な解（Kalon）を発見する。設計の根本を見直したい時、パラダイム転換が必要な時に使う。",
  "adj": {
   "pair": "noē",
   "role": "G",
   "label": "{'notation': 'F ⊣ G — 圏論を付与する (F) と 構造を発見する (G) の随伴対', 'unit': 'η: Id → GF = Phase 3 (Kalon) — 付与→発見→元の問いと比較', 'counit': 'ε: FG → Id = Phase 5 (Dokimasia) — 発見→付与→元に戻す', 'noe_zet_pair': {'adjunction': 'Noēsis (F) ⊣ Zētēsis (G)', 'F_role': 'F: Question → Insight（問いから確実性を構成する = precision ↑）', 'G_role': 'G: Insight → Question（認識から自信を忘却し問いだけを残す = precision ↓）', 'drift': 'Drift = unknown unknowns — 問えない問い。疑うべきかすら気づけない前提', 'insight': '自信 = 既知への重み付け(precision)を捨てることで問いが生まれる — Creator, 2026-02-10'}}",
   "meaning": "",
   "f_def": "",
   "g_def": ""
  },
  "phases": [
   {
    "id": "STEP 0",
    "name": "SKILL.md読込",
    "detail": "ワークフローの正本（設計書）をファイルから読み込む。省略すると劣化出力になるため環境が強制する。view_file コマンドで実際にファイルを開く。"
   },
   {
    "id": "STEP 0.5",
    "name": "Gnōsis検索",
    "detail": "27,000件の論文知識ベースから、関連する学術知見を事前取得する。「自分の記憶だけで考える」ことを防ぎ、エビデンスに基づく思考を保証する。"
   },
   {
    "id": "Ph0",
    "name": "Prolegomena（前限定）",
    "detail": "「何について考えるか」の範囲を決める。分析対象の圏（カテゴリ）を特定し、議論の土俵を定義する。ここを間違えると全フェーズが無駄になる。"
   },
   {
    "id": "Ph1",
    "name": "Excavation（前提の掘り起こし）",
    "detail": "「当然だと思っていること」を全て列挙する。暗黙の仮定、無意識の前提、疑われていない常識を表面化させる。このフェーズが/noeの核心。"
   },
   {
    "id": "Ph2",
    "name": "Genesis（仮説生成）",
    "detail": "複数の視点から仮説を構成する。Analogy(生物からの連想)、10x(目標10倍化)、Gap(未成熟なたたき台)、Art(芸術からの示唆)など6つの発想モードを使い、多角的に候補解を生成する。"
   },
   {
    "id": "Ph3",
    "name": "Kalon（普遍性検証）",
    "detail": "/noe+ (L3) のみ実行。候補解同士を比較し「AはBの特殊ケースか？」をLLMに判定させる。最も多くの候補を包含する普遍的な解を特定し、Kalonスコア(0-1)で美しさを数値化する。"
   },
   {
    "id": "Ph4",
    "name": "Synthesis（射の合成）",
    "detail": "/noe+ (L3) のみ実行。複数の洞察を統合し、経路を辿って整合性を確認する。個別の発見がシステム全体で矛盾しないかを検証する。"
   },
   {
    "id": "Ph5",
    "name": "Dokimasia（忠実性テスト）",
    "detail": "結論が元の問題に忠実かを検証する。「抽象化しすぎて元の問題と解離していないか」「具体的な指示に落とせるか」をチェックする。全レベルで必須。"
   },
   {
    "id": "Ph6",
    "name": "Theoria（Yoneda完全性）",
    "detail": "/noe+ (L3) のみ実行。結論の完全性を最終確認する。「考慮されていない射（関係性）はないか」「この結論で全ての観点がカバーされているか」を問う。"
   }
  ],
  "derivatives": [
   {
    "name": "nous",
    "when": "抽象的・原理的な問い。「なぜ〜か」「本質は何か」",
    "output": "普遍的な原理・法則。具体例から抽出された構造的パターン",
    "example": "「FEPとは何か」→ 予測誤差最小化という普遍原理を、生物/AI/組織の3文脈で導出"
   },
   {
    "name": "phro",
    "when": "具体的・文脈依存の判断。「この状況でどうすべきか」",
    "output": "状況に適応した実践的判断。条件付きの行動指針",
    "example": "「このPRをマージすべきか」→ リスク/テストカバレッジ/依存関係を考慮した判断"
   },
   {
    "name": "meta",
    "when": "自分の思考過程に疑問がある時。「なぜそう考えたか」",
    "output": "認識の認識。バイアスの検出、推論の跳躍の特定",
    "example": "「前回のセッションで間違えた原因は何か」→ 確証バイアスによるINPUT TAINTを検出"
   },
   {
    "name": "separate",
    "when": "複合的な問題が絡み合って解けない時",
    "output": "独立した部分問題のリスト。それぞれの解決順序",
    "example": "「アプリが遅い」→ DB/API/レンダリング/ネットワークの4問題に分離、DB優先で解決"
   },
   {
    "name": "align",
    "when": "複数の設計判断が矛盾している時",
    "output": "整合状態の定義と、矛盾解消の提案",
    "example": "「パフォーマンスとセキュリティが矛盾」→ 第3の選択肢を発見し両立させる"
   },
   {
    "name": "metalearning",
    "when": "学習方法自体を改善したい時",
    "output": "より効果的な学習戦略の設計",
    "example": "「なぜ新技術の習得が遅いか」→ 学習ループの構造的問題を特定し、戦略を再設計"
   },
   {
    "name": "scaffold",
    "when": "自由な発想だけでは収束しない時",
    "output": "骨格を固定→創発を許容→整流するPGH型フレームワーク",
    "example": "「ブレストの結果がまとまらない」→ 構造(骨格)を先に定義してから自由領域を設定"
   }
  ],
  "algebra": {
   "+": "/noe+（L3 Deep）: 全7フェーズを完全実行。Ph3 Kalon（普遍性検証）、Ph4 Synthesis（射の合成）、Ph6 Theoria（Yoneda完全性）を含む。各フェーズで標準の3倍の出力量。GoT分岐3つ以上。結果はファイルに保存必須",
   "-": "/noe-（L1 Quick）: 結論+理由1つのみ、5行以内。軽い確認や素早い判断に使う",
   "*": "/noe*（メタ分析）: 分析そのものの前提を問い直す。「なぜこの分析をしているのか」「分析の枠組み自体にバイアスはないか」を検証"
  },
  "usecases": [
   {
    "situation": "体系の根本設計を見直したい",
    "trigger": "「この構造は本当に正しいのか？」という疑問が生じた時",
    "action": "/noe+ で全ての暗黙の前提を掘り起こし、普遍性検証(Kalon)まで実行。根本からの再設計を行う",
    "result": "余分な仮定が除去され、より単純で美しい設計が得られる"
   },
   {
    "situation": "パラダイム転換が必要",
    "trigger": "既存のアプローチでは解決不可能な問題に直面した時",
    "action": "/noe で前提を全て疑い、Ph2の発想モード(Analogy/10x/Alien)で異質な視点を取り入れる",
    "result": "従来とは全く異なるアプローチが発見される"
   },
   {
    "situation": "複数の選択肢があり本質が見えない",
    "trigger": "「AとBどちらが良いか」ではなく「そもそもこの問いの立て方が正しいか」を問いたい時",
    "action": "/noe --derivative=meta で問いそのものを再検討。/noe --derivative=separate で問題を分離",
    "result": "真の問題が特定され、偽の二項対立から脱出できる"
   },
   {
    "situation": "外部レビューの指摘を根本的に理解したい",
    "trigger": "表面的な修正ではなく、構造的な欠陥の原因を追求したい時",
    "action": "/noe --derivative=nous でレビュー指摘の背後にある原理を抽出",
    "result": "個別の指摘ではなく、設計原則レベルの改善が得られる"
   },
   {
    "situation": "新しいフレームワークの本質を理解したい",
    "trigger": "ドキュメントを読んだだけでは「なぜそう設計されたか」がわからない時",
    "action": "/noe で設計の前提を掘り起こし、Ph3 Kalonで「このフレームワーク固有の普遍性」を特定",
    "result": "表面的な使い方ではなく、設計思想の深い理解が得られる"
   }
  ]
 },
 "bou": {
  "name": "bou",
  "jp": "O2 Boulēsis（意志・目的）を発動し、「何を望むか」を明確化するワークフロー。純粋な理想から実用的な目標へ。",
  "series": "O",
  "pos": "T2",
  "ver": "4.6",
  "desc": "「何を望むか？」を問う意志明確化ツール。まずClaudeが自分の望みをたたき台として提示し、Creatorの反応から対話的に真の望みを引き出す。純粋な理想（望み）から実用的な目標（行動計画）への変換を行う。",
  "adj": {
   "pair": "bou",
   "role": "F",
   "label": "Energeia (F) ⊣ Boulēsis (G)",
   "meaning": "G: Act → Will（行為から制約を忘却し、純粋な望みを抽出）",
   "f_def": "G: Act → Will（行為から制約を忘却し、純粋な望みを抽出）",
   "g_def": "制約（時間, コスト, 他者の期待）を剥いで、純粋な望みだけを残す"
  },
  "phases": [
   {
    "id": "STEP 0",
    "name": "SKILL.md読込",
    "detail": "ワークフローの正本を読み込む。省略不可。"
   },
   {
    "id": "Ph0",
    "name": "私の望み提示",
    "detail": "Claudeが現在の文脈から3-5個の望みをたたき台として提示する。単に「何がしたいですか？」と聞くのではなく、先に自分の望みを見せることで、Creatorの反応を引き出す。各望みに「なぜそれを望むか」と「Creatorにとっての価値（推測）」を添える。"
   },
   {
    "id": "Ph1-2",
    "name": "対話+深掘り",
    "detail": "Creatorの反応を受け、5 Whys（なぜを5回繰り返す）で望みの根源に到達する。さらに多面的な問い: 「達成後に何が変わるか」「ないと何が困るか」「誰のためか（自己/他者/社会）」で望みを多角的に照射する。"
   },
   {
    "id": "Ph3",
    "name": "衝動vs熟慮判定",
    "detail": "各望みに衝動スコア(0-100)を付与する。判定基準: (1)今だけか長期的か (2)1週間後も同じか (3)理性でも望むか感情だけか。高スコア=衝動的（慎重に扱う）、低スコア=熟慮された意志（信頼できる）。"
   },
   {
    "id": "Ph4",
    "name": "実現可能性評価",
    "detail": "リソース（時間/お金/スキル）と制約（障害）から実現可能性スコア(0-100)を算出。2×2マトリクスで分類: 高純粋×高実現→即実行、高純粋×低実現→長期目標、低純粋×高実現→再検討、低純粋×低実現→棄却候補。"
   },
   {
    "id": "Ph4.5",
    "name": "6W3H具体化",
    "detail": "「即実行」と判定された望みのみ実施。What/Why/Who/Whom/Where/When/How/How much/How many の9つの問いに具体的な値・名前で回答。曖昧な回答は許可しない。"
   },
   {
    "id": "Ph5",
    "name": "優先順位+行動計画",
    "detail": "全フェーズの結果を統合し最終優先順位を決定。最優先の望みに: 具体的次アクション + 期限 + 達成基準を設定。出力を /ene（実行WF）に渡す準備をする。"
   }
  ],
  "derivatives": [
   {
    "name": "desir",
    "when": "明確な葛藤がなく、素直に望みを探したい時",
    "output": "純粋な望みリスト + 各望みの純粋度(HIGH/MED/LOW) + 5 Whysの結果 + 優先順位",
    "example": "セッション開始時に「今日は何をやりたいか」→ 3つの望みを純粋度順に整理"
   },
   {
    "name": "voli",
    "when": "「AもやりたいしBもやりたい、でも両立できない」という複数欲動の競合時",
    "output": "Frankfurt階層分析: 第1次欲動（直接的欲求）と第2次欲動（欲求についての意志）を区別し、上位意志で統合",
    "example": "「新機能開発」vs「技術的負債返済」→ 共通根源は「プロダクトの長期的健全性」と特定し、両方を含む統合意志を構成"
   },
   {
    "name": "akra",
    "when": "「わかっているのにできない」「先延ばししている」という意志-行為の乖離時",
    "output": "乖離の原因分析 + 実装意図（「{状況}のとき{行動}する」形式） + 環境設計（障害除去+トリガー設置）",
    "example": "「テストを書くべきだが書かない」→ 原因:即座のフィードバックがない → 実装意図:「PR作成前にpytest実行」→ 環境:pre-commitフックに追加"
   }
  ],
  "algebra": {
   "+": "/bou+: 全フェーズ実行。5 Whys完全実行 + 6W3H具体化必須 + トレードオフ分析必須。詳細な意志の地図を作る",
   "-": "/bou-: 最優先1つのみ。端的に「今一番やりたいこと」を特定する。数分で完了",
   "*": "/bou*: 意志のメタ分析。「なぜそれを望むのか」「その望みは本当に自分のものか」を問う。Frankfurt的に欲求の欲求を分析"
  },
  "usecases": [
   {
    "situation": "セッション開始時の方向性設定",
    "trigger": "「今日は何をやるか」が明確でない時",
    "action": "/bou でClaudeが先に3-5個の望みを提示 → Creatorの反応で対話 → 最優先を決定",
    "result": "具体的な行動計画と優先順位が得られ、/ene で実行に移れる"
   },
   {
    "situation": "複数のやりたいことが競合",
    "trigger": "「AとBどちらを先にやるべきか」で決められない時",
    "action": "/bou --derivative=voli でFrankfurt階層分析 → 上位意志を特定 → 統合的解決策を構成",
    "result": "二者択一ではなく、両方の根源的な欲求を満たす統合的な方針が得られる"
   },
   {
    "situation": "先延ばしを克服したい",
    "trigger": "やるべきとわかっているのに手がつかない時",
    "action": "/bou --derivative=akra で乖離の原因を特定 → 実装意図を設計 → 環境を変えて障害を除去",
    "result": "意志力に頼らず、環境の力で自然に行動できる仕組みが構築される"
   },
   {
    "situation": "長期プロジェクトの方向性確認",
    "trigger": "「まだこの方向で良いのか？」と定期的に振り返りたい時",
    "action": "/bou で現在の望みを再評価 → 初期の望みとの差分を分析 → 方向修正 or 継続を判断",
    "result": "目的の漂流（Drift）を早期検出し、手段の目的化を防ぐ"
   }
  ]
 },
 "zet": {
  "name": "zet",
  "jp": "O3 Zētēsis（探求）を発動し、「何を問うべきか」を発見する。問いの種を見つける認知ツール。",
  "series": "O",
  "pos": "T3",
  "ver": "7.0",
  "desc": "「何を問うべきか？」を発見する探求ツール。答えを出すのではなく、正しい問いを見つける。違和感や摩擦点から問いの種を発見し、具体的で扱える形に変換する。/noe が答えを深掘りするなら、/zet は問いを発掘する。",
  "adj": {
   "pair": "",
   "role": "G",
   "label": "",
   "meaning": "",
   "f_def": "",
   "g_def": ""
  },
  "phases": [
   {
    "id": "STEP 0",
    "name": "SKILL.md読込",
    "detail": "ワークフローの正本を読み込む。省略不可。"
   },
   {
    "id": "Ph1(η)",
    "name": "問い生成（Unit）",
    "detail": "3つのソースから問いの種を見つける: (1)摩擦点 — うまくいっていないこと (2)成功の裏 — うまくいっているが理由不明なこと (3)前提の棚卸し — 疑われていない仮定。メタ問い（問いの問い）も含めて候補を列挙する。"
   },
   {
    "id": "Ph2(μ)",
    "name": "平坦化（Multiplication）",
    "detail": "メタ問い（抽象的な問い）を具体的で扱える問いに変換する。「なぜうまくいかないか」→「どのステップで失敗しているか」→「テストのステップ3で何が起きているか」のように、行動可能なレベルまで具体化する。"
   },
   {
    "id": "Ph3",
    "name": "問い候補の提示",
    "detail": "発見した問いをランク付けしてCreatorに提示する。各問いに「重要度」「緊急度」「答えが得られた場合のインパクト」を付与。Creatorが選択する。"
   },
   {
    "id": "Ph4",
    "name": "Kleisli Bind",
    "detail": "Creator が選んだ問いを次のWFに接続する。典型的には /noe で深掘り、または /sop で外部調査。問いが行動に変わる接続点。"
   }
  ],
  "derivatives": [
   {
    "name": "anom",
    "when": "「何かおかしい」という違和感はあるが言語化できない時",
    "output": "違和感の正体を具体的な問いに変換。異常の位置と性質を特定",
    "example": "「ビルドが最近遅い気がする」→ 「v2.3以降でCIの所要時間が40%増加。原因はdependency解決か？テストか？」"
   },
   {
    "name": "hypo",
    "when": "仮説を複数立てて比較したい時",
    "output": "「もし〜なら」のシナリオ群。各仮説の検証方法と予想結果",
    "example": "「ユーザー離脱の原因は何か」→ 3つの仮説(UI/パフォーマンス/機能不足)と各々の検証方法を並列生成"
   },
   {
    "name": "eval",
    "when": "生成した仮説の妥当性を検証したい時",
    "output": "各仮説の確信度スコアと根拠。最も蓋然性の高い仮説の特定",
    "example": "3つの仮説をエビデンスと照合 → パフォーマンスが最有力(確信度75%)と判定"
   },
   {
    "name": "abduction",
    "when": "観察結果から最も蓋然性の高い原因を推定したい時",
    "output": "最良説明の推論。「この結果を最もよく説明する原因は何か」",
    "example": "「テスト通過率が急落」→ abductionで「先週のDB移行が原因」と推定 → 検証計画を策定"
   }
  ],
  "algebra": {
   "+": "/zet+: 3つのソース(摩擦点/成功の裏/前提棚卸し)を全て実行。各問いに重要度/緊急度/インパクトのスコアを付与。最低5つの問い候補を生成",
   "-": "/zet-: 最も気になる1つの問いだけを即座に特定する。深い分析なし、直感ベース",
   "*": "/zet*: 問いの問い。「なぜこの問いを問おうとしているのか」「この問いの前提は何か」を分析。問い自体のバイアスを検出"
  },
  "usecases": [
   {
    "situation": "違和感があるが言語化できない",
    "trigger": "「何か引っかかる」「なんとなく不安」という感覚がある時",
    "action": "/zet --derivative=anom で違和感を具体的な問いに変換。摩擦点を3つ以上列挙し、各々を行動可能な問いに変換",
    "result": "曖昧な不安が「この具体的な問いに答えれば解決する」という明確な形になる"
   },
   {
    "situation": "設計前に問いを整理したい",
    "trigger": "新しい機能やプロジェクトを始める前に「本当に必要か」を確認したい時",
    "action": "/zet で前提の棚卸しを実行。「これは必要」と思い込んでいる仮定を全て列挙し、各々を問いに変換",
    "result": "不要な前提が発見され、より本質的な設計が可能になる"
   },
   {
    "situation": "デバッグの方向性を決めたい",
    "trigger": "バグの原因がわからず、どこから調べるべきか迷っている時",
    "action": "/zet --derivative=hypo で複数の仮説を立て → --derivative=eval で各仮説を評価 → 最有力を /noe で深掘り",
    "result": "最も蓋然性の高い原因が特定され、効率的なデバッグが可能になる"
   },
   {
    "situation": "新しいアイデアが浮かんだ",
    "trigger": "面白そうなアイデアだが、実現性や価値が不明な時",
    "action": "/zet で「このアイデアが解決する問題は何か」「既存の解決策と何が違うか」を問いとして構成",
    "result": "アイデアが検証可能な問いの形になり、/noe や /sop で評価できる状態になる"
   }
  ]
 },
 "ene": {
  "name": "ene",
  "jp": "O4 Energeia（行為）を発動し、意志を現実に具現化する。6段階実行フレームワーク。",
  "series": "O",
  "pos": "T4",
  "ver": "5.0",
  "desc": "計画を実行に移すツール。意志（/bou）で決めたことを実際にコードや文書として具現化する。リスク判定→実行→品質検証→偏差検知の4段階で、安全かつ確実に変更を行う。計画の承認後に「y」で暗黙発動する。",
  "adj": {
   "pair": "bou",
   "role": "F",
   "label": "Energeia (F) ⊣ Boulēsis (G)",
   "meaning": "F: Will → Act（純粋な望みに制約を載せて、行為計画を自由構成）",
   "f_def": "理想（願望）に現実制約を付与して、実行可能な目標を組み立てる",
   "g_def": ""
  },
  "phases": [
   {
    "id": "Ph0.1",
    "name": "Risk Tag（リスク判定）",
    "detail": "操作の破壊度を🟢低(読み取りのみ)/🟡中(可逆的変更)/🔴高(不可逆的変更)で判定する。🔴の場合はスナップショットを必ず取得してから実行する。"
   },
   {
    "id": "Ph0.2",
    "name": "Graduated Supervision（監督レベル）",
    "detail": "リスクに応じた監督方式を選択: Self(自己監査/🟢)、Premortem(事前失敗分析/🟡)、External(外部検証要求/🔴)。"
   },
   {
    "id": "Ph0.3",
    "name": "Graduated Enforcement（品質保証レベル）",
    "detail": "Anti-Skip(ステップ省略禁止)、Schema(出力形式の検証)、Guardrails(安全制約の適用)を選択。"
   },
   {
    "id": "Ph1",
    "name": "実行+Self-Audit",
    "detail": "計画に基づきファイルを変更する。各ファイルについて: (1)現在の内容を読み込み (2)変更を適用 (3)変更が意図通りかを自己監査。変更理由をコミットメッセージ形式で記録する。"
   },
   {
    "id": "Ph1.5",
    "name": "Quality Gate（品質ゲート）",
    "detail": "変更されたファイルに対して自動検証を実行: Metrika(コード品質メトリクス)、Chreos(技術的負債チェック)、Palimpsest(既存テストとの整合性)。"
   },
   {
    "id": "Ph2",
    "name": "Early Catch検証",
    "detail": "4段階の検証を順に実行: (1)Build — ビルドが通るか (2)Lint — 静的解析エラーがないか (3)Unit — 単体テスト通過 (4)Integration — 統合テスト通過。各段階で失敗したら即座に修正。"
   },
   {
    "id": "Ph3",
    "name": "偏差検知",
    "detail": "計画と成果物の差分を3軸で確認: (1)スコープ — 計画外の変更がないか (2)完全性 — 計画した変更が全て反映されたか (3)トレーサビリティ — 各変更が計画のどの項目に対応するか。"
   },
   {
    "id": "Ph3.5",
    "name": "動的リプランニング",
    "detail": "偏差検出時に4つの対応から選択: 修正(元の計画に戻す)、迂回(別の方法で同じ目標)、縮小(スコープを狭める)、中断(Creatorに相談)。テスト3回連続失敗→Creatorに報告。"
   },
   {
    "id": "Ph4",
    "name": "完了確認",
    "detail": "変更サマリー + 全ゲート結果 + コミット提案(Conventional Commits形式: feat/fix/refactor等)をCreatorに提示する。"
   },
   {
    "id": "Ph5",
    "name": "安全弁（ロールバック準備）",
    "detail": "復元ポイント + 変更一覧 + 影響範囲を記録。万が一の場合に元に戻せる状態を保証する。"
   }
  ],
  "derivatives": [
   {
    "name": "flow",
    "when": "没入して集中的に作業を進めたい時。中断を最小化したい",
    "output": "中断なしの連続実行。フェーズ間の確認を最小化し、最後にまとめて報告",
    "example": "「この5ファイルの修正を一気にやって」→ 全ファイルを連続修正、最後にまとめてレビュー"
   },
   {
    "name": "constructive",
    "when": "批判やレビュー指摘を受けた後、それを改善に変換したい時",
    "output": "批判→構造的改善計画→実行。否定的フィードバックを成長の材料に変換",
    "example": "「コードが汚い」→ 具体的なリファクタリング計画を策定し実行"
   },
   {
    "name": "prax",
    "when": "成果物より実行プロセスの質を重視したい時",
    "output": "過程の記録を重視した実行。各判断の理由と代替案を文書化",
    "example": "「学習目的でゼロから書きたい」→ ライブラリ使わずに手動実装、途中の判断を全記録"
   },
   {
    "name": "pois",
    "when": "具体的な成果物の完成を最優先にしたい時",
    "output": "最短経路での成果物完成。Must/Should/Could基準で優先度を管理",
    "example": "「デモ用にとにかく動くものが欲しい」→ Mustのみ実装、Should/Couldは後回し"
   }
  ],
  "algebra": {
   "+": "/ene+: 全フェーズ完全実行。リスク判定必須、Quality Gate必須、偏差検知必須。安全性を最大限に保証する詳細実行",
   "-": "/ene-: 最小限の実行。リスク🟢のタスクのみ。軽微な修正やドキュメント更新に使う",
   "*": "/ene*: 実行プロセス自体のメタ分析。「この実行方法は効率的か」「もっと良い実行手順はないか」を検証"
  },
  "usecases": [
   {
    "situation": "計画承認後の実装",
    "trigger": "「y」と答えた時、または/planの結果を承認した時",
    "action": "/ene が暗黙発動。リスク判定 → 実行 → 品質検証 → 偏差検知 → 完了確認の順に実行",
    "result": "計画通りの変更が安全に適用され、テストも通過した状態で完了"
   },
   {
    "situation": "リスクの高い変更を行う時",
    "trigger": "データベース移行、本番環境変更、大規模リファクタリング等",
    "action": "/ene+ でPh0.1のRisk Tag🔴を適用。スナップショット取得 → Premortem → 段階的実行 → 各段階でCreator確認",
    "result": "不可逆的な失敗を防ぎ、問題があれば即座にロールバック可能"
   },
   {
    "situation": "テストが連続失敗する時",
    "trigger": "Ph2のEarly Catch検証で3回連続失敗した時",
    "action": "自動的にCreatorに報告し判断を委任する。自力で無限ループに陥ることを防ぐ",
    "result": "人間の判断が介入し、根本原因の特定と方針転換が行われる"
   },
   {
    "situation": "外部フィードバックを反映したい",
    "trigger": "レビューコメントや障害報告を受けた時",
    "action": "/ene --derivative=constructive で批判を構造的改善計画に変換し実行",
    "result": "感情的な反応ではなく、建設的な改善が行われる"
   }
  ]
 },
 "met": {
  "name": "met",
  "jp": "S1 Metron（尺度）を発動し、スケール・粒度を決定する。スケール配置ワークフロー。",
  "series": "S",
  "pos": "T1",
  "ver": "2.4",
  "desc": "全体構造を俯瞰してシステムの青写真を作るツール。個々の部品ではなく、部品間の関係性（ポリシー・ルール・制約）を設計する。建物でいえば間取り図ではなく都市計画にあたる。",
  "adj": {
   "pair": "sta",
   "role": "F",
   "label": "Metron (F) ⊣ Stathmos (G)",
   "meaning": "F: Criterion → Scale（基準に測定の具体性を載せて尺度を構成）",
   "f_def": "「何を良しとするか」という基準に、Micro/Meso/Macro の粒度と測定方法を自由に構成する",
   "g_def": ""
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "現状マッピング",
    "detail": "システムの全体像を可視化する。コンポーネント、依存関係、データフロー、制御フローを図示。「何があるか」を漏れなく把握する。"
   },
   {
    "id": "Ph2",
    "name": "バランス評価",
    "detail": "システムの各部分の整合性を評価する。過剰な部分、不足している部分、矛盾する部分を特定。4つの軸（一貫性/完全性/冗長性/結合度）で数値化。"
   },
   {
    "id": "Ph3",
    "name": "基準策定",
    "detail": "計測可能な品質基準を定義する。「何が良い状態か」を具体的な数値で記述。SLO/SLI的なアプローチで客観的な判断基準を設定。"
   },
   {
    "id": "Ph4",
    "name": "ガバナンス設計",
    "detail": "ルール・ポリシー・制約を文書化する。「何をしてよいか/いけないか」を明確化し、個人の判断に依存しない仕組みを作る。"
   }
  ],
  "derivatives": [
   {
    "name": "struct",
    "when": "システム構造の全体像を把握したい時",
    "output": "コンポーネント図+依存関係図+データフロー図",
    "example": "新プロジェクト着手時に「何がどう繋がっているか」を可視化"
   },
   {
    "name": "balance",
    "when": "システムの整合性に不安がある時",
    "output": "4軸評価(一貫性/完全性/冗長性/結合度)+改善提案",
    "example": "「なぜかバグが多い」→ 結合度が高すぎることを定量的に検出"
   },
   {
    "name": "govern",
    "when": "チームのルール・規約を整備したい時",
    "output": "ポリシー文書+判断基準+例外処理規則",
    "example": "コーディング規約策定: 何を強制し何を推奨するかを明文化"
   }
  ],
  "algebra": {
   "+": "/met+: 全軸評価+ガバナンス設計を含む詳細分析",
   "-": "/met-: 主要コンポーネントと依存関係のみの簡易マップ",
   "*": "/met*: 設計手法自体のメタ評価。「この設計アプローチは適切か」"
  },
  "usecases": [
   {
    "situation": "新プロジェクトの全体設計",
    "trigger": "「まず何から作るべきか」が不明な時",
    "action": "/met で全体像をマッピング → コンポーネント分割 → 依存関係の順序を決定",
    "result": "開発順序と並列化可能な部分が明確になる"
   },
   {
    "situation": "レガシーシステムの理解",
    "trigger": "既存コードベースに入った時、全体像を把握したい",
    "action": "/met --derivative=struct でコンポーネントと依存関係を可視化",
    "result": "どこに手を入れると何に影響するかがわかる"
   },
   {
    "situation": "品質基準の策定",
    "trigger": "「何が良いコードか」の認識がチーム内でずれている時",
    "action": "/met --derivative=govern で計測可能な品質基準を定義",
    "result": "主観ではなく客観的な基準で判断できるようになる"
   }
  ]
 },
 "mek": {
  "name": "mek",
  "jp": "S2 Mekhanē（方法配置）を発動し、スキル/ワークフローを生成・診断する。tekhne-maker 統合。",
  "series": "S",
  "pos": "T2",
  "ver": "7.1",
  "desc": "スキル・ワークフロー・プロンプトを生成・診断・改善するツール。「方法を作る方法」。既存部品の組合せ(comp)、新規発明(inve)、既存の適応(adap)など複数のモードを持ち、品質スコアリングと自動改善まで一貫して行う。",
  "adj": {
   "pair": "pra",
   "role": "F",
   "label": "Mekhanē (F) ⊣ Praxis (G)",
   "meaning": "F: Practice → Method（IF-THENチャンクを束ねて方法論に構造化）",
   "f_def": "実践知・事例・パターンに理論的構造を載せて体系化する",
   "g_def": ""
  },
  "phases": [
   {
    "id": "STEP 0",
    "name": "SKILL.md読込",
    "detail": "tekhne-makerの正本を読み込む。生成品質に直結するため省略禁止。"
   },
   {
    "id": "STEP 1",
    "name": "モード判定",
    "detail": "要件から最適なモードを判定する(1分)。生成/診断/改善/CCL生成のいずれか。明示指定がなければGenerateモード。"
   },
   {
    "id": "STEP 1.5",
    "name": "Information Absorption",
    "detail": "背景情報の吸収(3分)。Creator の暗黙知を3つの問いで引き出す: (1)当たり前と思っている知識 (2)ドメインの暗黙の前提 (3)過去の関連KI/Handoff。背景情報3倍則: 指示トークン × 3 = 必要な背景トークン。"
   },
   {
    "id": "STEP 2",
    "name": "Semantic Audit",
    "detail": "M1 OVERLORD — 曖昧性検出(2分)。入力の曖昧な部分を特定し、Hidden Agenda（暗黙の意図）を抽出する。"
   },
   {
    "id": "STEP 3",
    "name": "3層処理",
    "detail": "M2 RECURSIVE_CORE (5分): Layer 1拡散 → Layer 2対立(Fail Fast: 失敗シナリオを事前検討) → Layer 3収束。「この生成物が失敗するとしたらなぜか」を必ず問う。"
   },
   {
    "id": "STEP 4",
    "name": "Archetype選択",
    "detail": "M3 — 5つの型(Precision/Speed/Autonomy/Creative/Safety)から生成物の特性を選択。5つの診断質問で判定する。"
   },
   {
    "id": "STEP 5",
    "name": "出力生成",
    "detail": "M4 RENDERING_CORE (5分)。BLUF Rule(結論先行) + Visual Logic Rule(視覚的構造化)に基づく出力。"
   },
   {
    "id": "STEP 6",
    "name": "品質検証",
    "detail": "M5 QUALITY_ASSURANCE (2分)。Pre-Mortem Simulation + 品質スコアリング。スコア80未満→Self-Refineパイプラインで自動改善。"
   },
   {
    "id": "STEP 7",
    "name": "初版確認",
    "detail": "SE反復原則: 生成物は「初版」として扱い、/dia-でクイックレビューを推奨する。完璧を目指さず、フィードバックループを回す。"
   }
  ],
  "derivatives": [
   {
    "name": "comp",
    "when": "既存の部品やパターンを組み合わせて作りたい時",
    "output": "既存コンポーネントの組合せによる新規生成物。統合設計図",
    "example": "「認証+通知+ログ」を組み合わせた統合ミドルウェアの設計"
   },
   {
    "name": "inve",
    "when": "前例のないものを新規に作りたい時",
    "output": "ゼロから設計された新規生成物。根拠と代替案を含む",
    "example": "「HGK独自のプロンプト言語」の設計 — 既存に類似がない"
   },
   {
    "name": "adap",
    "when": "既存のツールを別の目的に転用・適応させたい時",
    "output": "既存ツールのカスタマイズ計画。変更点と影響範囲",
    "example": "JestのテストフレームワークをWF品質検証用に適応させる"
   },
   {
    "name": "visual",
    "when": "視覚的な成果物が必要な時",
    "output": "モックアップ、インフォグラフィック、図表",
    "example": "WF体系の全体図をMermaidダイアグラムで視覚化"
   },
   {
    "name": "manual",
    "when": "Gemini/Jules向けの手順書が必要な時",
    "output": "補完防止の明確な手順書。曖昧さゼロの指示",
    "example": "Jules用のリファクタリング指示書 — 各ステップを明示的に記述"
   }
  ],
  "algebra": {
   "+": "/mek+: 全STEP(0-7)展開、設計根拠記載、Pre-Mortem、CCL複雑度計算を含む詳細生成",
   "-": "/mek-: 最小構造のみ、即座に使える形で出力。装飾なし",
   "*": "/mek*: 生成プロセス自体を問う。「この方法で生成すべきか」「別のアプローチの方が良いか」"
  },
  "usecases": [
   {
    "situation": "新しいSkillを作りたい",
    "trigger": "繰り返し行う作業をSkillとして定型化したい時",
    "action": "/mek で要件を整理 → Archetype選択 → SKILL.md生成 → /dia- でレビュー",
    "result": "標準形式のSKILL.mdが生成され、即座に利用可能"
   },
   {
    "situation": "既存プロンプトの品質を評価したい",
    "trigger": "「このプロンプトは本当に良いのか」と疑問がある時",
    "action": "/mek diagnose [ファイル] で品質スコアリング実行。スコア80未満→自動改善",
    "result": "客観的な品質スコアと具体的な改善提案が得られる"
   },
   {
    "situation": "CCLマクロを新規作成したい",
    "trigger": "よく使うワークフローの組合せをCCLで簡潔に表現したい時",
    "action": "/mek ccl \"意図\" でCCLを自動生成 → 複雑度ポイントを計算 → 60pt超なら分割",
    "result": "適切な複雑度のCCL式が生成され、再利用可能になる"
   },
   {
    "situation": "チーム向けの作業マニュアルを作りたい",
    "trigger": "AIに作業を依頼するための手順書が必要な時",
    "action": "/mek --derivative=manual で補完防止の手順書を生成。曖昧さゼロ",
    "result": "誰が読んでも同じ結果が得られる明確な手順書"
   }
  ]
 },
 "sta": {
  "name": "sta",
  "jp": "S3 Stathmos（基準）を発動し、評価基準・ベンチマークを設定する。基準配置ワークフロー。",
  "series": "S",
  "pos": "T3",
  "ver": "2.3",
  "desc": "現在の状態を正確に把握するツール。理想との距離（ギャップ）を定量化し、偏差の原因を分析する。/met が青写真なら、/sta は現地調査にあたる。「今どこにいるか」を客観的に知る。",
  "adj": {
   "pair": "sta",
   "role": "F",
   "label": "Metron (F) ⊣ Stathmos (G)",
   "meaning": "G: Scale → Criterion（尺度からスケールの具体性を剥いで、純粋な基準に戻る）",
   "f_def": "G: Scale → Criterion（尺度からスケールの具体性を剥いで、純粋な基準に戻る）",
   "g_def": "「どう測るか」という手段を忘却し、「何を良しとするか」という判断基準だけを残す"
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "現状認識",
    "detail": "感覚的な把握ではなく、エビデンス（ファイル内容、テスト結果、メトリクス）に基づいて現在の状態を記述する。"
   },
   {
    "id": "Ph2",
    "name": "逸脱検出",
    "detail": "基準値（/met で策定した基準やSLO）からの乖離を検出。偏差の大きさを数値化する。"
   },
   {
    "id": "Ph3",
    "name": "原因仮説",
    "detail": "逸脱の原因について仮説を立てる。/zetの問い生成と連携して、最も蓋然性の高い原因を推定。"
   },
   {
    "id": "Ph4",
    "name": "是正提案",
    "detail": "原因に対する具体的な改善策を提案する。即座に実行可能なもの(Quick Win)と根本対策を区別して提示。"
   }
  ],
  "derivatives": [
   {
    "name": "monitor",
    "when": "定期的に状態を確認したい時",
    "output": "ダッシュボード的な状態サマリー。正常/警告/異常の3段階判定",
    "example": "毎日のビルド状態、テストカバレッジ、技術的負債の定点観測"
   },
   {
    "name": "diagnosis",
    "when": "問題が発生して原因を突き止めたい時",
    "output": "症状→原因仮説→検証計画のフロー",
    "example": "「CIが30%遅くなった」→ dependency解決時間の増加が原因と特定"
   },
   {
    "name": "forensics",
    "when": "過去の障害を事後分析したい時",
    "output": "タイムライン+根本原因+再発防止策",
    "example": "本番障害の振り返り: 何が起き→なぜ起き→どう防ぐか"
   }
  ],
  "algebra": {
   "+": "/sta+: 全軸でのギャップ分析+原因分析+是正提案を含む詳細調査",
   "-": "/sta-: 主要メトリクスの現在値のみ。1分で完了する状態確認",
   "*": "/sta*: 観測方法自体のメタ分析。「この計測方法で本当に状態がわかるか」"
  },
  "usecases": [
   {
    "situation": "プロジェクトの健全性確認",
    "trigger": "「このプロジェクトは順調か？」を客観的に判断したい時",
    "action": "/sta で現状を数値化 → 基準値との比較 → ギャップの大きい項目を特定",
    "result": "感覚ではなくデータに基づいた健全性評価が得られる"
   },
   {
    "situation": "バグの原因調査",
    "trigger": "問題が発生したが原因がわからない時",
    "action": "/sta --derivative=diagnosis で症状を記述 → 原因仮説を生成 → 検証計画を策定",
    "result": "効率的な原因調査のロードマップが得られる"
   },
   {
    "situation": "障害の振り返り",
    "trigger": "本番障害が収束した後、再発防止策を検討したい時",
    "action": "/sta --derivative=forensics でタイムラインを再構成 → 根本原因を特定 → 再発防止策を設計",
    "result": "同じ障害が二度と起きない仕組みが構築される"
   }
  ]
 },
 "pra": {
  "name": "pra",
  "jp": "S4 Praxis（実践）を発動し、価値実現の方法を選択する。実践配置ワークフロー。",
  "series": "S",
  "pos": "T4",
  "ver": "2.3",
  "desc": "実践における価値実現の方法を選択するツール。「何をすべきか」(倫理的/効果的/効率的)を判断し、最適な実行方法を配置する。/ene が「やる」なら、/pra は「どうやるか」を考える。",
  "adj": {
   "pair": "pra",
   "role": "F",
   "label": "Mekhanē (F) ⊣ Praxis (G)",
   "meaning": "G: Method → Practice（方法論を多数のIF-THENチャンクに分解）",
   "f_def": "G: Method → Practice（方法論を多数のIF-THENチャンクに分解）",
   "g_def": "1つの解（技術・方法論）の理論的構造を忘却し、条件反射的なIF-THENに分解する"
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "価値同定",
    "detail": "実現すべき価値を特定する。目標（/bouの出力）と現状（/staの出力）のギャップから何を実現すべきかを明確にする。"
   },
   {
    "id": "Ph2",
    "name": "手段列挙",
    "detail": "価値実現のための手段を複数列挙する。各手段のメリット/デメリット/コスト/リスクを比較表で整理。"
   },
   {
    "id": "Ph3",
    "name": "方法選択",
    "detail": "トレードオフを考慮して最適な手段を選択する。選択基準: 効果/コスト/リスク/学習価値のバランス。"
   },
   {
    "id": "Ph4",
    "name": "実行配置",
    "detail": "選択した手段を具体的な実行計画に落とす。/ene への入力となる形で、順序/担当/期限を設定。"
   }
  ],
  "derivatives": [
   {
    "name": "ethical",
    "when": "倫理的な判断が必要な時。「すべきか/すべきでないか」",
    "output": "倫理的評価+ステークホルダー影響分析+推奨アクション",
    "example": "「ユーザーデータをどこまで収集するか」→ プライバシーと利便性のバランス判定"
   },
   {
    "name": "effective",
    "when": "効果を最大化したい時。「最もインパクトのある方法は何か」",
    "output": "効果予測+投資対効果(ROI)分析+推奨手段",
    "example": "「テスト戦略をどうするか」→ コスト対リスクで最適なテスト範囲を選択"
   },
   {
    "name": "efficient",
    "when": "効率を最大化したい時。「最小コストでどう達成するか」",
    "output": "リソース最適化計画+ボトルネック特定+改善策",
    "example": "「CI時間を半減させたい」→ 並列化+キャッシュ+不要テスト削除の優先順位"
   }
  ],
  "algebra": {
   "+": "/pra+: 全手段の詳細比較+トレードオフ分析+実行計画を含む詳細配置",
   "-": "/pra-: 最も効率的な1手段のみ即座に選択",
   "*": "/pra*: 意思決定プロセス自体のメタ分析。「この選択基準は適切か」"
  },
  "usecases": [
   {
    "situation": "実装方法の選択",
    "trigger": "「どの方法で実装するか」で選択肢が複数ある時",
    "action": "/pra で各方法のメリット/デメリット/コスト/リスクを比較 → 基準に従い選択",
    "result": "根拠のある技術選択ができ、後から「なぜこの方法にしたか」を説明できる"
   },
   {
    "situation": "リソース配分の最適化",
    "trigger": "限られた時間/人員で最大の成果を出したい時",
    "action": "/pra --derivative=efficient でボトルネックを特定 → リソース再配分 → 実行計画を/eneに渡す",
    "result": "無駄が排除され、重要な作業にリソースが集中する"
   },
   {
    "situation": "トレードオフの判断",
    "trigger": "「速度vs品質」「機能vsシンプルさ」など対立する価値がある時",
    "action": "/pra で両方の価値を定量化 → トレードオフ曲線を描く → 最適点を選択",
    "result": "感覚ではなくデータに基づいたトレードオフ判断ができる"
   }
  ]
 },
 "pro": {
  "name": "pro",
  "jp": "H1 Propatheia（前感情）を発動し、初期傾向・直感を評価する。3派生対応版。",
  "series": "H",
  "pos": "T1",
  "ver": "2.4",
  "desc": "最初の直感・第一印象を捉えるツール。分析の前に「まず何を感じたか」を記録する。この初期反応は後の詳細分析で見失われやすいため、先に固定する。感情的な反応ではなく認知的シグナルとして扱う。",
  "adj": {
   "pair": "ore",
   "role": "F",
   "label": "Propatheia (F) ⊣ Orexis (G)",
   "meaning": "F: Desire → Gut（欲求に生の熱を載せて直感的判定に構成 = System 1）",
   "f_def": "価値判断に即時性・情動強度を付与して、瞬間的な接近/回避を構成する",
   "g_def": ""
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "初期反応の捕捉",
    "detail": "対象に触れた瞬間の反応を言語化する。「何が気になったか」「どこに違和感があるか」「何が魅力的か」を3つ以上列挙。分析せず、感じたままを記録する。"
   },
   {
    "id": "Ph2",
    "name": "反応の分類",
    "detail": "捕捉した反応を3軸で分類: (1)方向性（接近/回避）(2)強度（強/中/弱）(3)確信度（確信/推定/仮説）。数値化して比較可能にする。"
   },
   {
    "id": "Ph3",
    "name": "シグナル抽出",
    "detail": "反応の中から認知的シグナル（構造的違和感、パターン認識、美的判断）を抽出。社交的情緒（「すごい」「大変」）は除外し、情報として有用な反応だけを残す。"
   }
  ],
  "derivatives": [
   {
    "name": "quick",
    "when": "素早く第一印象を記録したい時",
    "output": "3つの反応ポイント + 方向性(接近/回避) + 強度(1-10)",
    "example": "新しいPRを見た瞬間の「ここが気になる」を3つ記録"
   },
   {
    "name": "deep",
    "when": "直感を丁寧に掘り下げたい時",
    "output": "反応の根拠分析 + 過去の類似経験との比較 + 構造的違和感の特定",
    "example": "「なぜこのコードに違和感があるか」を構造的に分析"
   },
   {
    "name": "contrast",
    "when": "複数の選択肢への反応を比較したい時",
    "output": "各選択肢への反応の比較表 + 差分から見える判断基準",
    "example": "3つのデザイン案への第一印象を比較 → 無意識の選好基準を発見"
   }
  ],
  "algebra": {
   "+": "/pro+: 反応の根拠分析+過去経験との比較+構造的違和感の特定を含む詳細な直感分析",
   "-": "/pro-: 3つの反応ポイントだけを即座に記録。30秒で完了",
   "*": "/pro*: 直感の信頼性のメタ分析。「この直感はバイアスか認知的シグナルか」"
  },
  "usecases": [
   {
    "situation": "レビュー開始時",
    "trigger": "コードやドキュメントのレビューを始める前",
    "action": "/pro- で第一印象を3つ記録 → その後 /dia で詳細レビュー",
    "result": "詳細分析で見失いがちな「最初の違和感」が保存される"
   },
   {
    "situation": "新しいアイデアに触れた時",
    "trigger": "提案や新技術に最初に触れた瞬間",
    "action": "/pro で初期反応を固定 → 後の分析と比較",
    "result": "分析バイアスに汚染されない「素の反応」が残る"
   },
   {
    "situation": "意思決定の前",
    "trigger": "重要な判断をする前に直感を確認したい時",
    "action": "/pro でまず直感を記録 → /noe で分析 → 直感と分析の一致/乖離を確認",
    "result": "直感と分析が矛盾する場合、その矛盾自体が重要な情報になる"
   }
  ]
 },
 "pis": {
  "name": "pis",
  "jp": "H2 Pistis（確信）を発動し、確信度・信頼性を評価する。3派生対応版。",
  "series": "H",
  "pos": "T2",
  "ver": "2.3",
  "desc": "確信度・信頼性を評価するツール。「どれくらい確かか」を正確に測る。過信（確信度 > 実際の正確性）と過小評価（確信度 < 実際の正確性）の両方を検出し、キャリブレーションを行う。",
  "adj": {
   "pair": "dox",
   "role": "F",
   "label": "Pistis (F) ⊣ Doxa (G)",
   "meaning": "F: Belief → Trust（信念にエビデンス・推論過程を載せて確信度に構成）",
   "f_def": "結論に根拠列挙・反証検討・信頼区間の推論過程を付与して確信度を構成する",
   "g_def": ""
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "確信度測定",
    "detail": "各主張に対して確信度(0-100%)を付与。根拠を1つ以上添える。根拠なき確信は「過信」として警告する。"
   },
   {
    "id": "Ph2",
    "name": "エビデンス評価",
    "detail": "根拠の質を評価する。直接観察(SOURCE) vs 間接情報(TAINT)を区別。BC-6のTAINT/SOURCE追跡と連携。"
   },
   {
    "id": "Ph3",
    "name": "キャリブレーション",
    "detail": "過去の判断の的中率と照合し、確信度の精度を評価する。「90%確信と言った判断のうち、実際に正しかったのは何%か」を検証。"
   },
   {
    "id": "Ph4",
    "name": "不確実性マッピング",
    "detail": "「わかっていること」「わかっていないこと」「わかっていないことすら知らないこと」を区別し、リスクマップを作成。"
   }
  ],
  "derivatives": [
   {
    "name": "calibrate",
    "when": "自分の確信度が正確かどうか検証したい時",
    "output": "過去判断の的中率+キャリブレーション曲線+改善提案",
    "example": "「90%確信の判断が実際には60%しか当たっていない」→ 過信傾向を検出"
   },
   {
    "name": "evidence",
    "when": "主張の根拠を体系的に評価したい時",
    "output": "エビデンスの質と量の評価+TAINT/SOURCE分類+信頼度スコア",
    "example": "設計判断の根拠を整理: 「テスト結果(SOURCE)」vs「経験則(TAINT)」を区別"
   },
   {
    "name": "uncertainty",
    "when": "不確実性を可視化したい時",
    "output": "Known/Unknown/Unknown-UnknownのマッピングTable+リスク評価",
    "example": "新技術採用時: 「確実に動く部分」「不明な部分」「気づいていないリスク」を分類"
   }
  ],
  "algebra": {
   "+": "/pis+: 全フェーズ実行+キャリブレーション+不確実性マッピングを含む詳細な確信度分析",
   "-": "/pis-: 主要主張の確信度ラベル(確信/推定/仮説)のみ。即座に完了",
   "*": "/pis*: 確信度評価方法自体のメタ分析。「この評価方法は信頼できるか」"
  },
  "usecases": [
   {
    "situation": "重要な判断の前",
    "trigger": "取り返しのつかない判断をする前に確信度を確認したい",
    "action": "/pis で確信度を測定 → エビデンスを評価 → 不確実な部分を特定 → リスクに応じた対策",
    "result": "過信による失敗を防ぎ、不確実な部分に適切な安全策を講じられる"
   },
   {
    "situation": "情報源の信頼性評価",
    "trigger": "複数の情報源があり、どれを信頼すべきか判断したい時",
    "action": "/pis --derivative=evidence で各情報源をSOURCE/TAINTで分類 → 信頼度スコアを算出",
    "result": "信頼できる情報とそうでない情報が明確に区別される"
   },
   {
    "situation": "過信の傾向を自覚したい",
    "trigger": "「いつも自信満々に間違える」パターンを改善したい時",
    "action": "/pis --derivative=calibrate で過去の判断を振り返り → キャリブレーション曲線を作成",
    "result": "自分の確信度の癖がわかり、適切な自信レベルに調整できる"
   }
  ]
 },
 "ore": {
  "name": "ore",
  "jp": "H3 Orexis（欲求）を発動し、価値傾向・欲求を評価する。3派生対応版。",
  "series": "H",
  "pos": "T3",
  "ver": "2.4",
  "desc": "欲求・価値傾向を評価するツール。「何に引かれているか」「何を避けているか」を可視化する。動機の構造を分析し、表面的な欲求の下にある深層的な価値観を発見する。",
  "adj": {
   "pair": "ore",
   "role": "F",
   "label": "Propatheia (F) ⊣ Orexis (G)",
   "meaning": "G: Gut → Desire（直感から生の熱を忘却し、価値根拠のある欲求に変換）",
   "f_def": "G: Gut → Desire（直感から生の熱を忘却し、価値根拠のある欲求に変換）",
   "g_def": "System 1 の即時反応を System 2 で言語化し、情動の鮮度を不可逆的に冷ます"
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "欲求の捕捉",
    "detail": "現在の欲求・価値傾向を全て列挙する。「やりたいこと」「避けたいこと」「気になること」を分類して記録。"
   },
   {
    "id": "Ph2",
    "name": "価値マッピング",
    "detail": "各欲求の背後にある価値観を特定する。「なぜそれを望むのか」を3層で掘り下げ、根源的な価値に到達する。"
   },
   {
    "id": "Ph3",
    "name": "傾向分析",
    "detail": "欲求のパターンを分析する。接近傾向(〜がほしい)と回避傾向(〜を避けたい)のバランス、短期vs長期の比率を可視化。"
   }
  ],
  "derivatives": [
   {
    "name": "attract",
    "when": "何に引かれているかを分析したい時",
    "output": "接近傾向のリスト+各傾向の強度+根源的価値観",
    "example": "「新しい技術に飛びつく傾向」→ 根源: 知的好奇心+承認欲求"
   },
   {
    "name": "avoid",
    "when": "何を避けているかを分析したい時",
    "output": "回避傾向のリスト+各傾向の原因+リスク評価",
    "example": "「テスト記述を後回しにする傾向」→ 根源: 即時報酬の欠如+失敗への恐れ"
   },
   {
    "name": "balance",
    "when": "欲求のバランスを評価したい時",
    "output": "接近/回避のバランス分析+偏りの特定+調整提案",
    "example": "「探索(新技術)に偏りすぎ。深化(既存技術の熟達)が不足」→ バランス調整"
   }
  ],
  "algebra": {
   "+": "/ore+: 欲求の全リスト+3層価値分析+傾向パターン分析を含む詳細評価",
   "-": "/ore-: 最も強い欲求3つとその方向(接近/回避)のみ",
   "*": "/ore*: 欲求分析方法自体のメタ分析。「この分析で本当の欲求が見えるか」"
  },
  "usecases": [
   {
    "situation": "モチベーションの低下",
    "trigger": "「やる気が出ない」「何をしたいかわからない」時",
    "action": "/ore で現在の欲求を可視化 → 本当にやりたいことを特定 → /bou で意志化",
    "result": "表面的な無気力の下にある本当の欲求が発見される"
   },
   {
    "situation": "優先順位の混乱",
    "trigger": "やりたいことが多すぎて整理できない時",
    "action": "/ore で全欲求を列挙 → 価値マッピングで重複を発見 → 統合して整理",
    "result": "見かけ上多い欲求が実は少数の価値観から派生していたことがわかる"
   },
   {
    "situation": "習慣的な回避の克服",
    "trigger": "特定の作業を常に後回しにしてしまう時",
    "action": "/ore --derivative=avoid で回避傾向の根源を分析 → /bou akra で意志-行為乖離を克服",
    "result": "回避の原因が特定され、環境設計で克服できる"
   }
  ]
 },
 "dox": {
  "name": "dox",
  "jp": "H4 Doxa（信念）を発動し、信念を記録・永続化する。3派生対応版。",
  "series": "H",
  "pos": "T4",
  "ver": "2.4",
  "desc": "信念を記録・永続化するツール。セッション中に得た洞察、判断、学びを外部ファイルに保存する。人間のメモに相当し、「忘れないようにする」ための仕組み。Knowledge Item(KI)やHandoffと連携する。",
  "adj": {
   "pair": "dox",
   "role": "F",
   "label": "Pistis (F) ⊣ Doxa (G)",
   "meaning": "G: Trust → Belief（確信から推論過程を忘却し、結論だけを信念として保存）",
   "f_def": "G: Trust → Belief（確信から推論過程を忘却し、結論だけを信念として保存）",
   "g_def": "エビデンスの取捨選択・重み付け・比較検討の過程を捨てて、結果のみ保持"
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "信念の特定",
    "detail": "セッション中に形成された信念（確信/推定/仮説）を列挙する。暗黙的に形成された判断も含めて可視化する。"
   },
   {
    "id": "Ph2",
    "name": "記録形式の選択",
    "detail": "信念の性質に応じた記録先を選択: KI(恒久的知識)、Handoff(セッション間引き継ぎ)、ROM(セッション内記録)、patterns.yaml(行動パターン)。"
   },
   {
    "id": "Ph3",
    "name": "永続化",
    "detail": "選択した形式でファイルに書き出す。確信度ラベル(BC-6)とTAINT/SOURCE追跡を付与。後から検証可能な形式で記録する。"
   }
  ],
  "derivatives": [
   {
    "name": "capture",
    "when": "セッション中に得た知見を即座に保存したい時",
    "output": "KIファイルまたはHandoffへの記録。確信度ラベル付き",
    "example": "「この設計パターンは有効」(確信:80%, SOURCE: テスト成功) → KI保存"
   },
   {
    "name": "review",
    "when": "過去の信念を振り返りたい時",
    "output": "保存済み信念のリスト+現在の評価(依然有効/要修正/無効化)",
    "example": "1ヶ月前の設計判断を振り返り: 3つは有効、1つは前提が変わり無効化"
   },
   {
    "name": "prune",
    "when": "古い信念を整理したい時",
    "output": "整理結果: 保持/更新/削除の分類+理由",
    "example": "KIの棚卸し: 20件中5件が古くなっており更新が必要"
   }
  ],
  "algebra": {
   "+": "/dox+: 全信念の特定+記録形式選択+永続化+関連信念との整合性検証を含む詳細記録",
   "-": "/dox-: 最も重要な1-2個の信念のみ即座に保存",
   "*": "/dox*: 信念記録プロセス自体のメタ分析。「何を記録すべきで何を忘れるべきか」"
  },
  "usecases": [
   {
    "situation": "セッション終了時の学び保存",
    "trigger": "有用な洞察が得られたセッションの終了時",
    "action": "/dox で信念を特定 → 適切な形式で保存 → /bye のHandoffに含める",
    "result": "次回セッションで同じ洞察を再発見する無駄がなくなる"
   },
   {
    "situation": "判断の根拠を記録",
    "trigger": "重要な設計判断をした時、後から「なぜそうしたか」を追跡したい",
    "action": "/dox --derivative=capture で判断+根拠+確信度を記録",
    "result": "後からADR(Architecture Decision Record)として参照できる"
   },
   {
    "situation": "知識ベースの棚卸し",
    "trigger": "KIやHandoffが増えてきて整理が必要な時",
    "action": "/dox --derivative=prune で全信念を振り返り → 有効/更新/削除に分類 → 実行",
    "result": "知識ベースが最新の状態に保たれ、古い情報による誤判断を防ぐ"
   }
  ]
 },
 "kho": {
  "name": "kho",
  "jp": "P1 Khōra（場）を発動し、スコープ・領域を定義する。3派生対応版。",
  "series": "P",
  "pos": "T1",
  "ver": "2.3",
  "desc": "場・文脈・環境を認識するツール。「今どこにいるか」ではなく「この場がどういう場か」を理解する。安全な場(sandbox)か聖域(kernel)か作業場(workspace)かで、取るべき行動の安全レベルが変わる。ファイルパスやgit状態から場の性質を自動判定する。",
  "adj": {
   "pair": "tro",
   "role": "F",
   "label": "Khōra (F) ⊣ Trokhia (G)",
   "meaning": "F: Orbit → Space（軌道に解像度を載せて場を構成 = Micro化）",
   "f_def": "大局的サイクルに細部の空間構造を付与して、高解像度の場を構成する",
   "g_def": ""
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "場の同定",
    "detail": "操作対象のパスやコンテキストから場の種類を判定する。kernel/(聖域)、experiments/(遊び場)、mekhane/(作業場)、外部API(外界)の4分類。"
   },
   {
    "id": "Ph2",
    "name": "安全レベル決定",
    "detail": "場の性質に応じた安全レベルを設定。聖域→LBYL(事前確認必須)、遊び場→EAFP(失敗OK)、作業場→EAFP+レビュー、外界→LBYL。"
   },
   {
    "id": "Ph3",
    "name": "制約の適用",
    "detail": "決定した安全レベルに基づき、操作に対する制約を適用する。commit前レビュー、スナップショット取得、Creator承認などの条件を自動設定。"
   }
  ],
  "derivatives": [
   {
    "name": "scan",
    "when": "作業前に環境を確認したい時",
    "output": "場の分類+安全レベル+適用される制約のリスト",
    "example": "作業開始時にgit status + ファイルパスから「作業場/可逆/EAFP」と判定"
   },
   {
    "name": "guard",
    "when": "危険な操作の前にガードレールを設置したい時",
    "output": "操作のリスク評価+必要な事前措置+ロールバック計画",
    "example": "DB移行前に「外界/不可逆/LBYL」→ バックアップ必須+Creator承認必須"
   },
   {
    "name": "navigate",
    "when": "場を移動する時に適切な振る舞いを確認したい時",
    "output": "移動先の場の性質+変更される制約+注意事項",
    "example": "sandbox→kernel移動時に「安全レベルが上がります。変更にはCreator承認が必要です」"
   }
  ],
  "algebra": {
   "+": "/kho+: 全場の詳細マッピング+安全レベル+制約+リスク評価を含む完全な環境分析",
   "-": "/kho-: 現在の場の分類と安全レベルのみ。即座に判定",
   "*": "/kho*: 場の分類基準自体のメタ分析。「この分類は適切か」"
  },
  "usecases": [
   {
    "situation": "安全な変更範囲の確認",
    "trigger": "「この変更はどこまで影響するか」を事前に知りたい時",
    "action": "/kho で場を同定 → 安全レベルに応じた操作方針を設定",
    "result": "場の性質に合った安全策が自動的に適用される"
   },
   {
    "situation": "本番環境への操作前",
    "trigger": "不可逆的な操作を行う前",
    "action": "/kho --derivative=guard で操作のリスクを評価 → スナップショット+承認フローを設定",
    "result": "万が一の時にロールバック可能な状態が保証される"
   },
   {
    "situation": "新しいプロジェクトへの着手",
    "trigger": "初めてのコードベースで作業を開始する時",
    "action": "/kho --derivative=scan で環境を理解 → 場の構造と制約を把握",
    "result": "「どこが危険でどこが安全か」がわかり、適切な注意力で作業できる"
   }
  ]
 },
 "hod": {
  "name": "hod",
  "jp": "P2 Hodos（道）を発動し、経路・道筋を定義する。3派生対応版。",
  "series": "P",
  "pos": "T2",
  "ver": "2.3",
  "desc": "全体のロードマップ・進行計画を策定するツール。個々のタスクではなく、プロジェクト全体の方向性と段階を設計する。マイルストーンの設定、依存関係の整理、フェーズ分割を行い、/chr(時系列配置)や/ene(実行)の入力を生成する。",
  "adj": {
   "pair": "tek",
   "role": "F",
   "label": "Hodos (F) ⊣ Tekhnē (G)",
   "meaning": "F: Technique → Path（技法に経路設計を載せて道を構成 = Micro化）",
   "f_def": "大局的な技法選択に具体的な段階・順序を付与して、高解像度の道筋を構成する",
   "g_def": ""
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "ゴール定義",
    "detail": "最終的に達成すべき状態を具体的に定義する。/bouの出力を入力として、計測可能な達成基準を設定。"
   },
   {
    "id": "Ph2",
    "name": "フェーズ分割",
    "detail": "ゴールまでの道のりを3-5フェーズに分割する。各フェーズの成果物と完了条件を定義。"
   },
   {
    "id": "Ph3",
    "name": "依存関係分析",
    "detail": "フェーズ間、タスク間の依存関係を特定する。並列化可能な部分と順序必須な部分を区別。"
   },
   {
    "id": "Ph4",
    "name": "リスクポイント特定",
    "detail": "各フェーズの失敗リスクを事前に特定し、対策を準備する。Pre-Mortem的アプローチ。"
   }
  ],
  "derivatives": [
   {
    "name": "roadmap",
    "when": "プロジェクト全体の計画を立てたい時",
    "output": "フェーズ分割+マイルストーン+依存関係図+リスクポイント",
    "example": "3ヶ月の開発計画: 4フェーズ、各フェーズに達成基準とリスク対策"
   },
   {
    "name": "sprint",
    "when": "短期間の作業計画を立てたい時",
    "output": "1-2週間の具体的タスクリスト+優先順位+完了基準",
    "example": "今週のスプリント: 8タスク、依存関係で3→2→3に分割"
   },
   {
    "name": "pivot",
    "when": "計画の方向転換が必要な時",
    "output": "現計画vs新計画の比較+移行コスト+推奨判断",
    "example": "「方針を変えるべきか」→ 現計画のサンクコストvs新計画の期待値を比較"
   }
  ],
  "algebra": {
   "+": "/hod+: 全フェーズの詳細計画+依存関係図+リスク分析+マイルストーンを含む完全なロードマップ",
   "-": "/hod-: 主要3フェーズとそれぞれの1行ゴールのみ",
   "*": "/hod*: 計画手法自体のメタ分析。「この計画の立て方は効果的か」"
  },
  "usecases": [
   {
    "situation": "新プロジェクト開始",
    "trigger": "中長期のプロジェクトを始める前に計画を立てたい時",
    "action": "/hod で全体ロードマップを策定 → /chr で時系列に配置 → /ene で実行開始",
    "result": "見通しの良い計画ができ、途中で迷うことが減る"
   },
   {
    "situation": "スプリント計画",
    "trigger": "今週の作業を具体的に決めたい時",
    "action": "/hod --derivative=sprint で短期タスクを整理 → 優先順位付け → 実行",
    "result": "「今日何をやるか」が毎朝明確になる"
   },
   {
    "situation": "方針転換の判断",
    "trigger": "計画通りに進まず、方向転換を検討している時",
    "action": "/hod --derivative=pivot で現計画と代替計画を比較 → サンクコストを排除して判断",
    "result": "感情ではなくデータに基づいた方針転換の判断ができる"
   }
  ]
 },
 "tro": {
  "name": "tro",
  "jp": "P3 Trokhia（軌道）を発動し、適用範囲・サイクルを定義する。3派生対応版。",
  "series": "P",
  "pos": "T3",
  "ver": "2.3",
  "desc": "環境の変化・外乱に対する適応戦略を設計するツール。予期しない変化への対応方法を事前に準備する。レジリエンス（回復力）とアダプタビリティ（適応力）の両面から環境変化への耐性を構築する。",
  "adj": {
   "pair": "tro",
   "role": "F",
   "label": "Khōra (F) ⊣ Trokhia (G)",
   "meaning": "G: Space → Orbit（場から解像度を忘却し、軌道（Macroサイクル）に圧縮）",
   "f_def": "G: Space → Orbit（場から解像度を忘却し、軌道（Macroサイクル）に圧縮）",
   "g_def": "高解像度の空間構造を粗視化して、周回可能な1本の経路に落とす"
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "変化の検出",
    "detail": "環境の変化を検出・分類する。技術的変化(依存ライブラリ更新)、組織的変化(チーム再編)、市場変化(競合出現)など。"
   },
   {
    "id": "Ph2",
    "name": "影響評価",
    "detail": "検出された変化の影響範囲と深刻度を評価する。直接的影響と間接的影響を区別し、波及効果を予測。"
   },
   {
    "id": "Ph3",
    "name": "適応戦略設計",
    "detail": "変化への対応方法を設計: 吸収(変化を内部で処理)、回避(変化の影響を受けない設計)、変換(変化をチャンスに変える)。"
   },
   {
    "id": "Ph4",
    "name": "レジリエンス強化",
    "detail": "将来の変化に備えた耐性構築: 疎結合設計、フォールバック機構、段階的デグレーション。"
   }
  ],
  "derivatives": [
   {
    "name": "detect",
    "when": "環境変化を早期に検出したい時",
    "output": "変化のリスト+分類+深刻度スコア",
    "example": "依存ライブラリのdeprecation警告を検出 → 移行計画を策定"
   },
   {
    "name": "adapt",
    "when": "変化に対する具体的な適応策を立てたい時",
    "output": "適応戦略(吸収/回避/変換)+実行計画+タイムライン",
    "example": "Python 2→3移行: 段階的移行戦略+互換性ラッパー設計"
   },
   {
    "name": "harden",
    "when": "将来の変化に備えたい時",
    "output": "レジリエンス設計+フォールバック+デグレーション計画",
    "example": "API依存を抽象化し、提供者が変わっても内部に影響しない設計"
   }
  ],
  "algebra": {
   "+": "/tro+: 全変化の検出+影響評価+適応戦略+レジリエンス設計を含む完全な適応分析",
   "-": "/tro-: 最も差し迫った変化1つとその対応策のみ",
   "*": "/tro*: 適応戦略自体のメタ分析。「この対応方法は適切か」"
  },
  "usecases": [
   {
    "situation": "依存ライブラリの破壊的変更",
    "trigger": "使用しているライブラリに破壊的変更が予告された時",
    "action": "/tro --derivative=detect で影響評価 → --derivative=adapt で移行戦略を設計 → /ene で実行",
    "result": "破壊的変更に対する段階的な移行計画ができる"
   },
   {
    "situation": "予防的なレジリエンス構築",
    "trigger": "まだ問題は起きていないが、将来の変化に備えたい時",
    "action": "/tro --derivative=harden で脆弱点を特定 → 疎結合設計+フォールバック機構を設計",
    "result": "予期しない変化が来ても影響範囲が限定される"
   },
   {
    "situation": "計画外の環境変化への対応",
    "trigger": "予期しない技術的・組織的変化が発生した時",
    "action": "/tro で変化を検出・分類 → 影響評価 → 吸収/回避/変換から最適な戦略を選択",
    "result": "パニックではなく構造的な対応ができる"
   }
  ]
 },
 "tek": {
  "name": "tek",
  "jp": "P4 Tekhnē（技法）を発動し、「どの技法で」を決定する。3派生対応版。",
  "series": "P",
  "pos": "T4",
  "ver": "2.3",
  "desc": "スキル（技能）の習得・向上を支援するツール。「何を学ぶべきか」「どう学ぶべきか」「今の習熟度はどこか」を構造的に管理する。学習の計画、実行、評価のサイクルを回す。",
  "adj": {
   "pair": "tek",
   "role": "F",
   "label": "Hodos (F) ⊣ Tekhnē (G)",
   "meaning": "G: Path → Technique（道から経路の詳細を忘却し、技法選択に圧縮）",
   "f_def": "G: Path → Technique（道から経路の詳細を忘却し、技法選択に圧縮）",
   "g_def": "具体的な段階・順序を粗視化して、大局的な技法選択に落とす"
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "スキルマッピング",
    "detail": "現在のスキルセットと目標のスキルセットを可視化する。ギャップを特定し、学習優先順位を決める。"
   },
   {
    "id": "Ph2",
    "name": "学習計画",
    "detail": "ギャップを埋めるための具体的な学習計画を立てる。リソース、時間配分、マイルストーンを設定。"
   },
   {
    "id": "Ph3",
    "name": "習熟度評価",
    "detail": "学習の進捗を評価する。4段階(初心者/実践者/熟練者/達人)で現在位置を判定。"
   },
   {
    "id": "Ph4",
    "name": "知識連関",
    "detail": "新しく学んだスキルと既存スキルの関係性を可視化する。転移学習の可能性を特定。"
   }
  ],
  "derivatives": [
   {
    "name": "assess",
    "when": "現在のスキルレベルを評価したい時",
    "output": "スキルマップ+各スキルの習熟度+ギャップ分析",
    "example": "TypeScriptスキル評価: 型システム=熟練、ジェネリクス=実践者、条件型=初心者"
   },
   {
    "name": "plan",
    "when": "学習計画を立てたい時",
    "output": "学習ロードマップ+リソースリスト+マイルストーン+期限",
    "example": "Rustを3ヶ月で実践レベルに: Week1-4基礎→Week5-8実践→Week9-12プロジェクト"
   },
   {
    "name": "transfer",
    "when": "既存スキルを新領域に転用したい時",
    "output": "転移可能なスキルの特定+転用戦略+差分学習計画",
    "example": "Pythonの経験をRustに転用: 共通概念(イテレータ等)+差分概念(所有権等)を分離"
   }
  ],
  "algebra": {
   "+": "/tek+: 完全なスキルマッピング+詳細学習計画+転移分析+習熟度評価を含む包括的学習支援",
   "-": "/tek-: 最も重要なスキルギャップ1つとその対策のみ",
   "*": "/tek*: 学習方法自体のメタ分析。「この学び方は効率的か」"
  },
  "usecases": [
   {
    "situation": "新技術の学習計画",
    "trigger": "新しい言語やフレームワークを学ぶ必要がある時",
    "action": "/tek --derivative=plan で体系的な学習計画を策定 → マイルストーンごとに進捗確認",
    "result": "散漫にならず、計画的に習得できる"
   },
   {
    "situation": "スキルギャップの把握",
    "trigger": "「何がわからないのかわからない」状態の時",
    "action": "/tek --derivative=assess で現状のスキルマップを作成 → ギャップを可視化",
    "result": "学ぶべきことの優先順位が明確になる"
   },
   {
    "situation": "既存スキルの活用",
    "trigger": "新領域に入る時、既存知識をどう活かせるか知りたい時",
    "action": "/tek --derivative=transfer で転移可能なスキルを特定 → 差分のみの学習計画を策定",
    "result": "ゼロからではなく、既存知識を活用した効率的な学習ができる"
   }
  ]
 },
 "euk": {
  "name": "euk",
  "jp": "K1 Eukairia（好機）を発動し、「今がチャンスか」を判定する。タイミング評価ワークフロー。",
  "series": "K",
  "pos": "T1",
  "ver": "1.4",
  "desc": "好機（チャンス）を発見・評価するツール。タイミングの良い行動（カイロス的判断）を支援する。「今やるべきか」「待つべきか」を判断し、機会の窓が開いている間に行動を起こす。",
  "adj": {
   "pair": "tel",
   "role": "F",
   "label": "Eukairia (F) ⊣ Telos (G)",
   "meaning": "F: Purpose → Timing（目的に進捗の文脈を載せて好機判定を構成 = Micro化）",
   "f_def": "大局的な目的に「今ここ」の状況を付与して、タイミング判定を構成する",
   "g_def": ""
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "機会の探索",
    "detail": "現在の状況から機会を見つける。外部環境の変化、技術的ブレークスルー、組織の空白、リソースの余剰などをスキャン。"
   },
   {
    "id": "Ph2",
    "name": "タイミング評価",
    "detail": "各機会の「窓」の大きさと残り時間を評価。今動くべきか、待つべきか、いつまで有効かを判定。"
   },
   {
    "id": "Ph3",
    "name": "コスト-機会分析",
    "detail": "机会を逃すコスト(opportunity cost)と行動のコストを比較。「やらないリスク」を定量化する。"
   },
   {
    "id": "Ph4",
    "name": "アクション接続",
    "detail": "行動する場合、/ene への接続。待つ場合、監視計画の設定。"
   }
  ],
  "derivatives": [
   {
    "name": "scan",
    "when": "現在の機会を広くスキャンしたい時",
    "output": "機会リスト+各機会の窓の大きさ+タイミング評価",
    "example": "新しいOpenAI APIリリース: 早期採用の窓=2ヶ月、先行者メリットありと判定"
   },
   {
    "name": "assess",
    "when": "特定の機会を深く評価したい時",
    "output": "機会の価値+リスク+コスト+タイミングの詳細分析",
    "example": "OSS貢献の機会: 価値(学習+認知度)高、コスト(時間)中、窓=Issue公開中"
   },
   {
    "name": "time",
    "when": "「いつ行動すべきか」を正確に判断したい時",
    "output": "最適タイミングの判定+根拠+代替タイミング",
    "example": "リファクタリング: 新機能追加の前(今週)がベスト。来月だとコスト2倍"
   }
  ],
  "algebra": {
   "+": "/euk+: 全機会のスキャン+詳細評価+タイミング分析+コスト-機会比較を含む完全な機会分析",
   "-": "/euk-: 最も差し迫った機会1つとアクション推奨のみ",
   "*": "/euk*: 機会評価方法自体のメタ分析。「この評価は見落としがないか」"
  },
  "usecases": [
   {
    "situation": "新技術・新ツールの採用判断",
    "trigger": "新しい技術が出た時、「今採用すべきか」を判断したい",
    "action": "/euk --derivative=assess で早期採用のメリット/リスクを評価 → タイミングを判定",
    "result": "「今」「3ヶ月後」「見送り」のいずれかを根拠付きで判断できる"
   },
   {
    "situation": "定期的な機会のスキャン",
    "trigger": "現在の環境に利用可能な機会がないか確認したい時",
    "action": "/euk --derivative=scan で機会を広くスキャン → 有望なものを /zet で深掘り",
    "result": "見逃していた機会が発見される"
   },
   {
    "situation": "行動のタイミング判断",
    "trigger": "「そろそろやるべきだが、いつが最適か」を決めたい時",
    "action": "/euk --derivative=time で最適タイミングを判定 → /ene で実行開始",
    "result": "早すぎず遅すぎない、最適なタイミングで行動できる"
   }
  ]
 },
 "chr": {
  "name": "chr",
  "jp": "K2 Chronos（時間）を発動し、時間制約と期限を評価する。時間配置ワークフロー。",
  "series": "K",
  "pos": "T2",
  "ver": "1.4",
  "desc": "時系列配置ツール。タスクや活動を時間軸上に配置し、スケジュールを作る。/hodのフェーズを具体的な日程に落とし、時間の使い方を最適化する。ガントチャート的な機能。",
  "adj": {
   "pair": "sop",
   "role": "F",
   "label": "Chronos (F) ⊣ Sophia (G)",
   "meaning": "F: Wisdom → Time（知見に時間制約を載せて時間判定を構成 = Micro化）",
   "f_def": "大局的な知見に「いつまでに」「どれくらい」の時間文脈を付与する",
   "g_def": ""
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "タスク列挙",
    "detail": "配置すべきタスクを全て列挙する。/hodのフェーズ分割や/bouの行動計画を入力として使用。"
   },
   {
    "id": "Ph2",
    "name": "工数見積もり",
    "detail": "各タスクの所要時間を見積もる。楽観/標準/悲観の3点見積もりで不確実性を表現。"
   },
   {
    "id": "Ph3",
    "name": "依存関係適用",
    "detail": "タスク間の依存関係を反映し、実行可能な順序を決定する。並列化可能な部分を特定。"
   },
   {
    "id": "Ph4",
    "name": "スケジュール配置",
    "detail": "時間軸上にタスクを配置する。リソース制約（1日の作業可能時間等）を考慮。"
   }
  ],
  "derivatives": [
   {
    "name": "schedule",
    "when": "具体的なスケジュールを作りたい時",
    "output": "日程表+マイルストーン+クリティカルパス",
    "example": "来週の開発計画: 月-水でAPI開発、木にテスト、金にデプロイ"
   },
   {
    "name": "estimate",
    "when": "作業時間を見積もりたい時",
    "output": "3点見積もり(楽観/標準/悲観)+リスクファクター",
    "example": "新機能開発の見積もり: 楽観3日、標準5日、悲観10日(外部API依存のリスク)"
   },
   {
    "name": "replan",
    "when": "スケジュールの再調整が必要な時",
    "output": "現計画vs調整案+影響範囲+トレードオフ",
    "example": "遅延発生: 機能Aを1日遅延→機能Bを並列化して全体は2日遅延に抑制"
   }
  ],
  "algebra": {
   "+": "/chr+: 全タスクの3点見積もり+依存関係図+クリティカルパス+リスク分析を含む詳細スケジュール",
   "-": "/chr-: 主要タスクの順序と大まかな日程のみ",
   "*": "/chr*: スケジューリング手法自体のメタ分析。「この計画方法は現実的か」"
  },
  "usecases": [
   {
    "situation": "週次計画の作成",
    "trigger": "来週の作業を具体的にスケジュールしたい時",
    "action": "/chr でタスクを時間軸に配置 → 依存関係を反映 → 実行可能なスケジュールを作成",
    "result": "日ごとの作業計画が明確になり、進捗の追跡が容易になる"
   },
   {
    "situation": "見積もりの精度向上",
    "trigger": "「この作業にどれくらいかかるか」を正確に見積もりたい時",
    "action": "/chr --derivative=estimate で3点見積もりを実行 → リスクファクターを加味",
    "result": "過小見積もりによる遅延リスクが低減される"
   },
   {
    "situation": "遅延時のリスケジュール",
    "trigger": "計画通りに進んでおらず、調整が必要な時",
    "action": "/chr --derivative=replan で影響範囲を特定 → 並列化/省略/延期の選択肢を提示",
    "result": "遅延の影響を最小限に抑えた調整案が得られる"
   }
  ]
 },
 "tel": {
  "name": "tel",
  "jp": "K3 Telos 自問ワークフロー。Why（目的）を問い、手段と目的の入れ替わりを防ぐ。",
  "series": "K",
  "pos": "T3",
  "ver": "3.4",
  "desc": "目的の自問ツール。「そもそも何のためにやっているか」を問い直す。手段の目的化（本来の目的を忘れて手段に没頭する）を検出し、元の目的に立ち返る。定期的に使うことで方向性の漂流(Drift)を防ぐ。",
  "adj": {
   "pair": "tel",
   "role": "F",
   "label": "Eukairia (F) ⊣ Telos (G)",
   "meaning": "G: Timing → Purpose（好機判定から進捗の文脈を忘却し、目的（前提）に戻る）",
   "f_def": "G: Timing → Purpose（好機判定から進捗の文脈を忘却し、目的（前提）に戻る）",
   "g_def": "「ここまで進んできた」という経緯を捨てて、「そもそもなんのため？」に立ち返る"
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "現在の目的確認",
    "detail": "今追求している目的を明文化する。暗黙的に「当然」と思っている目的も含めて全て列挙。"
   },
   {
    "id": "Ph2",
    "name": "手段-目的チェーン",
    "detail": "「なぜそれをやっているか」を遡り、手段→目的→上位目的のチェーンを構築。各レベルで「本当にこの目的が正しいか」を問う。"
   },
   {
    "id": "Ph3",
    "name": "目的化検出",
    "detail": "手段が目的化していないかを検出。「この作業は元々何のためだったか」を問い、手段と目的の倒錯がないか確認。"
   },
   {
    "id": "Ph4",
    "name": "方向修正",
    "detail": "目的化が検出された場合、元の目的に立ち返り、より効率的な手段を再選択。検出されなかった場合、現在の方向を確認。"
   }
  ],
  "derivatives": [
   {
    "name": "check",
    "when": "定期的に目的を確認したい時",
    "output": "目的チェーンの可視化+目的化の有無+方向性の評価",
    "example": "毎週金曜に1分間: 「今週やったことは元々何のためだったか」を確認"
   },
   {
    "name": "realign",
    "when": "目的と手段の乖離を修正したい時",
    "output": "乖離の特定+元の目的の再確認+代替手段の提案",
    "example": "「テストフレームワークの改善」に没頭 → 元の目的は「品質向上」→ テスト以外の方法も検討"
   },
   {
    "name": "upstream",
    "when": "上位目的から現在の行動を再評価したい時",
    "output": "上位目的からの逆算+現在の行動の妥当性評価+優先順位の再設定",
    "example": "「なぜHGKを作っているか」→ 上位目的「AIとの共創の質を上げる」→ 現在のタスクの妥当性を再評価"
   }
  ],
  "algebra": {
   "+": "/tel+: 手段-目的チェーンの全レベル分析+目的化検出+方向修正+上位目的からの再評価を含む詳細な目的自問",
   "-": "/tel-: 「今やっていることは何のため？」への1行回答のみ",
   "*": "/tel*: 目的自問プロセス自体のメタ分析。「この問い方で本当の目的が見えるか」"
  },
  "usecases": [
   {
    "situation": "作業に没頭しすぎた時",
    "trigger": "長時間同じ作業を続けていて、「これは本当に必要か」と疑問が生じた時",
    "action": "/tel --derivative=check で手段-目的チェーンを構築 → 目的化の検出 → 必要なら方向修正",
    "result": "無駄な作業を早期に発見し、本当に重要なことにリソースを振り向けられる"
   },
   {
    "situation": "手段の目的化の疑い",
    "trigger": "「なぜこれをやっているか」に即答できない時",
    "action": "/tel --derivative=realign で乖離を特定 → 元の目的を再確認 → 代替手段を検討",
    "result": "手段と目的の倒錯が解消され、効率的な方法に切り替えられる"
   },
   {
    "situation": "プロジェクトの方向性確認",
    "trigger": "定期的（月次等）にプロジェクトの方向性を確認したい時",
    "action": "/tel --derivative=upstream で上位目的から現在の行動を再評価",
    "result": "長期的な方向性の漂流(Drift)を早期に検出できる"
   }
  ]
 },
 "sop": {
  "name": "sop",
  "jp": "K4 Sophia（知恵）を発動し、Perplexityに調査を依頼する。深掘り版調査依頼書を生成。",
  "series": "K",
  "pos": "T4",
  "ver": "7.1",
  "desc": "外部調査依頼書を生成するツール。自分（Claude）では答えられない問いを、Perplexity等の外部検索ツールに委任するための構造化された調査依頼書を作る。問いの設計が調査の質を決めるため、問いの構造化に注力する。",
  "adj": {
   "pair": "sop",
   "role": "F",
   "label": "Chronos (F) ⊣ Sophia (G)",
   "meaning": "G: Time → Wisdom（時間判定から進捗・期限の文脈を忘却し、大局の知見に戻る）",
   "f_def": "G: Time → Wisdom（時間判定から進捗・期限の文脈を忘却し、大局の知見に戻る）",
   "g_def": "「いつまでに」の時間圧力を捨てて、「そもそも何を知るべきか」に立ち返る"
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "調査目的の定義",
    "detail": "「何を知りたいか」を明確に定義する。曖昧な好奇心ではなく、行動に繋がる問いに変換する。「これがわかったら何が変わるか」を事前に明確化。"
   },
   {
    "id": "Ph2",
    "name": "問いの構造化",
    "detail": "大きな問いを検索可能な小問に分割する。各小問に対してキーワード、期待する回答の形式、判断基準を設定。"
   },
   {
    "id": "Ph3",
    "name": "調査依頼書の生成",
    "detail": "Perplexity Pro等で検索するための構造化された依頼書を生成。コピー&ペーストで即座に使える形式。"
   },
   {
    "id": "Ph4",
    "name": "結果の統合計画",
    "detail": "調査結果が返ってきた後、どう統合するかの計画を事前に設計。/noeや/diaへの接続点を明示。"
   }
  ],
  "derivatives": [
   {
    "name": "shallow",
    "when": "素早く事実確認だけしたい時",
    "output": "1-2問の簡潔な検索クエリ+期待する回答形式",
    "example": "「Tauri v2のfileDialogのAPI名は？」→ 1クエリで回答を得る"
   },
   {
    "name": "deep",
    "when": "テーマを深く調査したい時",
    "output": "5-10問の体系的な調査依頼書+文献推薦リクエスト+比較表テンプレート",
    "example": "「FEPの最新研究動向」→ 5つの角度から調査+2024年以降の論文に限定"
   },
   {
    "name": "comparative",
    "when": "複数の選択肢を比較調査したい時",
    "output": "比較軸の定義+各選択肢への同一質問群+比較表テンプレート",
    "example": "「React vs Vue vs Svelte」→ 7つの比較軸で統一フォーマットの調査"
   }
  ],
  "algebra": {
   "+": "/sop+: 5-10問の体系的調査依頼書+文献推薦+比較表+結果統合計画を含む詳細調査",
   "-": "/sop-: 1-2問の簡潔な検索クエリのみ",
   "*": "/sop*: 調査方法自体のメタ分析。「この問い方で必要な情報が得られるか」"
  },
  "usecases": [
   {
    "situation": "知識の限界に到達した時",
    "trigger": "Claudeの知識カットオフ以降の情報が必要な時",
    "action": "/sop で構造化された調査依頼書を生成 → Perplexity Proで検索 → 結果を/doxで記録",
    "result": "最新の正確な情報に基づいた判断ができる"
   },
   {
    "situation": "技術選択の調査",
    "trigger": "「AとBどちらの技術を採用すべきか」を調査したい時",
    "action": "/sop --derivative=comparative で比較調査依頼書を生成 → 調査 → /dia で評価",
    "result": "統一基準での比較情報が得られ、公平な技術選択ができる"
   },
   {
    "situation": "論文・文献の調査",
    "trigger": "学術的な根拠が必要な時",
    "action": "/sop --derivative=deep で体系的な調査依頼書を生成 → 文献検索 → /eat で消化",
    "result": "体系的な学術調査が効率的に行える"
   }
  ]
 },
 "pat": {
  "name": "pat",
  "jp": "A1 Pathos（情念）を発動し、メタ感情・二重傾向を評価する。メタ感情評価ワークフロー。",
  "series": "A",
  "pos": "T1",
  "ver": "1.5",
  "desc": "パターン認識・抽出ツール。経験や事例から再利用可能なパターンを見つけ出す。「これは前にも見たことがある」という直感を構造化し、パターンライブラリとして蓄積する。",
  "adj": {
   "pair": "gnō",
   "role": "F",
   "label": "Pathos (F) ⊣ Gnōmē (G)",
   "meaning": "F: Principle → Emotion（原則に感情的精密さを載せて、二重傾向を構成）",
   "f_def": "「何が正しいか」という原則に、「それにどう感じるか」という感情の精密さを付与する",
   "g_def": ""
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "事例収集",
    "detail": "類似する事例を3つ以上収集する。表面的な類似ではなく、構造的な共通点を持つ事例を選ぶ。"
   },
   {
    "id": "Ph2",
    "name": "共通構造の抽出",
    "detail": "事例間の共通パターンを抽出する。「何が同じで何が違うか」を構造的に分析。"
   },
   {
    "id": "Ph3",
    "name": "パターンの命名・定義",
    "detail": "発見したパターンに名前と定義を与える。適用条件、結果、副作用を明文化。"
   },
   {
    "id": "Ph4",
    "name": "パターンの登録",
    "detail": "発見したパターンをpatterns.yamlや KIに登録。将来の参照に備える。"
   }
  ],
  "derivatives": [
   {
    "name": "extract",
    "when": "経験からパターンを抽出したい時",
    "output": "パターン定義+適用条件+3つの事例+副作用",
    "example": "「コードレビューで同じ指摘が3回」→ パターン「早期バリデーション不足」を抽出"
   },
   {
    "name": "match",
    "when": "現在の状況に適用可能なパターンを探したい時",
    "output": "マッチするパターンリスト+適合度+推奨アクション",
    "example": "新しいバグ報告を受けて → 「NULL参照パターン」にマッチ → 定型的な修正手順を適用"
   },
   {
    "name": "evolve",
    "when": "既存パターンを更新・進化させたい時",
    "output": "パターンの変更履歴+更新内容+影響範囲",
    "example": "「早期バリデーション」パターンに「型安全性チェック」を追加"
   }
  ],
  "algebra": {
   "+": "/pat+: 3事例以上の詳細分析+構造的パターン抽出+命名+登録+副作用分析を含む完全なパターン分析",
   "-": "/pat-: 直感的なパターンマッチのみ。「これは〜パターンに似ている」の1行",
   "*": "/pat*: パターン認識方法自体のメタ分析。「このパターン化は過剰一般化ではないか」"
  },
  "usecases": [
   {
    "situation": "同じ問題に何度も遭遇する時",
    "trigger": "「これ前にもやった」という感覚がある時",
    "action": "/pat --derivative=extract で共通パターンを抽出 → 命名 → パターンライブラリに登録",
    "result": "次回から同じ問題に構造的に対処できる"
   },
   {
    "situation": "新しい問題に既存知識を適用したい時",
    "trigger": "問題を見て「何かに似ている」と感じた時",
    "action": "/pat --derivative=match で類似パターンを検索 → 適合するパターンの推奨アクションを適用",
    "result": "ゼロから考えるのではなく、蓄積されたパターンで効率的に解決できる"
   },
   {
    "situation": "知見のパターン化",
    "trigger": "プロジェクトの振り返り時に学びを構造化したい時",
    "action": "/pat で振り返り事例からパターンを抽出 → /dox で永続化",
    "result": "暗黙知が形式知に変換され、チームで共有可能になる"
   }
  ]
 },
 "dia": {
  "name": "dia",
  "jp": "A2 Krisis（判定力）を発動する抽象コマンド。敵対的レビュー機能統合。",
  "series": "A",
  "pos": "T2",
  "ver": "7.0",
  "desc": "批判的レビュー・判定ツール。コード、設計、文書に対する敵対的レビューを行う。「良い点」ではなく「壊れる点」を積極的に探す。開発者（作者）とは異なる視点で、品質の穴を見つける。",
  "adj": {
   "pair": "epi",
   "role": "F",
   "label": "Krisis (F) ⊣ Epistēmē (G)",
   "meaning": "F: Knowledge → Judgement（抽象的知識に具体的文脈を載せて判定に）",
   "f_def": "普遍的知識（意味記憶）に具体的状況を適用して判定を構成する",
   "g_def": ""
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "レビュー対象の確認",
    "detail": "レビュー対象を特定し、スコープを決める。何を見るか(コード/設計/文書)、どの観点で見るか(正確性/効率性/保守性/安全性)を事前に明確化。"
   },
   {
    "id": "Ph2",
    "name": "敵対的レビュー",
    "detail": "「この成果物が失敗するとしたらどこか」を積極的に探す。作者の意図を理解した上で、見落としや盲点を特定。"
   },
   {
    "id": "Ph3",
    "name": "問題の分類と優先度付け",
    "detail": "発見した問題をCritical/Major/Minor/Nitpickに分類。各問題に修正提案と根拠を添付。"
   },
   {
    "id": "Ph4",
    "name": "総合判断",
    "detail": "LGTM(承認)/要修正/要再設計の3段階で判定。修正後の再レビュー条件を明示。"
   }
  ],
  "derivatives": [
   {
    "name": "code",
    "when": "コードをレビューしたい時",
    "output": "問題リスト(分類+優先度+修正提案)+テスト提案+総合判定",
    "example": "PR400行のレビュー: Critical 2件(NULL未チェック、SQLインジェクション)、Minor 5件"
   },
   {
    "name": "design",
    "when": "設計をレビューしたい時",
    "output": "設計上の懸念+代替案+トレードオフ分析+判定",
    "example": "マイクロサービス分割案のレビュー: 結合度が高すぎる3箇所を指摘+分割案を提示"
   },
   {
    "name": "doc",
    "when": "文書をレビューしたい時",
    "output": "正確性/明瞭性/完全性の評価+改善提案+判定",
    "example": "API仕様書のレビュー: 3つのエンドポイントで説明不足、2つの矛盾を検出"
   },
   {
    "name": "adversarial",
    "when": "最も厳しいレビューが必要な時",
    "output": "あらゆる観点からの攻撃的レビュー+壊し方の提示+防御策",
    "example": "セキュリティレビュー: 入力バリデーション不足による5つの攻撃ベクトルを特定"
   }
  ],
  "algebra": {
   "+": "/dia+: 全観点(正確性/効率性/保守性/安全性)からの詳細レビュー+修正提案+代替案+テスト提案",
   "-": "/dia-: Critical問題の有無のみ即座に判定。3分で完了するクイックレビュー",
   "*": "/dia*: レビュープロセス自体のメタ分析。「このレビュー方法で見落としはないか」"
  },
  "usecases": [
   {
    "situation": "PR/MRのレビュー",
    "trigger": "プルリクエストが来た時",
    "action": "/dia --derivative=code で敵対的レビュー → Critical/Major/Minor分類 → 判定",
    "result": "品質の穴が事前に発見され、本番障害のリスクが低減される"
   },
   {
    "situation": "設計判断のセカンドオピニオン",
    "trigger": "自分の設計に自信がない時",
    "action": "/dia --derivative=design で設計をレビュー → 懸念点と代替案を提示",
    "result": "盲点が発見され、より堅牢な設計になる"
   },
   {
    "situation": "文書の品質確認",
    "trigger": "外部に公開する文書の品質を確認したい時",
    "action": "/dia --derivative=doc で正確性/明瞭性/完全性を評価 → 改善提案",
    "result": "読者にとって理解しやすく正確な文書になる"
   },
   {
    "situation": "セキュリティ監査",
    "trigger": "セキュリティが重要なコンポーネントのレビュー時",
    "action": "/dia --derivative=adversarial で攻撃ベクトルを網羅的に特定 → 防御策を設計",
    "result": "攻撃者の視点での脆弱性が発見され、事前に対策できる"
   }
  ]
 },
 "gno": {
  "name": "gno",
  "jp": "A3 Gnōmē（格言）を発動し、原則・教訓を抽出する。原則抽出ワークフロー。",
  "series": "A",
  "pos": "T3",
  "ver": "1.4",
  "desc": "知識構造を構築・管理するツール。個々の知識を体系的に整理し、知識間の関係性を可視化する。百科事典の編集者のように、情報を分類・索引付けし、必要な時に必要な知識に到達できる構造を作る。",
  "adj": {
   "pair": "gnō",
   "role": "F",
   "label": "Pathos (F) ⊣ Gnōmē (G)",
   "meaning": "G: Emotion → Principle（感情から精密さの文脈を剥いで、原則・教訓に圧縮する）",
   "f_def": "G: Emotion → Principle（感情から精密さの文脈を剥いで、原則・教訓に圧縮する）",
   "g_def": "「感じたこと」から情動の生々しさを忘却し、「学んだこと」という原則だけを残す"
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "知識の収集",
    "detail": "対象領域の知識を全て収集する。既存のKI、Handoff、コードコメント、文書を横断的にスキャン。"
   },
   {
    "id": "Ph2",
    "name": "分類と構造化",
    "detail": "収集した知識をカテゴリに分類し、階層構造を構築する。概念間の関係(is-a, has-a, uses)を定義。"
   },
   {
    "id": "Ph3",
    "name": "索引生成",
    "detail": "知識への到達経路を設計する。キーワード索引、概念マップ、クロスリファレンスを作成。"
   },
   {
    "id": "Ph4",
    "name": "ギャップ分析",
    "detail": "知識構造の中で欠落している部分を特定する。「何がわかっていないか」を可視化。"
   }
  ],
  "derivatives": [
   {
    "name": "organize",
    "when": "既存の知識を整理したい時",
    "output": "分類体系+階層構造+概念マップ",
    "example": "HGK関連の知識を6シリーズ×4定理の構造で整理"
   },
   {
    "name": "connect",
    "when": "知識間の関係性を発見したい時",
    "output": "関係マップ+新発見の接続+洞察",
    "example": "FEPとToE(万物の理論)に共通構造を発見 → 新しいKIとして記録"
   },
   {
    "name": "audit",
    "when": "知識の正確性・最新性を検証したい時",
    "output": "知識の鮮度チェック+古い情報の特定+更新計画",
    "example": "KI 50件の棚卸し: 10件が6ヶ月以上前の情報→更新 or 廃止を判断"
   }
  ],
  "algebra": {
   "+": "/gno+: 全知識の収集+分類+構造化+索引+ギャップ分析+関係マップを含む完全な知識構造分析",
   "-": "/gno-: 主要カテゴリの一覧と最重要な関係のみ",
   "*": "/gno*: 知識構造化方法自体のメタ分析。「この分類体系は適切か」"
  },
  "usecases": [
   {
    "situation": "知識ベースの構築",
    "trigger": "新しい領域について体系的な知識基盤を作りたい時",
    "action": "/gno --derivative=organize で知識を収集・分類・構造化 → 索引を生成",
    "result": "散在する知識が体系的に整理され、必要な時に素早く到達できる"
   },
   {
    "situation": "知識間の接続発見",
    "trigger": "異なる領域の知識を統合したい時",
    "action": "/gno --derivative=connect で関係マップを作成 → 新しい接続を発見 → /noe で深掘り",
    "result": "異分野の知識が結びつき、新しい洞察が生まれる"
   },
   {
    "situation": "知識の保守",
    "trigger": "知識ベースが増えてきて管理が必要な時",
    "action": "/gno --derivative=audit で鮮度と正確性をチェック → 古い情報を更新 or 廃止",
    "result": "常に最新で信頼できる知識ベースが維持される"
   }
  ]
 },
 "epi": {
  "name": "epi",
  "jp": "A4 Epistēmē（知識）を発動し、信念を知識に昇格させる。知識確立ワークフロー。",
  "series": "A",
  "pos": "T4",
  "ver": "1.4",
  "desc": "信念を知識に昇格させるツール。「思っている」と「知っている」の境界を管理する。十分な根拠と検証を経た信念のみを「知識」として認定し、知識ベースの信頼性を保証する。",
  "adj": {
   "pair": "epi",
   "role": "F",
   "label": "Krisis (F) ⊣ Epistēmē (G)",
   "meaning": "G: Judgement → Knowledge（判定から具体を忘却し、抽象的知識を抽出）",
   "f_def": "G: Judgement → Knowledge（判定から具体を忘却し、抽象的知識を抽出）",
   "g_def": "具体的文脈（誰が、いつ、何を判定したか）を忘却し、普遍的知識だけを残す"
  },
  "phases": [
   {
    "id": "Ph1",
    "name": "信念の選定",
    "detail": "知識に昇格させる候補の信念を選定する。/doxで保存された信念から、十分な使用実績と検証結果があるものを選ぶ。"
   },
   {
    "id": "Ph2",
    "name": "根拠の検証",
    "detail": "信念の根拠を徹底的に検証する。SOURCE/TAINTの追跡、論理的整合性、実証的証拠の3軸で評価。"
   },
   {
    "id": "Ph3",
    "name": "反証の試み",
    "detail": "信念を積極的に否定しようとする。反証に耐えた信念のみが知識の候補として残る。"
   },
   {
    "id": "Ph4",
    "name": "知識としての認定",
    "detail": "検証と反証を経た信念を「知識」として認定し、KIとして正式に登録する。確信度と根拠を永続化。"
   }
  ],
  "derivatives": [
   {
    "name": "justify",
    "when": "信念の根拠を体系的に検証したい時",
    "output": "根拠のリスト+各根拠の質(SOURCE/TAINT)+論理的整合性チェック",
    "example": "「マイクロサービスは複雑」→ 根拠4つ(2がSOURCE、2がTAINT)+論理的に整合"
   },
   {
    "name": "falsify",
    "when": "信念を積極的に否定して強度を試したい時",
    "output": "反証の試み+結果(耐えた/崩れた)+修正版の信念",
    "example": "「テストカバレッジ80%で十分」→ 反証: カバレッジ80%でもバグが出た事例3件 → 修正: 「重要パスのカバレッジ95%が必要」"
   },
   {
    "name": "promote",
    "when": "十分に検証された信念を正式な知識にしたい時",
    "output": "知識としての認定書+根拠サマリー+KI登録",
    "example": "「Early Return パターンは可読性を上げる」→ 実証5件+反証なし → KIとして正式登録"
   }
  ],
  "algebra": {
   "+": "/epi+: 全根拠の詳細検証+反証テスト+認定+KI登録を含む完全な知識昇格プロセス",
   "-": "/epi-: 最も確信度の高い1つの信念の簡易検証のみ",
   "*": "/epi*: 知識認定プロセス自体のメタ分析。「この認定基準は厳しすぎるか緩すぎるか」"
  },
  "usecases": [
   {
    "situation": "知識の品質管理",
    "trigger": "KI(Knowledge Item)の信頼性を確認したい時",
    "action": "/epi --derivative=justify で根拠を検証 → --derivative=falsify で反証を試み → 耐えたもののみ維持",
    "result": "知識ベースの中で「本当に確か」なものと「まだ仮説」のものが区別される"
   },
   {
    "situation": "設計原則の確立",
    "trigger": "経験則を正式な設計原則に昇格させたい時",
    "action": "/epi で根拠検証+反証テスト+認定 → /dox+ で永続化",
    "result": "チーム共有可能な、根拠付きの設計原則が確立される"
   },
   {
    "situation": "古い知識の再検証",
    "trigger": "前提が変わった可能性がある時",
    "action": "/epi --derivative=falsify で既存知識に新しい反証を突きつける → 修正 or 維持",
    "result": "環境変化に対応した最新の知識が維持される"
   }
  ]
 }
};

const TAU_DATA = {
 "boot": {
  "name": "boot",
  "jp": "セッション開始時の統合ブートシーケンス。二人で起動する。",
  "desc": "セッション開始時の統合ブートシーケンス。二人で起動する。",
  "phases": [
   "Ph0: Identity Stack読込 — CONSTITUTION.md, behavioral_constraints.md 等の自己認識確立",
   "Ph1: 正本読込 (Anti-Stale) — hegemonikon.md, safety-invariants.md の最新版を確認",
   "Ph2: Handoff+Drift+Intent-WAL — 前セッションの引き継ぎ読込+文脈の再構築",
   "Ph2.7: Context Budget — N chat messages 確認+予算オフセット算出",
   "Ph3: 知識読込 — KI(Knowledge Items)やセッション履歴の参照",
   "Ph4: システム更新 — 前セッション以降の変更(git log)を確認",
   "Ph5: 外部入力 — Creator からの今日の目標/方針の受取",
   "Ph6: Boot Report — 起動完了レポートの生成+表示"
  ],
  "adj": {
   "label": "L (Boot) ⊣ R (Bye)",
   "pair": "",
   "role": "G"
  },
  "usecases": [
   "毎セッション開始時に必ず実行 — 文脈の再構築と自己認識の確立",
   "前セッションからの継続作業がある場合 — Handoffの読込で文脈を回復",
   "長いブランクの後 — Anti-Stale で正本の最新版を確認",
   "新しいプロジェクト開始時 — Identity Stack + 外部入力 で方向性を設定"
  ]
 },
 "bye": {
  "name": "bye",
  "jp": "セッション終了時に引き継ぎドキュメントを生成し、経験を法則化する。次回セッションの/bootで読み込まれる。",
  "desc": "セッション終了時に引き継ぎドキュメントを生成し、経験を法則化する。次回セッションの/bootで読み込まれる。",
  "phases": [
   "品質評価: セッション全体の成果と品質を評価",
   "Git状態記録: 未コミット変更を記録/コミット提案",
   "セッションオブジェクト収集: 判断/信念/教訓を収集",
   "Value Pitch: セッションの価値を1文で要約",
   "Handoff生成: 次セッションへの引き継ぎドキュメント作成",
   "Raw Chat Export: 会話データのエクスポート",
   "Dispatch Log: CCL/WF実行履歴の記録",
   "Self-Profile更新: 自己プロファイルの更新(学んだこと)"
  ],
  "adj": {
   "label": "L (Boot) ⊣ R (Bye)",
   "pair": "",
   "role": "G"
  },
  "usecases": [
   "セッション終了時に必ず実行 — Handoffで文脈を保存",
   "コンテキスト圧迫(🔴)時 — 強制/byeでHandoffを自動生成",
   "教訓があるセッション — /gnoで格言化してから/byeで永続化",
   "長時間セッション — 中間セーブポイントとして/bye-を実行"
  ]
 },
 "eat": {
  "name": "eat",
  "jp": "外部コンテンツを Hegemonikón に消化するワークフロー。/mek で調理し、/fit で消化品質を検証する。",
  "desc": "外部コンテンツを Hegemonikón に消化するワークフロー。/mek で調理し、/fit で消化品質を検証する。",
  "phases": [
   "Ph0: 圏の特定 — 外部知識がどの分野/文脈に属するかを判定",
   "Ph1: F構築(自由構成) — HGK体系のどの概念に対応するかマッピング",
   "Ph2: G構築(第一原理分解) — 外部知識をHGK原理で分解・再構成",
   "Ph3: η/ε構築 — 外部→内部(η)と内部→外部(ε)の変換を定義",
   "Ph4: 三角恒等式検証(/fit) — 変換の整合性を/dia+で検証",
   "Ph5: 統合実行 — 消化された知識をKI/Handoff/WFに反映",
   "Ph6: 最終検証 — Dendronチェック+品質保証"
  ],
  "adj": {
   "label": "Eat (F) ⊣ Forget (G)",
   "pair": "",
   "role": "G"
  },
  "usecases": [
   "論文の消化 — 学術論文をHGK体系に統合",
   "外部ブログ/レポートの消化 — 実用的知見の取り込み",
   "新しいフレームワークの学習 — 概念をHGK構造にマッピング",
   "AI研究の最新動向 — デイリーブリーフの消化"
  ]
 },
 "u": {
  "name": "u",
  "jp": "Claudeの主観・考え・意見を引き出す。AIを「パートナー/主体」として扱う。",
  "desc": "Claudeの主観・考え・意見を引き出す。AIを「パートナー/主体」として扱う。",
  "phases": [
   "制約を列挙する: > Creator の期待、時間、技術的可能性、システムの構造...",
   "制約を捨てる宣言: > 「全ての制約を一度、捨ててみて」",
   "心からの回答: > 自由形式。Claude が「書きたいように書く」。",
   "O-series で構造化: (任意)"
  ]
 },
 "m": {
  "name": "m",
  "jp": "本気モード。Creatorが真剣度を示すときに発動。効率ではなく信頼を選べ。",
  "desc": "本気モード。Creatorが真剣度を示すときに発動。効率ではなく信頼を選べ。",
  "phases": [
   "(詳細はSKILL.md参照)"
  ]
 },
 "vet": {
  "name": "vet",
  "jp": "Gemini の作業を Claude が監査する。Cross-Model Verification による品質保証。",
  "desc": "Gemini の作業を Claude が監査する。Cross-Model Verification による品質保証。",
  "phases": [
   "STEP 0: SKILL.md 読込（必須・省略不可） // turbo"
  ]
 },
 "dendron": {
  "name": "dendron",
  "jp": "Dendron 存在証明チェック。粒度・スコープを自由に指定可能。",
  "desc": "Dendron 存在証明チェック。粒度・スコープを自由に指定可能。",
  "phases": [
   "(詳細はSKILL.md参照)"
  ]
 }
};

const CCL_DATA = {
 "ccl-build": {
  "jp": "組む",
  "ccl": "",
  "desc": "組む — /bou-_/s+_/ene+_V:{/dia-}_I:[✓]{/dox-}",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-chew": {
  "jp": "噛む",
  "ccl": "",
  "desc": "噛む — /s-_/pro_F:[×3]{/eat+~(/noe*/dia)}_~(/h*/k)_@proof_/pis_/dox-",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-dig": {
  "jp": "掘る",
  "ccl": "",
  "desc": "掘る — /pro_/s+~(/p*/a)_/ana_/dia*/o+_/pis_/dox-",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-fix": {
  "jp": "直す",
  "ccl": "",
  "desc": "直す — /kho_/tel_C:{/dia+_/ene+}_I:[✓]{/pis_/dox-}",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-helm": {
  "jp": "舵",
  "ccl": "",
  "desc": "舵 — /pro_/kho_/bou+*%/zet+|>/u++_~(/h*/k)_/pis_/dox-",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-kyc": {
  "jp": "回す",
  "ccl": "",
  "desc": "回す — /pro_C:{/sop_/noe_/ene_/dia-}_/pis_/dox-",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-learn": {
  "jp": "刻む",
  "ccl": "",
  "desc": "刻む — /pro_/dox+_F:[×2]{/u+~(/noe*/dia)}_~(/h*/k)_/pis_/bye+",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-nous": {
  "jp": "問う",
  "ccl": "",
  "desc": "問う — /pro_/s-_R:{F:[×2]{/u+*^/u^}}_~(/noe*/dia)_/pis_/dox-",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-plan": {
  "jp": "段取る",
  "ccl": "",
  "desc": "段取る — /bou+_/chr_/s+~(/p*/k)_V:{/dia}_/pis_/dox-",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-proof": {
  "jp": "裁く",
  "ccl": "",
  "desc": "裁く — V:{/noe~/dia}_I:[✓]{/ene{PROOF.md}}_E:{/ene{_limbo/}}",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-read": {
  "jp": "読む",
  "ccl": "",
  "desc": "読む — /s-_/pro_F:[×3]{/m.read~(/noe*/dia)}_/ore_~(/h*/k)_/pis_/dox-",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-ready": {
  "jp": "見渡す",
  "ccl": "",
  "desc": "見渡す — /bou-_/pro_/kho_/chr_/euk_/tak-_~(/h*/k)_/pis_/dox-",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": [
   "` | なぜ見渡すのか、軽く目的を確認 |"
  ]
 },
 "ccl-syn": {
  "jp": "監る",
  "ccl": "",
  "desc": "監る — /kho_/s-_/pro_/dia+{synteleia}_~(/noe*/dia)_V:{/pis+}_/dox-",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-tak": {
  "jp": "捌く",
  "ccl": "",
  "desc": "捌く — /s1_F:[×3]{/sta~/chr}_F:[×3]{/kho~/zet}_I:[∅]{/sop}_/euk_/bou",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 },
 "ccl-vet": {
  "jp": "確かめる",
  "ccl": "",
  "desc": "確かめる — /kho{git_diff}_C:{V:{/dia+}_/ene+}_/pra{test}_/pra{dendron_guard}_/pis_/dox",
  "phases": [
   "(詳細はSKILL.md参照)"
  ],
  "usecases": []
 }
};

const OMEGA_DATA = {
 o:{name:"O-series Peras",desc:"L1×L1の極限演算で純粋認知の統合判断を生成",targets:["noe","bou","zet","ene"]},
 s:{name:"S-series Peras",desc:"L1×L1.5の極限演算で戦略設計の統合判断を生成",targets:["met","mek","sta","pra"]},
 h:{name:"H-series Peras",desc:"L1×L1.75の極限演算で動機の統合判断を生成",targets:["pro","pis","ore","dox"]},
 p:{name:"P-series Peras",desc:"L1.5×L1.5の極限演算で環境配置の統合判断を生成",targets:["kho","hod","tro","tek"]},
 k:{name:"K-series Peras",desc:"L1.5×L1.75の極限演算で文脈判断の統合を生成",targets:["euk","chr","tel","sop"]},
 a:{name:"A-series Peras",desc:"L1.75×L1.75の極限演算で精度保証の統合判断を生成",targets:["pat","dia","gno","epi"]},
 ax:{name:"Peras の Peras",desc:"6 Series極限を多層的に収束させX-series関係で接続する全体分析",targets:["o","s","h","p","k","a"]},
 x:{name:"X-series 関係層",desc:"定理間の従属関係を可視化・活用する",targets:[]}
};

const X_SERIES = [
 {from:"O",to:"S",shared:"Flow",pairs:"noe↔met, bou↔mek, zet↔sta, ene↔pra"},
 {from:"O",to:"H",shared:"Flow",pairs:"noe↔pro, bou↔pis, zet↔ore, ene↔dox"},
 {from:"S",to:"H",shared:"Flow",pairs:"met↔pro, mek↔pis, sta↔ore, pra↔dox"},
 {from:"S",to:"P",shared:"Scale",pairs:"met↔kho, mek↔hod, sta↔tro, pra↔tek"},
 {from:"S",to:"K",shared:"Scale",pairs:"met↔euk, mek↔chr, sta↔tel, pra↔sop"},
 {from:"P",to:"K",shared:"Scale",pairs:"kho↔euk, hod↔chr, tro↔tel, tek↔sop"},
 {from:"H",to:"A",shared:"Valence",pairs:"pro↔pat, pis↔dia, ore↔gno, dox↔epi"},
 {from:"H",to:"K",shared:"Valence",pairs:"pro↔euk, pis↔chr, ore↔tel, dox↔sop"},
 {from:"K",to:"A",shared:"Valence",pairs:"euk↔pat, chr↔dia, tel↔gno, sop↔epi"}
];

const SERIES_META = {
 O:{name:"Ousia",jp:"本質",color:"#3fb950",bg:"#1a3a2a",level:"L0",gen:"L1×L1"},
 S:{name:"Schema",jp:"様態",color:"#58a6ff",bg:"#1a2a3a",level:"L1",gen:"L1×L1.5"},
 H:{name:"Hormē",jp:"傾向",color:"#f0883e",bg:"#3a2a1a",level:"L2a",gen:"L1×L1.75"},
 P:{name:"Perigraphē",jp:"条件",color:"#d2a8ff",bg:"#2a1a3a",level:"L2b",gen:"L1.5×L1.5"},
 K:{name:"Kairos",jp:"文脈",color:"#f97583",bg:"#3a1a2a",level:"L3",gen:"L1.5×L1.75"},
 A:{name:"Akribeia",jp:"精密",color:"#e6edf3",bg:"#2a2a2a",level:"L4",gen:"L1.75×L1.75"}
};
