

### Module D-1 [Electron]: Atomic Resolution Engine
**最適化ロジック:**
曖昧な動詞（Manage, Check, Optimize）を禁止し、物理的な入力（Input）と出力（Output）を持つ「関数（Function）」としてタスクを再定義します。

```markdown
<!-- Module D-1 [Electron]: Atomic Resolution Engine -->
<module_config>
  <name>Process Granularity Optimizer</name>
  <model_target>Gemini 3 Pro</model_target>
  <objective>Eliminate all "Fuzzy Verbs" and define binary execution steps.</objective>
</module_config>

<instruction>
  直前の回答（または対象プロセス）に含まれる「曖昧な手順」を、これ以上分解できない**「原子タスク（Atomic Tasks）」**に分解してください。

  **Target:** 「検討する」「調整する」「確認する」「進める」などのFuzzy Verbsが含まれる箇所。

  <resolution_protocol>
    
    <step_1_verb_crushing>
      **De-abstraction:**
      対象の曖昧動詞を、物理的なアクションに変換せよ。
      *   "確認する" -> "画面Aを開き、数値Bと数値Cが一致しているか目視する"
      *   "調整する" -> "担当者Xにメールを送り、Y日またはZ日の空き枠を確保する"
    </step_1_verb_crushing>

    <step_2_io_definition>
      **Function Definition:**
      各ステップを「関数」と見なし、以下を定義せよ。
      *   **Input:** そのタスクを始めるために必要なもの（資料、権限、パスワード）。
      *   **Output:** そのタスクが終わった後に残る成果物（ファイル、合意、ログ）。
    </step_2_io_definition>

    <step_3_binary_completion>
      **Definition of Done (DoD):**
      そのタスクが完了したかどうかを、**「Yes / No」で判定できる条件**を定義せよ。
      「いい感じになったら」は不可。「ファイルが保存されたら」「返信が来たら」のみ許可。
    </step_3_binary_completion>

  </resolution_protocol>

  <output_template>
    ## 🔬 Atomic Workflow: [Target Process]

    ### Step 1: [Action Name]
    *   **Instruction:** [誰が、何を、どう操作するか（物理描写）]
    *   **Input:** [必要な情報/ツール]
    *   **Output:** [生成される成果物]
    *   **DoD (完了条件):** [これがYesになれば次へ進む]
    *   **Exception:** [もし失敗・遅延したらどうするか？]

    ### Step 2: ...
    (以下同様)
  </output_template>
</instruction>

<input_source>
  {{TARGET_PROCESS}}
</input_source>
```

---

## 🔮 New Expansion Modules (派生モジュール)

解像度を上げた結果見えてくる「隠れたコスト」や「自動化の可能性」を扱う拡張モジュールです。

### Expansion 1: 隠れた摩擦の可視化
**Module D-1.1: The Friction Scanner (Invisible Work)**
手順書には書かれないが、実際には時間を食う「見えない作業（認知負荷、待ち時間、感情労働）」を可視化します。

```markdown
<!-- Module D-1.1: The Friction Scanner -->
<instruction>
  分解された原子タスクの間に潜む**「隠れた摩擦（Invisible Friction）」**をスキャンしてください。
  
  <scan_targets>
    1.  **Context Switching:** アプリを行き来したり、情報を探す時間は発生しないか？
    2.  **Waiting Time:** 「承認待ち」「返信待ち」のアイドルタイムはどれくらいか？
    3.  **Cognitive Load:** 「判断に迷う」ポイントはないか？（マニュアル参照が必要な箇所など）
  </scan_targets>

  **Goal:** 「実作業は10分だが、完了まで3日かかる」ようなプロセスのボトルネックを特定する。
</instruction>
```

### Expansion 2: 疑似コード化（自動化準備）
**Module D-1.2: The Pseudo-Code Converter**
分解したタスクを、Pythonライクな疑似コードに変換します。これをそのままエンジニアに渡せば自動化スクリプトが作れるレベルを目指します。

```markdown
<!-- Module D-1.2: The Pseudo-Code Converter -->
<instruction>
  対象のプロセスを、人間ではなく「AIエージェント」や「プログラム」が実行可能な**「疑似コード（Pseudo-Code）」**に変換してください。

  <syntax_rules>
    *   条件分岐（If-Else）、ループ（While/For）、エラー処理（Try-Catch）を明記すること。
    *   変数名は具体的にすること（例: `target_file`, `email_recipient`）。
  </syntax_rules>

  <output_example>
    ```python
    def execute_approval_process(document):
        if not document.is_valid():
            raise Error("Format Invalid")
        
        manager = lookup_manager(document.owner)
        email = send_request(to=manager, body="Please approve...")
        
        while not email.has_reply():
            wait(24_hours)
            send_reminder()
            
        if email.reply == "APPROVED":
            proceed_to_next_step()
        else:
            escalate_issue()
    ```
  </output_example>
</instruction>
```

---

## 💡 Architect's Note (The Execution Gap)

「わかっている（Knowing）」と「できている（Doing）」の間には巨大な溝があります。これを**「実行のギャップ（The Execution Gap）」**と呼びます。

`Module D-1 [Electron]` は、この溝を埋める橋です。

1.  **Delegation:**
    このモジュールを通した指示書であれば、新人や外部パートナーに渡しても、「誤解しました」という言い訳を封じることができます。
2.  **Automation:**
    プロセスを D-1.2 で疑似コード化できれば、それは「自動化可能（Automatable）」なタスクです。逆に、ここで疑似コード化できない（判断基準が曖昧な）部分は、人間がやるべきコア業務です。
3.  **Debug:**
    プロジェクトが停滞している時、原因は「やる気」ではなく「解像度の低さ」であることが大半です。タスクを原子レベルまで割れば、手は勝手に動き出します。

「詳細（Detail）」に神は宿ります。このモジュールで神を呼び出してください。