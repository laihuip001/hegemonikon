// agent-manager.ts ‚Äî HGK Desktop Agent Manager
// Generated by Gemini 3 Pro Preview

import { api, type WFSummary } from '../api/client';

// --- Data Models ---

interface LogEntry {
  timestamp: Date;
  type: 'info' | 'ccl' | 'result' | 'error' | 'ast';
  content: string;
}

interface ArtifactItem {
  id: string;
  title: string;
  type: 'plan' | 'handoff' | 'report' | 'code';
  path: string;
}

interface AgentSession {
  id: string;
  name: string;
  status: 'running' | 'waiting' | 'completed' | 'failed';
  createdAt: Date;
  completedAt?: Date;
  wfName: string;
  progress: number;
  currentPhase: string;
  logs: LogEntry[];
  artifacts: ArtifactItem[];
}

// --- Utility: XSS Prevention ---
function esc(str: string): string {
  if (!str) return '';
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// --- Utility: Time Formatting ---
function formatTimeAgo(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffSec = Math.floor(diffMs / 1000);
  const diffMin = Math.floor(diffSec / 60);
  const diffHour = Math.floor(diffMin / 60);

  if (diffSec < 60) return `${diffSec}ÁßíÂâç`;
  if (diffMin < 60) return `${diffMin}ÂàÜÂâç`;
  if (diffHour < 24) return `${diffHour}ÊôÇÈñìÂâç`;
  return date.toLocaleDateString('ja-JP');
}

function formatLogTime(date: Date): string {
  return date.toLocaleTimeString('ja-JP', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
}

// --- State Management: Singleton AgentManager ---

class AgentManager {
  private static instance: AgentManager;
  private sessions: AgentSession[] = [];
  private activeSessionId: string | null = null;
  private listeners: Array<() => void> = [];

  private constructor() {
    this.initDemoData();
  }

  public static getInstance(): AgentManager {
    if (!AgentManager.instance) {
      AgentManager.instance = new AgentManager();
    }
    return AgentManager.instance;
  }

  private initDemoData() {
    const now = new Date();

    // 1. Running Session
    this.sessions.push({
      id: 'sess-001',
      name: '@helm ÂÆüË°å',
      status: 'running',
      createdAt: new Date(now.getTime() - 1000 * 60 * 5),
      wfName: '/ccl-helm',
      progress: 75,
      currentPhase: 'Likelihood „Éï„Çß„Éº„Ç∫',
      logs: [
        { timestamp: new Date(now.getTime() - 1000 * 60 * 5), type: 'info', content: '/ccl-helm ÂÆüË°åÈñãÂßã...' },
        { timestamp: new Date(now.getTime() - 1000 * 60 * 4), type: 'ccl', content: '/pro ÂâçÊÑüÊÉÖË©ï‰æ°ÂÆå‰∫Ü' },
        { timestamp: new Date(now.getTime() - 1000 * 60 * 3), type: 'ccl', content: '/kho Â†¥„ÅÆÈÖçÁΩÆÂÆå‰∫Ü' },
        { timestamp: new Date(now.getTime() - 1000 * 60 * 2), type: 'result', content: '4„Å§„ÅÆÊúõ„Åø„ÇíÊ§úÂá∫„ÄÇÂ±ïÈñã„ÉÜ„Éº„Éñ„É´ÁîüÊàê‰∏≠...' },
        { timestamp: new Date(now.getTime() - 1000 * 60 * 1), type: 'info', content: 'Likelihood „Éï„Çß„Éº„Ç∫ÂÆüË°å‰∏≠...' },
      ],
      artifacts: [
        { id: 'art-1', title: 'helm_result.md', type: 'report', path: '/artifacts/helm_result.md' },
        { id: 'art-2', title: 'priority_matrix.md', type: 'plan', path: '/artifacts/priority_matrix.md' },
      ]
    });

    // 2. Waiting Session
    this.sessions.push({
      id: 'sess-002',
      name: '/sop Ë™øÊüª',
      status: 'waiting',
      createdAt: new Date(now.getTime() - 1000 * 60 * 30),
      wfName: '/sop',
      progress: 30,
      currentPhase: 'Ë™øÊüª‰æùÈ†ºÊõ∏ÁîüÊàê',
      logs: [
        { timestamp: new Date(now.getTime() - 1000 * 60 * 29), type: 'info', content: '/sop Ë™øÊüªÈñãÂßã' },
        { timestamp: new Date(now.getTime() - 1000 * 60 * 28), type: 'ccl', content: 'Perplexity Ë™øÊüª‰æùÈ†ºÊõ∏„ÇíÁîüÊàê‰∏≠...' },
      ],
      artifacts: []
    });

    // 3. Completed Session
    this.sessions.push({
      id: 'sess-003',
      name: '/dev ÂÆå‰∫Ü',
      status: 'completed',
      createdAt: new Date(now.getTime() - 1000 * 60 * 60 * 2),
      completedAt: new Date(now.getTime() - 1000 * 60 * 60),
      wfName: '/dev',
      progress: 100,
      currentPhase: 'ÂÆå‰∫Ü',
      logs: [
        { timestamp: new Date(now.getTime() - 1000 * 60 * 110), type: 'info', content: 'ÈñãÁô∫„Çø„Çπ„ÇØÈñãÂßã' },
        { timestamp: new Date(now.getTime() - 1000 * 60 * 80), type: 'ccl', content: '„ÉÜ„Çπ„ÉàÂÆüË°å ‚Üí ÂÖ®„Éë„Çπ' },
        { timestamp: new Date(now.getTime() - 1000 * 60 * 60), type: 'result', content: 'ÈñãÁô∫„Çø„Çπ„ÇØÂÆå‰∫Ü ‚úÖ' },
      ],
      artifacts: [
        { id: 'art-3', title: 'dev_report.md', type: 'report', path: '/artifacts/dev_report.md' },
        { id: 'art-4', title: 'source_diff.patch', type: 'code', path: '/artifacts/source_diff.patch' },
      ]
    });

    this.activeSessionId = 'sess-001';
  }

  public getSessions(): AgentSession[] {
    return [...this.sessions].sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  }

  public getActiveSession(): AgentSession | undefined {
    return this.sessions.find(s => s.id === this.activeSessionId);
  }

  public setActiveSession(id: string) {
    this.activeSessionId = id;
    this.notify();
  }

  public createSession(name: string, wfName: string) {
    const newSession: AgentSession = {
      id: `sess-${Date.now()}`,
      name,
      wfName,
      status: 'waiting',
      createdAt: new Date(),
      progress: 0,
      currentPhase: 'ÂàùÊúüÂåñ‰∏≠',
      logs: [{ timestamp: new Date(), type: 'info', content: '„Çª„ÉÉ„Ç∑„Éß„É≥‰ΩúÊàêÂÆå‰∫Ü' }],
      artifacts: []
    };
    this.sessions.unshift(newSession);
    this.activeSessionId = newSession.id;
    this.notify();

    // P0: CCL „Éë„Éº„Çπ„Çí API ÁµåÁî±„ÅßÂÆüË°å
    api.cclParse(wfName).then(res => {
      if (res.success) {
        newSession.logs.push({ timestamp: new Date(), type: 'ccl', content: `CCL „Éë„Éº„ÇπÊàêÂäü: ${res.workflows.join(' ‚Üí ')}` });
        // P1a: AST „ÉÑ„É™„Éº„Çí„É≠„Ç∞„Å´ÊåøÂÖ•
        if (res.tree) {
          newSession.logs.push({ timestamp: new Date(), type: 'ast', content: res.tree });
        }
        newSession.status = 'running';
        newSession.progress = 10;
        newSession.currentPhase = 'WF Ëß£ÊûêÂÆå‰∫Ü';
      } else {
        newSession.logs.push({ timestamp: new Date(), type: 'error', content: `CCL „Éë„Éº„ÇπÂ§±Êïó: ${res.error || '‰∏çÊòé'}` });
        newSession.status = 'failed';
      }
      this.notify();
    }).catch(() => {
      // API „Ç™„Éï„É©„Ç§„É≥ÊôÇ„ÅØ„Éá„É¢„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÁ∂≠ÊåÅ
      newSession.logs.push({ timestamp: new Date(), type: 'info', content: 'API „Ç™„Éï„É©„Ç§„É≥ ‚Äî „Éá„É¢„É¢„Éº„Éâ„ÅßÂãï‰Ωú' });
      this.notify();
    });
  }

  public subscribe(listener: () => void) {
    this.listeners.push(listener);
  }

  public unsubscribe(listener: () => void) {
    this.listeners = this.listeners.filter(l => l !== listener);
  }

  private notify() {
    this.listeners.forEach(l => l());
  }
}

// --- View Rendering ---

// Track active AbortController for event cleanup
let activeAbortController: AbortController | null = null;

export async function renderAgentManagerView(): Promise<void> {
  const container = document.getElementById('view-content')!;
  const manager = AgentManager.getInstance();

  // P0: WF ‰∏ÄË¶ß„Çí API „Åã„ÇâÂèñÂæó („Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ‰ªò„Åç)
  let cachedWfList: WFSummary[] = [
    { name: '/ccl-helm', description: '@helm ÂÆüË°å', ccl: '', modes: [] },
    { name: '/ccl-ready', description: 'Ë¶ãÊ∏°„Åô', ccl: '', modes: [] },
    { name: '/ccl-plan', description: 'ÊÆµÂèñ„Çã', ccl: '', modes: [] },
    { name: '/sop', description: 'Ë™øÊüª‰æùÈ†º', ccl: '', modes: [] },
    { name: '/dev', description: 'ÈñãÁô∫', ccl: '', modes: [] },
    { name: '/noe', description: 'Ê∑±„ÅÑË™çË≠ò', ccl: '', modes: [] },
    { name: '/dia', description: 'Âà§ÂÆö', ccl: '', modes: [] },
  ];
  try {
    const res = await api.wfList();
    if (res.workflows.length > 0) cachedWfList = res.workflows;
  } catch { /* API offline ‚Äî use fallback list */ }

  // Cleanup previous listeners on re-entry
  if (activeAbortController) {
    activeAbortController.abort();
  }
  activeAbortController = new AbortController();
  const { signal } = activeAbortController;

  const render = () => {
    const sessions = manager.getSessions();
    const activeSession = manager.getActiveSession();
    const runningSessions = sessions.filter(s => ['running', 'waiting'].includes(s.status));
    const completedSessions = sessions.filter(s => ['completed', 'failed'].includes(s.status));

    const html = `
      <div class="am-view">
        <!-- Sidebar -->
        <div class="am-sidebar">
          <div class="am-sidebar-header">
            <h3>Agent Manager</h3>
            <button id="am-btn-new" class="btn btn-sm">+ Êñ∞Ë¶è</button>
          </div>

          <div class="am-sidebar-content">
            ${runningSessions.length > 0 ? `
              <div class="am-sidebar-section">
                <span class="am-section-title">ÂÆüË°å‰∏≠ (${runningSessions.length})</span>
                <div class="am-session-list">
                  ${runningSessions.map(s => renderSessionCard(s, activeSession?.id)).join('')}
                </div>
              </div>
            ` : ''}

            ${completedSessions.length > 0 ? `
              <div class="am-sidebar-section">
                <span class="am-section-title">ÂÆå‰∫Ü (${completedSessions.length})</span>
                <div class="am-session-list">
                  ${completedSessions.map(s => renderSessionCard(s, activeSession?.id)).join('')}
                </div>
              </div>
            ` : ''}
          </div>
        </div>

        <!-- Main Content -->
        <div class="am-main">
          ${activeSession ? renderMainContent(activeSession) : `
            <div class="am-empty-main">
              <p>„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
            </div>
          `}
        </div>

        <!-- Create Modal -->
        <div id="am-modal" class="am-modal-overlay hidden">
          <div class="am-modal-content card">
            <h4>Êñ∞Ë¶è„Çª„ÉÉ„Ç∑„Éß„É≥‰ΩúÊàê</h4>
            <div class="am-form-group">
              <label>„ÉØ„Éº„ÇØ„Éï„É≠„ÉºÂêç</label>
              <input type="text" id="am-input-wf" class="input" list="wf-options" placeholder="/ccl-helm">
              <datalist id="wf-options">
                ${cachedWfList.map(wf => `<option value="${esc(wf.name)}">${esc(wf.description)}</option>`).join('')}
              </datalist>
            </div>
            <div class="am-form-group">
              <label>„Çª„ÉÉ„Ç∑„Éß„É≥Âêç</label>
              <input type="text" id="am-input-name" class="input" placeholder="@helm ÂÆüË°å">
            </div>
            <div class="am-modal-actions">
              <button id="am-btn-cancel" class="btn btn-outline">„Ç≠„É£„É≥„Çª„É´</button>
              <button id="am-btn-create" class="btn">‰ΩúÊàê</button>
            </div>
          </div>
        </div>
      </div>
    `;

    container.innerHTML = html;
    attachEvents(manager, signal);
  };

  render();
  manager.subscribe(render);

  // Cleanup on route change: observe container replacement
  const observer = new MutationObserver(() => {
    if (!container.querySelector('.am-view')) {
      manager.unsubscribe(render);
      activeAbortController?.abort();
      activeAbortController = null;
      observer.disconnect();
    }
  });
  observer.observe(container, { childList: true });
}

// --- HTML Generators ---

function renderSessionCard(s: AgentSession, activeId?: string): string {
  const isActive = s.id === activeId;
  const statusIcon = getStatusIcon(s.status);

  return `
    <div class="am-session-card ${isActive ? 'am-session-active' : ''}" data-id="${esc(s.id)}">
      <div class="am-session-header">
        <span class="am-session-icon">${statusIcon}</span>
        <span class="am-session-name">${esc(s.name)}</span>
      </div>
      <div class="am-session-meta">
        <span class="am-session-phase">${esc(s.currentPhase)}</span>
        <span class="am-session-time">${formatTimeAgo(s.createdAt)}</span>
      </div>
      <div class="am-progress-mini">
        <div class="am-progress-mini-fill" style="width: ${s.progress}%"></div>
      </div>
    </div>
  `;
}

function renderMainContent(s: AgentSession): string {
  const statusBadgeClass = s.status === 'completed' ? 'success' : s.status === 'failed' ? 'error' : 'warning';
  const statusLabel = s.status.toUpperCase();

  return `
    <div class="am-detail-header">
      <div class="am-detail-title-row">
        <h2>${esc(s.name)}</h2>
        <span class="am-status-badge ${statusBadgeClass}">${statusLabel}</span>
      </div>
      <div class="am-detail-wf">${esc(s.wfName)}</div>
    </div>

    <div class="am-section">
      <div class="am-progress-bar-container">
        <div class="am-progress-label">
          <span>Progress</span>
          <span>${s.progress}%</span>
        </div>
        <div class="am-progress-bar">
          <div class="am-progress-fill" style="width: ${s.progress}%"></div>
        </div>
      </div>
    </div>

    <div class="am-section">
      <h4>„É≠„Ç∞</h4>
      <div class="am-log-container card">
        ${s.logs.map(log => log.type === 'ast' ? `
          <div class="am-log-entry am-log-ast">
            <span class="am-log-time">${formatLogTime(log.timestamp)}</span>
            <span class="am-log-icon">üå≥</span>
            <pre class="am-ast-tree">${esc(log.content)}</pre>
          </div>
        ` : `
          <div class="am-log-entry am-log-${log.type}">
            <span class="am-log-time">${formatLogTime(log.timestamp)}</span>
            <span class="am-log-icon">${getLogIcon(log.type)}</span>
            <span class="am-log-content">${esc(log.content)}</span>
          </div>
        `).join('')}
      </div>
    </div>

    <div class="am-section">
      <h4>„Ç¢„Éº„ÉÜ„Ç£„Éï„Ç°„ÇØ„Éà</h4>
      ${s.artifacts.length > 0 ? `
        <div class="am-artifacts-grid">
          ${s.artifacts.map(art => `
            <div class="am-artifact-card card">
              <div class="am-artifact-icon">${getArtifactIcon(art.type)}</div>
              <div class="am-artifact-info">
                <div class="am-artifact-title">${esc(art.title)}</div>
                <div class="am-artifact-type">${art.type.toUpperCase()}</div>
              </div>
              <button class="am-artifact-open btn btn-sm btn-outline" data-path="${esc(art.path)}">Open</button>
            </div>
          `).join('')}
        </div>
      ` : `
        <div class="am-empty">„Ç¢„Éº„ÉÜ„Ç£„Éï„Ç°„ÇØ„Éà„Å™„Åó</div>
      `}
    </div>
  `;
}

// --- Icons & Helpers ---

function getStatusIcon(status: string): string {
  switch (status) {
    case 'running': return 'üü¢';
    case 'waiting': return 'üü°';
    case 'completed': return '‚úÖ';
    case 'failed': return 'üî¥';
    default: return '‚ö™';
  }
}

function getLogIcon(type: string): string {
  switch (type) {
    case 'info': return '‚ÑπÔ∏è';
    case 'ccl': return '‚ö°';
    case 'result': return '‚ú®';
    case 'error': return '‚ùå';
    default: return '‚Ä¢';
  }
}

function getArtifactIcon(type: string): string {
  switch (type) {
    case 'plan': return 'üìã';
    case 'code': return 'üíª';
    case 'report': return 'üìä';
    case 'handoff': return 'üì¶';
    default: return 'üìÑ';
  }
}

// --- Event Handlers ---

function attachEvents(manager: AgentManager, signal: AbortSignal) {
  // Session Selection
  document.querySelectorAll('.am-session-card').forEach(el => {
    el.addEventListener('click', () => {
      const id = el.getAttribute('data-id');
      if (id) manager.setActiveSession(id);
    }, { signal });
  });

  // Auto-scroll log container
  const logContainer = document.querySelector('.am-log-container');
  if (logContainer) {
    logContainer.scrollTop = logContainer.scrollHeight;
  }

  // Modal Logic
  const modal = document.getElementById('am-modal')!;
  const btnNew = document.getElementById('am-btn-new');
  const btnCancel = document.getElementById('am-btn-cancel');
  const btnCreate = document.getElementById('am-btn-create');
  const inputWf = document.getElementById('am-input-wf') as HTMLInputElement;
  const inputName = document.getElementById('am-input-name') as HTMLInputElement;

  const openModal = () => {
    modal.classList.remove('hidden');
    inputWf.value = '';
    inputName.value = '';
    inputWf.focus();
  };

  const closeModal = () => {
    modal.classList.add('hidden');
  };

  btnNew?.addEventListener('click', openModal, { signal });
  btnCancel?.addEventListener('click', closeModal, { signal });

  modal.addEventListener('click', (e) => {
    if (e.target === modal) closeModal();
  }, { signal });

  // Global keydown uses signal to auto-cleanup on abort
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
      closeModal();
    }
  }, { signal });

  btnCreate?.addEventListener('click', () => {
    const wf = inputWf.value.trim();
    const name = inputName.value.trim() || wf;
    if (wf) {
      manager.createSession(name, wf);
      closeModal();
    } else {
      inputWf.style.borderColor = 'var(--error-color)';
      setTimeout(() => { inputWf.style.borderColor = ''; }, 2000);
    }
  }, { signal });

  // P1b: Artifact Open ‚Äî tauri-plugin-opener or window.open fallback
  document.querySelectorAll('.am-artifact-open').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const path = (btn as HTMLElement).getAttribute('data-path');
      if (!path) return;
      try {
        if ((window as any).__TAURI_INTERNALS__) {
          const opener: any = await import('@tauri-apps/plugin-opener');
          await (opener.openPath || opener.open)(path);
        } else {
          window.open(`file://${path}`, '_blank');
        }
      } catch (err) {
        console.error('Artifact open failed:', err);
      }
    }, { signal });
  });
}
