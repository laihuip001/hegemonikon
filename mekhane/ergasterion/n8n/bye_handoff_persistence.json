{
    "name": "WF-02: Bye Handoff Persistence",
    "nodes": [
        {
            "parameters": {
                "httpMethod": "POST",
                "path": "bye-handoff",
                "responseMode": "lastNode",
                "options": {}
            },
            "id": "webhook",
            "name": "Webhook Trigger",
            "type": "n8n-nodes-base.webhook",
            "typeVersion": 1,
            "position": [
                250,
                300
            ],
            "webhookId": "bye-handoff"
        },
        {
            "parameters": {
                "jsCode": "const fs = require('fs');\nconst path = require('path');\n\nconst subject = $input.item.json.body.subject || 'Unknown';\nconst timestamp = $input.item.json.body.timestamp || new Date().toISOString();\n\nconst EXPORT_DIR = '/oikos/mneme/.hegemonikon/sessions';\n\ntry {\n  const files = fs.readdirSync(EXPORT_DIR)\n    .filter(f => f.endsWith('.md'))\n    .map(f => {\n      const stat = fs.statSync(path.join(EXPORT_DIR, f));\n      return { name: f, time: stat.mtime.getTime() };\n    })\n    .sort((a, b) => b.time - a.time);\n\n  const latestFile = files.length > 0 ? files[0].name : 'none';\n  const totalHandoffs = files.filter(f => f.includes('handoff')).length;\n  const totalSessions = files.length;\n\n  return [{ json: { status: 'success', file: latestFile, subject, timestamp, totalHandoffs, totalSessions } }];\n} catch (e) {\n  return [{ json: { status: 'error', message: e.message, subject, timestamp } }];\n}"
            },
            "id": "process-handoff",
            "name": "Process Handoff",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                450,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\nconst { execSync } = require('child_process');\n\nconst data = $input.item.json;\n\nlet webhookUrl = '';\ntry {\n  webhookUrl = execSync('echo $SLACK_WEBHOOK_URL', { encoding: 'utf-8', timeout: 3000 }).trim();\n} catch(e) {}\n\nif (!webhookUrl) {\n  return [{ json: { slack: 'skipped', reason: 'SLACK_WEBHOOK_URL not set' } }];\n}\n\nconst emoji = data.status === 'success' ? '\\u{1F44B}' : '\\u26A0\\uFE0F';\nconst statusText = data.status === 'success' ? 'Saved' : 'Error';\n\nconst payload = JSON.stringify({\n  blocks: [\n    { type: 'header', text: { type: 'plain_text', text: `${emoji} Session Ended`, emoji: true } },\n    { type: 'section', fields: [\n      { type: 'mrkdwn', text: `*Subject:*\\n${data.subject}` },\n      { type: 'mrkdwn', text: `*Status:*\\n${statusText}` }\n    ]},\n    { type: 'section', fields: [\n      { type: 'mrkdwn', text: `*File:*\\n\\`${data.file || 'N/A'}\\`` },\n      { type: 'mrkdwn', text: `*Time:*\\n${data.timestamp}` }\n    ]},\n    { type: 'context', elements: [\n      { type: 'mrkdwn', text: `Sessions: ${data.totalSessions || '?'} | Handoffs: ${data.totalHandoffs || '?'}` }\n    ]}\n  ]\n});\n\nconst urlObj = new URL(webhookUrl);\nconst result = await new Promise((resolve) => {\n  const req = https.request({\n    hostname: urlObj.hostname,\n    path: urlObj.pathname,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(payload) },\n    timeout: 10000\n  }, (res) => {\n    let body = '';\n    res.on('data', (c) => body += c);\n    res.on('end', () => resolve({ slack: 'sent', code: res.statusCode, body }));\n  });\n  req.on('error', (e) => resolve({ slack: 'error', msg: e.message }));\n  req.on('timeout', () => { req.destroy(); resolve({ slack: 'timeout' }); });\n  req.write(payload);\n  req.end();\n});\n\nreturn [{ json: result }];"
            },
            "id": "slack-notify",
            "name": "Slack Notification",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                650,
                300
            ]
        }
    ],
    "connections": {
        "Webhook Trigger": {
            "main": [
                [
                    {
                        "node": "Process Handoff",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Process Handoff": {
            "main": [
                [
                    {
                        "node": "Slack Notification",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "settings": {
        "executionOrder": "v1"
    },
    "tags": [
        {
            "name": "hegemonikon"
        },
        {
            "name": "bye"
        }
    ],
    "versionId": "3.0.0"
}