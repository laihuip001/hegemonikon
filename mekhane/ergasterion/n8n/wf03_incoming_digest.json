{
    "name": "WF-03: Incoming ‚Üí Digest ‚Üí Slack",
    "nodes": [
        {
            "parameters": {
                "rule": {
                    "interval": [
                        {
                            "field": "cronExpression",
                            "expression": "*/30 * * * *"
                        }
                    ]
                }
            },
            "id": "schedule-trigger",
            "name": "30ÂàÜ„Åî„Å®„ÉÅ„Çß„ÉÉ„ÇØ",
            "type": "n8n-nodes-base.scheduleTrigger",
            "typeVersion": 1.2,
            "position": [
                250,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "const fs = require('fs');\nconst path = require('path');\n\nconst INCOMING_DIR = '/oikos/mneme/.hegemonikon/incoming';\nconst PROCESSED_DIR = '/oikos/mneme/.hegemonikon/processed';\n\ntry {\n  if (!fs.existsSync(INCOMING_DIR)) {\n    return [];\n  }\n\n  const files = fs.readdirSync(INCOMING_DIR)\n    .filter(f => f.endsWith('.md') && !f.startsWith('.'))\n    .map(f => {\n      const fullPath = path.join(INCOMING_DIR, f);\n      const stat = fs.statSync(fullPath);\n      const content = fs.readFileSync(fullPath, 'utf-8');\n      return { filename: f, path: fullPath, size: stat.size, content: content, mtime: stat.mtime.toISOString() };\n    })\n    .filter(f => f.content.trim().length > 0);\n\n  if (files.length === 0) {\n    return [];\n  }\n\n  return files.map(f => ({ json: f }));\n} catch (e) {\n  throw new Error('Scan failed: ' + e.message);\n}"
            },
            "id": "scan-incoming",
            "name": "incoming/ „Çπ„Ç≠„É£„É≥",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                450,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "const fs = require('fs');\nconst path = require('path');\n\nconst content = $input.item.json.content;\nconst filename = $input.item.json.filename;\n\nconst lines = content.split('\\n');\nlet title = filename;\nlet score = '?';\nlet topics = [];\nlet abstract = '';\nlet source = '';\nlet url = '';\n\n// „É°„Çø„Éá„Éº„ÇøÊäΩÂá∫\nfor (const line of lines) {\n  if (line.startsWith('# ')) {\n    title = line.replace(/^#\\s*\\/eat\\s*ÂÄôË£ú:\\s*/, '').trim();\n  }\n  const scoreMatch = line.match(/Score[*]*:\\s*([\\d.]+)/);\n  if (scoreMatch) score = scoreMatch[1];\n  const topicMatch = line.match(/Topics[*]*:\\s*(.+?)(?:\\s*\\||$)/);\n  if (topicMatch) topics = topicMatch[1].split(',').map(t => t.trim());\n  const sourceMatch = line.match(/Source[*]*:\\s*(.+?)(?:\\s*\\||$)/);\n  if (sourceMatch) source = sourceMatch[1].trim();\n  const urlMatch = line.match(/URL[*]*:\\s*(http\\S+)/);\n  if (urlMatch) url = urlMatch[1].trim();\n}\n\n// Abstract ÊäΩÂá∫\nconst absIdx = lines.findIndex(l => l.startsWith('## Abstract'));\nif (absIdx >= 0) {\n  abstract = lines.slice(absIdx + 1, absIdx + 5).join(' ').trim().slice(0, 200);\n}\n\n// processed/ „Å´ÁßªÂãï\nconst PROCESSED_DIR = '/oikos/mneme/.hegemonikon/processed';\nif (!fs.existsSync(PROCESSED_DIR)) {\n  fs.mkdirSync(PROCESSED_DIR, { recursive: true });\n}\n\nconst now = new Date().toISOString().slice(0, 10);\nconst digestFilename = `digest_${now}_${filename}`;\n\n// „ÉÄ„Ç§„Ç∏„Çß„Çπ„Éà .md ÁîüÊàê\nconst digest = `# Digest: ${title}\\n\\n> **Ê∂àÂåñÊó•**: ${now}\\n> **Score**: ${score}\\n> **Topics**: ${topics.join(', ')}\\n> **Source**: ${source}\\n> **URL**: ${url}\\n\\n## Abstract\\n\\n${abstract}\\n\\n---\\n\\n*Auto-processed by WF-03 (n8n)*\\n`;\n\nfs.writeFileSync(path.join(PROCESSED_DIR, digestFilename), digest, 'utf-8');\nfs.renameSync($input.item.json.path, path.join(PROCESSED_DIR, `original_${filename}`));\n\nreturn [{\n  json: {\n    title, score, topics, source, url, abstract,\n    status: 'digested', digestFile: digestFilename\n  }\n}];"
            },
            "id": "digest-process",
            "name": "„ÉÄ„Ç§„Ç∏„Çß„Çπ„ÉàÁîüÊàê + ÁßªÂãï",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                650,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "const items = $input.all();\nconst now = new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' });\n\nconst summary = items.map(item => {\n  const d = item.json;\n  const emoji = parseFloat(d.score) >= 0.5 ? '‚≠ê' : 'üìÑ';\n  return `${emoji} **${d.title}** (${d.score}) ‚Äî ${d.topics.join(', ')}`;\n}).join('\\n');\n\nreturn [{ json: {\n  text: `üì• Hegemonik√≥n Ê∂àÂåñÂÆå‰∫Ü (${now})\\n\\n${items.length}‰ª∂Âá¶ÁêÜ:\\n${summary}`,\n  count: items.length,\n  items: items.map(i => i.json)\n} }];"
            },
            "id": "format-summary",
            "name": "Slack „É°„ÉÉ„Çª„Éº„Ç∏Êï¥ÂΩ¢",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                850,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nconst data = $input.item.json;\nconst webhookUrl = process.env.SLACK_WEBHOOK_URL;\n\nif (!webhookUrl) {\n  return [{ json: { slack: 'skipped', reason: 'SLACK_WEBHOOK_URL not set', message: data.text } }];\n}\n\nconst payload = JSON.stringify({\n  blocks: [\n    { type: 'header', text: { type: 'plain_text', text: `üì• Ê∂àÂåñÂÆå‰∫Ü: ${data.count}‰ª∂`, emoji: true } },\n    { type: 'section', text: { type: 'mrkdwn', text: data.text } },\n    { type: 'context', elements: [\n      { type: 'mrkdwn', text: '_WF-03 Incoming ‚Üí Digest | Hegemonik√≥n_' }\n    ]}\n  ]\n});\n\nconst urlObj = new URL(webhookUrl);\nconst result = await new Promise((resolve) => {\n  const req = https.request({\n    hostname: urlObj.hostname,\n    path: urlObj.pathname,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(payload) },\n    timeout: 10000\n  }, (res) => {\n    let body = '';\n    res.on('data', (c) => body += c);\n    res.on('end', () => resolve({ slack: 'sent', code: res.statusCode }));\n  });\n  req.on('error', (e) => resolve({ slack: 'error', msg: e.message }));\n  req.on('timeout', () => { req.destroy(); resolve({ slack: 'timeout' }); });\n  req.write(payload);\n  req.end();\n});\n\nreturn [{ json: result }];"
            },
            "id": "slack-notify",
            "name": "Slack ÈÄöÁü•",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1050,
                300
            ]
        }
    ],
    "connections": {
        "30ÂàÜ„Åî„Å®„ÉÅ„Çß„ÉÉ„ÇØ": {
            "main": [
                [
                    {
                        "node": "incoming/ „Çπ„Ç≠„É£„É≥",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "incoming/ „Çπ„Ç≠„É£„É≥": {
            "main": [
                [
                    {
                        "node": "„ÉÄ„Ç§„Ç∏„Çß„Çπ„ÉàÁîüÊàê + ÁßªÂãï",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "„ÉÄ„Ç§„Ç∏„Çß„Çπ„ÉàÁîüÊàê + ÁßªÂãï": {
            "main": [
                [
                    {
                        "node": "Slack „É°„ÉÉ„Çª„Éº„Ç∏Êï¥ÂΩ¢",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Slack „É°„ÉÉ„Çª„Éº„Ç∏Êï¥ÂΩ¢": {
            "main": [
                [
                    {
                        "node": "Slack ÈÄöÁü•",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "settings": {
        "executionOrder": "v1"
    },
    "tags": [
        {
            "name": "hegemonikon"
        },
        {
            "name": "digest"
        },
        {
            "name": "incoming"
        }
    ],
    "versionId": "3.0.0"
}