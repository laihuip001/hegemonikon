{
    "name": "WF-13: Git Sentinel (Sympatheia)",
    "nodes": [
        {
            "parameters": {
                "rule": {
                    "interval": [
                        {
                            "field": "cronExpression",
                            "expression": "0 * * * *"
                        }
                    ]
                }
            },
            "id": "sentinel-cron",
            "name": "æ¯æ™‚ã®èµ°æŸ»",
            "type": "n8n-nodes-base.scheduleTrigger",
            "typeVersion": 1.2,
            "position": [
                250,
                300
            ]
        },
        {
            "parameters": {
                "httpMethod": "POST",
                "path": "git-sentinel",
                "responseMode": "lastNode",
                "options": {}
            },
            "id": "sentinel-webhook",
            "name": "æ‰‹å‹•ãƒˆãƒªã‚¬ãƒ¼",
            "type": "n8n-nodes-base.webhook",
            "typeVersion": 2,
            "position": [
                250,
                500
            ],
            "webhookId": "git-sentinel-wh"
        },
        {
            "parameters": {
                "jsCode": "const fs = require('fs');\nconst path = require('path');\n\n// === è¨­å®š ===\nconst REPO_DIR = '/home/makaron8426/oikos/hegemonikon';\nconst GIT_DIR = path.join(REPO_DIR, '.git');\nconst STATE_FILE = '/home/makaron8426/oikos/mneme/.hegemonikon/git_sentinel_state.json';\n\n// HEAD ã‹ã‚‰ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒã‚’è§£æ±º\nconst headContent = fs.readFileSync(path.join(GIT_DIR, 'HEAD'), 'utf-8').trim();\nvar branchRef = null;\nvar branchName = 'detached';\nif (headContent.startsWith('ref: ')) {\n  branchRef = headContent.slice(5);\n  branchName = branchRef.split('/').pop();\n}\n\n// === mtime å–å¾— ===\nconst now = Date.now();\n\n// .git/index = working tree ãŒå¤‰æ›´ã•ã‚Œã‚‹ãŸã³ã«æ›´æ–°\nvar indexMtime = 0;\ntry {\n  indexMtime = fs.statSync(path.join(GIT_DIR, 'index')).mtimeMs;\n} catch(e) {}\n\n// .git/refs/heads/{branch} = æœ€çµ‚ã‚³ãƒŸãƒƒãƒˆæ™‚åˆ»\nvar commitMtime = 0;\nif (branchRef) {\n  // packed-refs ã®å ´åˆã¯ refs/heads ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„ã“ã¨ãŒã‚ã‚‹\n  var refPath = path.join(GIT_DIR, branchRef);\n  try {\n    commitMtime = fs.statSync(refPath).mtimeMs;\n  } catch(e) {\n    // packed-refs ã‚’ç¢ºèª\n    try {\n      var packed = fs.readFileSync(path.join(GIT_DIR, 'packed-refs'), 'utf-8');\n      if (packed.indexOf(branchRef) !== -1) {\n        // packed-refs ã® mtime ã‚’ä»£ç”¨\n        commitMtime = fs.statSync(path.join(GIT_DIR, 'packed-refs')).mtimeMs;\n      }\n    } catch(e2) {}\n  }\n}\n\n// === æœªã‚³ãƒŸãƒƒãƒˆæ¤œå‡ºãƒ­ã‚¸ãƒƒã‚¯ ===\n// index ãŒ commit ref ã‚ˆã‚Šæ–°ã—ã„ = staging area ã«å¤‰æ›´ãŒã‚ã‚‹å¯èƒ½æ€§\nvar hasUncommitted = indexMtime > commitMtime + 1000; // 1ç§’ãƒãƒ¼ã‚¸ãƒ³\nvar uncommittedSeconds = hasUncommitted ? Math.floor((now - commitMtime) / 1000) : 0;\nvar uncommittedHours = Math.floor(uncommittedSeconds / 3600);\n\n// MERGE_HEAD, REBASE_HEAD ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯\nvar hasMergeInProgress = false;\nvar hasRebaseInProgress = false;\ntry { fs.statSync(path.join(GIT_DIR, 'MERGE_HEAD')); hasMergeInProgress = true; } catch(e) {}\ntry { fs.statSync(path.join(GIT_DIR, 'rebase-merge')); hasRebaseInProgress = true; } catch(e) {}\ntry { fs.statSync(path.join(GIT_DIR, 'rebase-apply')); hasRebaseInProgress = true; } catch(e) {}\n\n// === çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ« èª­ã¿æ›¸ã ===\nvar prevState = {};\ntry {\n  prevState = JSON.parse(fs.readFileSync(STATE_FILE, 'utf-8'));\n} catch(e) {}\n\nvar scanCount = ((prevState._meta || {}).scanCount || 0) + 1;\nvar prevAlerted = prevState.lastAlertedAt || null;\n\n// ã‚¢ãƒ©ãƒ¼ãƒˆåˆ¤å®š: 24hä»¥ä¸Šæœªã‚³ãƒŸãƒƒãƒˆ\nvar ALERT_THRESHOLD_HOURS = 24;\nvar shouldAlert = hasUncommitted && uncommittedHours >= ALERT_THRESHOLD_HOURS;\n\n// ãƒªãƒã‚¤ãƒ³ãƒ‰é–“éš”: ä¸€åº¦ã‚¢ãƒ©ãƒ¼ãƒˆã—ãŸã‚‰6æ™‚é–“ã¯å†é€šçŸ¥ã—ãªã„\nvar REMIND_INTERVAL_MS = 6 * 3600 * 1000;\nif (shouldAlert && prevAlerted) {\n  var sinceLast = now - new Date(prevAlerted).getTime();\n  if (sinceLast < REMIND_INTERVAL_MS) {\n    shouldAlert = false; // æŠ‘åˆ¶\n  }\n}\n\n// ç‰¹æ®ŠçŠ¶æ…‹ã®å³æ™‚ã‚¢ãƒ©ãƒ¼ãƒˆ\nvar hasSpecialState = hasMergeInProgress || hasRebaseInProgress;\nif (hasSpecialState) shouldAlert = true;\n\n// === Slack ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ ===\nvar slackPayload = '';\nif (shouldAlert) {\n  var emoji = hasSpecialState ? 'ğŸš¨' : 'ğŸ§¬';\n  var title = hasSpecialState\n    ? emoji + ' Git: ç‰¹æ®ŠçŠ¶æ…‹ã‚’æ¤œå‡º'\n    : emoji + ' Git Sentinel: ' + uncommittedHours + 'h æœªã‚³ãƒŸãƒƒãƒˆ';\n\n  var lines = [];\n  lines.push('*Branch*: `' + branchName + '`');\n  lines.push('*æœ€çµ‚ã‚³ãƒŸãƒƒãƒˆ*: ' + uncommittedHours + 'h ' + (uncommittedSeconds % 3600 > 0 ? Math.floor((uncommittedSeconds % 3600) / 60) + 'm' : '') + ' ago');\n  if (hasMergeInProgress) lines.push('âš ï¸ MERGE_HEAD ãŒå­˜åœ¨ â€” ãƒãƒ¼ã‚¸é€”ä¸­');\n  if (hasRebaseInProgress) lines.push('âš ï¸ rebase ãŒé€²è¡Œä¸­');\n  lines.push('_Scan #' + scanCount + '_');\n\n  slackPayload = JSON.stringify({\n    blocks: [\n      { type: 'header', text: { type: 'plain_text', text: title, emoji: true } },\n      { type: 'section', text: { type: 'mrkdwn', text: lines.join('\\n') } },\n      { type: 'context', elements: [{ type: 'mrkdwn', text: '_WF-13 Git Sentinel | DNAä¿®å¾©é…µç´ _' }] }\n    ]\n  });\n}\n\n// === çŠ¶æ…‹ä¿å­˜ ===\ntry {\n  var state = {\n    _meta: {\n      scanCount: scanCount,\n      lastScan: new Date(now).toISOString(),\n      lastAlertedAt: shouldAlert ? new Date(now).toISOString() : prevAlerted\n    },\n    branch: branchName,\n    indexMtime: indexMtime,\n    commitMtime: commitMtime,\n    hasUncommitted: hasUncommitted,\n    uncommittedHours: uncommittedHours,\n    hasMergeInProgress: hasMergeInProgress,\n    hasRebaseInProgress: hasRebaseInProgress\n  };\n  fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2), 'utf-8');\n} catch(e) {}\n\nreturn [{ json: {\n  scanCount: scanCount,\n  timestamp: new Date(now).toISOString(),\n  branch: branchName,\n  hasUncommitted: hasUncommitted,\n  uncommittedHours: uncommittedHours,\n  hasMergeInProgress: hasMergeInProgress,\n  hasRebaseInProgress: hasRebaseInProgress,\n  shouldAlert: shouldAlert,\n  slackPayload: slackPayload\n} }];"
            },
            "id": "sentinel-check",
            "name": "GitçŠ¶æ…‹èµ°æŸ»",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                450,
                400
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "boolean": [
                        {
                            "value1": "={{$json.shouldAlert}}",
                            "value2": true
                        }
                    ]
                }
            },
            "id": "if-alert",
            "name": "é€šçŸ¥è¦?",
            "type": "n8n-nodes-base.if",
            "typeVersion": 1,
            "position": [
                650,
                400
            ]
        },
        {
            "parameters": {
                "method": "POST",
                "url": "={{ $env.SLACK_WEBHOOK_URL }}",
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ $json.slackPayload }}",
                "options": {
                    "timeout": 10000
                }
            },
            "id": "slack-notify",
            "name": "ã‚³ãƒŸãƒƒãƒˆå‚¬ä¿ƒ",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                850,
                300
            ]
        }
    ],
    "connections": {
        "æ¯æ™‚ã®èµ°æŸ»": {
            "main": [
                [
                    {
                        "node": "GitçŠ¶æ…‹èµ°æŸ»",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "æ‰‹å‹•ãƒˆãƒªã‚¬ãƒ¼": {
            "main": [
                [
                    {
                        "node": "GitçŠ¶æ…‹èµ°æŸ»",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "GitçŠ¶æ…‹èµ°æŸ»": {
            "main": [
                [
                    {
                        "node": "é€šçŸ¥è¦?",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "é€šçŸ¥è¦?": {
            "main": [
                [
                    {
                        "node": "ã‚³ãƒŸãƒƒãƒˆå‚¬ä¿ƒ",
                        "type": "main",
                        "index": 0
                    }
                ],
                []
            ]
        }
    },
    "settings": {
        "executionOrder": "v1"
    },
    "tags": [
        {
            "name": "hegemonikon"
        },
        {
            "name": "sympatheia"
        },
        {
            "name": "git-sentinel"
        }
    ],
    "active": true,
    "versionId": "1.0.0"
}