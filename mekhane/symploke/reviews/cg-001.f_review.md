# ネスト深度警報者 レビュー

## 対象ファイル
`mekhane/ochema/antigravity_client.py`

## 判定
発言（要改善）

## 発見事項

### 1. `session_episodes` (High)
- **ネスト深度**: 7
- **場所**: `session_episodes` メソッド (L327-L382)
- **詳細**: `for entry` -> `if isdir` -> `if count > 0` -> `if isfile` -> `with open` -> `for line` -> `if startswith`
- **違反**: 脳の処理限界 (4段) を大幅に超過 (7段)。可読性が著しく低い。

### 2. `session_info` (High)
- **ネスト深度**: 5
- **場所**: `session_info` メソッド (L208-L260)
- **詳細**: `if cascade_id` -> `for s` -> `if s["cascade_id"]` -> `for step` -> `st = ...`
- **違反**: 4段以上。特定IDの検索ロジックと詳細取得が混在。

### 3. `_poll_response` (High)
- **ネスト深度**: 5
- **場所**: `_poll_response` メソッド (L667-L709)
- **詳細**: `while` -> `if trajectory_id` -> `try` -> `if has_response` -> `return`
- **違反**: 4段以上。ポーリング、状態チェック、結果パースが一箇所に集中。

### 4. `_detect_ls` (High)
- **ネスト深度**: 4
- **場所**: `_detect_ls` メソッド (L585-L649)
- **詳細**: `for line` -> `if "language_server"` -> `if ws_normalized` -> `if "grep"`
- **違反**: 4段以上。プロセス行のフィルタリング条件がネストしている。

### 5. `session_read` (High)
- **ネスト深度**: 4
- **場所**: `session_read` メソッド (L263-L325)
- **詳細**: `for step` -> `if type` -> `for item` -> `if "text"`
- **違反**: 4段以上。データ構造の深層アクセス。

### 6. `_parse_steps` (High)
- **ネスト深度**: 4
- **場所**: `_parse_steps` メソッド (L711-L733)
- **詳細**: `for step` -> `if type` -> `parsed = ...` -> `if parsed["text"]`
- **違反**: 4段以上。

## 修正提案

### 共通
早期リターン (Guard Clause) の活用と、ヘルパー関数への抽出（抽出メソッド）を推奨します。

### `session_episodes` の修正案
Brain情報の取得ロジックを分離する。

```python
def _get_brain_title(self, brain_dir: str, entry: str) -> str:
    """Brain のタイトルを task.md から取得する。"""
    task_file = os.path.join(brain_dir, entry, "task.md")
    if not os.path.isfile(task_file):
        return ""

    with open(task_file, "r", errors="replace") as f:
        for line in f:
            if line.startswith("# "):
                return line[2:].strip()
    return ""

def session_episodes(self, brain_id: Optional[str] = None) -> dict:
    # ... (前半省略) ...

    # Brain 一覧取得
    brains = []
    for entry in os.listdir(BRAIN_DIR):
        sys_gen = os.path.join(BRAIN_DIR, entry, ".system_generated", "steps")
        # 早期リターンに近い形で continue を使用
        if not os.path.isdir(sys_gen):
            continue

        # エピソード数のカウントロジックも抽出可能だがここでは省略
        count = len([
            d for d in os.listdir(sys_gen)
            if os.path.isfile(os.path.join(sys_gen, d, "output.txt"))
        ])

        if count == 0:
            continue

        # ヘルパー関数利用によりネスト削減
        title = self._get_brain_title(BRAIN_DIR, entry)
        brains.append({
            "brain_id": entry,
            "episode_count": count,
            "title": title,
        })
    # ...
```

### `session_info` の修正案
特定セッションの検索と処理を分離するか、早期リターンを使用。

```python
    if cascade_id:
        # リスト内包表記や next を使って検索をフラット化
        target_session = next((s for s in sessions if s["cascade_id"] == cascade_id), None)
        if not target_session:
            return {"error": f"cascade_id {cascade_id} not found"}

        steps_data = self._rpc(RPC_GET_STEPS, {
            "cascadeId": cascade_id,
            "trajectoryId": target_session["trajectory_id"],
        })

        # 集計処理
        step_types: dict[str, int] = {}
        for step in steps_data.get("steps", []):
            st = step.get("type", "UNKNOWN")
            step_types[st] = step_types.get(st, 0) + 1

        target_session["step_types"] = step_types
        return target_session
```

### `_poll_response` の修正案
`continue` を活用してネストを浅くする。

```python
    while time.time() - start_time < timeout:
        # Step 3: trajectory_id 取得
        if not trajectory_id:
            trajectory_id = self._fetch_trajectory_id(cascade_id) # 抽出メソッドと仮定

        # Step 4: 結果確認
        if trajectory_id:
            # 内部ロジックを抽出しても良い
            response = self._check_trajectory_completion(cascade_id, trajectory_id)
            if response:
                return response

        time.sleep(POLL_INTERVAL)
```

## 重大度
High
