# ネスト深度警報者 レビュー

## 対象ファイル
`mekhane/mcp/sophia_mcp_server.py`

## 判定
発言（要改善）

## 発見事項
- **`call_tool` 関数内 `if name == "search"` ブロック (High)**
  - ネスト深度が最大 **8** に到達しています。
  - `if name` (Lv1) -> `try` (Lv2) -> `if source` (Lv3) -> `for r` (Lv4) -> `if recent_days` (Lv5) -> `if ts` (Lv6) -> `try` (Lv7) -> `if (now - doc_date)` (Lv8)
- **`call_tool` 関数内 `if name == "backlinks"` ブロック (High)**
  - ネスト深度が **5** に到達しています。
  - `if name` (Lv1) -> `try` (Lv2) -> `if backlinks` (Lv3) -> `for link` (Lv4)
  - `if name` (Lv1) -> `try` (Lv2) -> `if outlinks` (Lv3) -> `for link` (Lv4)
- **`call_tool` 関数内 `if name == "graph_stats"` ブロック (High)**
  - ネスト深度が **5** に到達しています。
  - `if name` (Lv1) -> `try` (Lv2) -> `if stats["most_linked"]` (Lv3) -> `for name` (Lv4) -> `if count` (Lv5)
- **`try-except` ブロック内のネスト (Medium)**
  - `call_tool` 内の各ツール処理が `try` ブロックで囲まれており、その内部でさらに分岐やループが発生しているため、全体的に `try` 内部のネストが3段を超えています。

## 重大度
High

## 修正案
`call_tool` 関数が肥大化し、複数の責務を持っていることが深いネストの原因です。
各ツールの処理を独立した関数に切り出し（Early Returnを活用）、`call_tool` はディスパッチのみを担当するように修正することを推奨します。

```python
# 修正イメージ

async def _handle_search(arguments: dict):
    query = arguments.get("query", "")
    if not query:
        return [TextContent(type="text", text="Error: query is required")]

    source = arguments.get("source", "both")
    limit = arguments.get("limit", 5)
    recent_days = arguments.get("recent_days")

    try:
        with StdoutSuppressor():
            from mekhane.symploke.adapters.embedding_adapter import EmbeddingAdapter

        # ... (Sophia/Kairos 検索ロジックをここに移動し、ガード節でネストを減らす) ...
        # 例: if not results: return ...

        return [TextContent(type="text", text=formatted_output)]
    except Exception as e:
        log(f"Search error: {e}")
        return [TextContent(type="text", text=f"Error searching: {str(e)}")]

async def call_tool(name: str, arguments: dict):
    """Handle tool calls."""
    log(f"call_tool: {name} with {arguments}")

    handlers = {
        "search": _handle_search,
        "stats": _handle_stats,
        "backlinks": _handle_backlinks,
        "graph_stats": _handle_graph_stats,
    }

    handler = handlers.get(name)
    if handler:
        return await handler(arguments)

    return [TextContent(type="text", text=f"Unknown tool: {name}")]
```
