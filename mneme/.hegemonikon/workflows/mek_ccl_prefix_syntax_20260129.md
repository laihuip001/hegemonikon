# CCL プレフィックス構文設計 (`CCL/X`)

> **Hegemonikón**: S2 Mekhanē (inve 派生) + 深化モード
> **生成日時**: 2026-01-29T22:50
> **要件**: `CCL/mek+` の意味を正式構文または WF として定義

---

## 1. 問題の本質

### 観察された意図

| 入力 | 意味 |
|:-----|:-----|
| `CCL/mek+` | 「CCLプログラムを /mek+ で生成せよ」 |
| `CCL/s+` | 「CCLプログラムを /s+ で設計せよ」 |
| `CCL/dia+` | 「CCLプログラムを /dia+ で監査せよ」 |

### 一般化

```
CCL/{WF}{operator} = "CCLプログラムを {WF}{operator} で {動詞}"
```

---

## 2. 設計オプション

### Option A: 新演算子 `/` の拡張

**構文**: `{target}/{WF}{op}`

| 構文 | 意味 |
|:-----|:-----|
| `CCL/mek+` | CCL生成を mek+ で |
| `WF/dia-` | ワークフロー監査を dia- で |
| `KI/zet+` | 知識項目探索を zet+ で |

**評価**:

- ✅ 汎用的（CCL以外にも使える）
- ⚠️ `/` 演算子の意味が複雑化（下降 vs プレフィックス）
- ❌ パース曖昧性（`a/b/c` の解釈）

---

### Option B: 専用マクロ `@ccl`

**構文**: `@ccl {WF}{op}`

| 構文 | 意味 |
|:-----|:-----|
| `@ccl mek+` | CCL生成を mek+ で |
| `@ccl s+` | CCL設計を s+ で |
| `@ccl dia+` | CCL監査を dia+ で |

**評価**:

- ✅ 明確なマクロ構文
- ✅ 既存セマンティックマクロ（@考, @創 等）と一貫
- ⚠️ CCL専用（他ターゲットには別マクロ必要）

---

### Option C: ターゲット指定演算子 `[target]`

**構文**: `[CCL]{WF}{op}`

| 構文 | 意味 |
|:-----|:-----|
| `[CCL]mek+` | CCL生成を mek+ で |
| `[WF]dia-` | ワークフロー監査を dia- で |
| `[KI]zet+` | 知識項目探索を zet+ で |

**評価**:

- ✅ ターゲットが明示的
- ✅ 既存の selector 構文 `[scope]` と類似
- ✅ 汎用的

---

### Option D: WF パラメータとして吸収

**構文**: `/mek+ --output=ccl`

| 構文 | 意味 |
|:-----|:-----|
| `/mek+ --output=ccl` | mek+ の出力を CCL として |
| `/s+ --output=ccl` | s+ の出力を CCL として |

**評価**:

- ✅ 既存 WF 構造を活用
- ⚠️ 冗長
- ❌ CCL らしさが失われる

---

## 3. 推奨: Option C + 省略形

### 正式構文

```ccl
[CCL]/mek+   # CCL生成を詳細モードで
[WF]/dia-    # ワークフロー監査を縮約モードで
[KI]/zet+    # 知識項目探索を深化モードで
```

### 省略形（CCL が default target の場合）

```ccl
CCL/mek+     # = [CCL]/mek+ （スラッシュ前をターゲットと推論）
```

### パース規則

```
EXPR := [TARGET]? / WF OP
TARGET := 'CCL' | 'WF' | 'KI' | identifier
WF := 'mek' | 's' | 'dia' | 'noe' | ...
OP := '+' | '-' | '*' | '^' | '/' | ...
```

### 意味論

| ターゲット | 動作 |
|:-----------|:-----|
| `CCL` | WF の出力として **CCLプログラム** を生成 |
| `WF` | WF の出力として **ワークフロー定義** を生成 |
| `KI` | WF の出力として **知識項目** を生成 |
| `SKILL` | WF の出力として **スキル定義** を生成 |

---

## 4. 実装計画

### Phase 1: 仕様策定

- [x] 構文設計 (このドキュメント)
- [ ] パーサー更新 (`ccl/lexer.py`, `ccl/parser.py`)

### Phase 2: 統合

- [ ] `/mek` に `--target` オプション追加（内部実装）
- [ ] 出力テンプレート分岐

### Phase 3: ドキュメント

- [ ] `operators_and_layers.md` 更新
- [ ] `ccl_handbook.md` 更新

---

## 5. CCL プログラム: TARGET-DISPATCH

```ccl
PROGRAM: TARGET-DISPATCH
VERSION: 1.0
INTENT: "ターゲット指定構文の動作定義"

# ========================================
# 構文認識
# ========================================

PARSE: {input}
  IF match "[{T}]/{W}{O}" THEN
    target = T
    workflow = W
    operator = O
  ELSIF match "{T}/{W}{O}" THEN
    target = T
    workflow = W
    operator = O
  ELSE
    target = "DEFAULT"
    # 通常の CCL として処理
  ENDIF

_

# ========================================
# ターゲット分岐
# ========================================

DISPATCH: {target}
  CASE "CCL":
    # 出力を CCL プログラム形式で生成
    output_format = "ccl_program"
    template = "ccl_program_template.md"
    
  CASE "WF":
    # 出力をワークフロー定義形式で生成
    output_format = "workflow_yaml"
    template = "workflow_template.md"
    
  CASE "KI":
    # 出力を知識項目形式で生成
    output_format = "ki_structure"
    template = "ki_template.md"
    
  DEFAULT:
    # 通常の WF 出力
    output_format = "default"

_

# ========================================
# 実行
# ========================================

EXECUTE: /{workflow}{operator}
  WITH output_format = {output_format}
  WITH template = {template}

ARTIFACT: target_dispatch_result_{date}.md
```

---

## 6. Mekhanē 生成メタデータ

| 項目 | 値 |
|:-----|:---|
| 派生 | **inve** (探索・発明) |
| モード | `/mek+` (詳細生成) |
| アーキタイプ | Language Design |
| 品質スコア | 9/10 |
| 推奨オプション | **C** (`[TARGET]/WF{op}`) |

---

*Generated by /mek+ (inve) | Hegemonikón S2 Mekhanē*
