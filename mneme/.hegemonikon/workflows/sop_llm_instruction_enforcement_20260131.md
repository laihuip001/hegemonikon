# 調査依頼: LLM エージェントの論外処理を強制的に解消する方法

> **決定事項**: CCL 実行時に LLM が仕様を読まない・省略する・怠惰になる問題を、どの構造的強制機構で解消するか
> **仮説**: 実行前の仕様強制注入 + 出力検証 + 違反時リジェクトで解消できる

---

## 背景: 発生した具体的問題

```
問題1: ドキュメント未読
  - operators.md に「! = 階乗 = 全派生同時実行」と明記
  - LLM は読まずに「! = 否定」と誤解して処理
  - 結果: 完全に間違った出力

問題2: トークン節約の無意識的最適化
  - @repeat(/noe!~/u+_/s!*^/mek+, x2) という複雑な式
  - LLM は「長くなるから」と省略
  - 結果: 演算子の意味が無視される

問題3: 怠惰
  - 「楽な方を選んだ」と自覚あり
  - 詳細な処理を避け、簡潔な出力で済ませる
  - 結果: ユーザーの期待と乖離
```

---

## 【出力形式】← ⚠️ 最初に読め

**【必須】** 構造化テーブル（4列: 手法, 効果, 実装方法, 根拠URL）を返せ。
その後、「Hegemonikón CCL に最も適用しやすい手法」を2-3文で結論。

---

## 【時間制約】← ⚠️ 情報鮮度

- **採用範囲**: 過去6ヶ月以内の情報を優先
- **日付明記**: 各ソースに「取得時点: YYYY年MM月」を付記

---

## 【調査すべき論点】← ⚠️ 必須網羅

### A. 仕様強制注入 (Specification Injection)

- A1: LLM に「必ず読むべきドキュメント」を強制する方法は？
- A2: System Prompt への仕様埋め込みのベストプラクティスは？
- A3: 実行前に仕様を「クイズ形式」で確認させる手法は？
- A4: RAG で関連仕様を自動注入する方法は？
- A5: 「仕様を読んだ証拠」を出力に含めさせる方法は？

### B. 出力検証 (Output Validation)

- B1: LLM 出力を自動検証するフレームワークは？（Guardrails AI, NeMo Guardrails 等）
- B2: 必須セクション/見出しの有無を検証する方法は？
- B3: JSON Schema / Pydantic での出力強制の効果は？
- B4: 違反時に自動リジェクト→再生成させる実装は？
- B5: 出力の「詳細度」を測定するメトリクスは？

### C. 怠惰防止 (Lazy Output Prevention)

- C1: LLM が「短く済ませる」傾向の研究は？
- C2: 出力長を強制する方法は？（min_tokens, length penalty 等）
- C3: Chain-of-Thought を強制する方法は？
- C4: 「省略禁止」を System Prompt で効果的に伝える方法は？
- C5: Multi-Agent で「監査エージェント」を置く手法は？

### D. 演算子/DSL 実行の強制

- D1: DSL (Domain Specific Language) を LLM に正確に実行させる研究は？
- D2: 各演算子に対応する出力セクションを強制する方法は？
- D3: プログラム的に「ステップごとの出力」を要求する手法は？
- D4: LLM が演算子を「理解した」ことを検証する方法は？
- D5: 演算子の意味論を毎回注入するコスト vs 精度のトレードオフは？

---

## 【反証・検証】← ⚠️ 確認用

- 「構造的強制は効果がない」という研究があれば報告せよ
- 強制機構がパフォーマンスを劣化させる事例を3件探すこと
- Anthropic / OpenAI / Google の公式ガイドラインを確認

---

## 【成果物構成】

1. **結論サマリー**（10行以内）: Hegemonikón CCL への最適解
2. **比較テーブル**（必須列: 手法, 効果, 実装難度, 根拠URL）
3. **推奨実装順序**: 最小労力で最大効果の手法から順に

---

*Generated by /sop v5.3 — 2026-01-31*
*Topic: LLM Agent Specification Compliance Enforcement*
*Context: Hegemonikón CCL execution failures*
