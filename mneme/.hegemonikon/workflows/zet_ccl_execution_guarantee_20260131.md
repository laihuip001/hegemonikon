# /zet+: CCL 実行保証に足りないもの

> **Date**: 2026-01-31T12:12
> **CCL**: `/zet+`
> **Theme**: 言語としての CCL — 実行保証の欠落診断

---

## 0. 問いの背景

**CCL は「プログラミング言語」として実行保証を持つか？**

「実行保証」を持つ言語の特性:

| 側面 | Python/Rust | CCL 現状 |
|:-----|:------------|:---------|
| **構文正当性** | パーサーがエラー検出 | ❌ 正式パーサーなし |
| **型検証** | 型チェック | ⚠️ Theorem Types あるが非強制 |
| **ランタイム保証** | VM/インタプリタ | ❌ LLM 依存（非決定的） |
| **副作用管理** | 型制約 (Rust borrow) | ⚠️ Signature 概念あり、未強制 |
| **テスト可能性** | assert/テストフレームワーク | ❌ なし |

---

## 1. 5層の問い

### 🔴 Layer 1: 表層 — 構文的ギャップ

| 問い | 現状 | 欠落 |
|:-----|:-----|:-----|
| 構文は一意にパース可能か？ | `syntax_validator.py` 存在 | **正式文法 (EBNF/PEG) がない** |
| 演算子の結合規則は？ | 概念はあるが曖昧 | **優先順位テーブルが未定義** |
| エラー診断は？ | 事後検証のみ | **行/位置報告がない** |

**問い A**: CCL の正式文法 (EBNF/PEG) を定義せよ

---

### 🟠 Layer 2: 構造 — 型・意味論的ギャップ

| 問い | 現状 | 欠落 |
|:-----|:-----|:-----|
| 定理の型は強制されるか？ | O/S/H/P/K/A 概念あり | **型検査パイプラインがない** |
| 演算子の入出力型は？ | 暗黙 | **型シグネチャがない** |
| マクロ展開の正しさは？ | `macro_expander.py` | **展開後の型安全性チェックがない** |

**問い B**: CCL に型システム（または契約型）を導入せよ

---

### 🟡 Layer 3: 実行時 — ランタイム保証

| 問い | 現状 | 欠落 |
|:-----|:-----|:-----|
| CCL は「実行」できるか？ | LLM 依存 | **インタプリタ/VM がない** |
| 失敗時の再実行は？ | `failure_db.py` 記録 | **自動リトライ機構がない** |
| 収束条件は検証可能？ | `lim[]{...}` 構文 | **無限ループ検出がない** |
| 並列実行は？ | なし | **`||` 並列演算子がない** |

**問い C**: CCL インタプリタ/VM を構築せよ

---

### 🟢 Layer 4: 副作用・状態管理

| 問い | 現状 | 欠落 |
|:-----|:-----|:-----|
| 副作用の管理？ | Signature 概念 | **副作用の型注釈・追跡がない** |
| 状態変化のトレース？ | `tracer.py` 存在 | **状態の rollback がない** |
| 外部呼び出しの制御？ | MCP 連携 | **サンドボックスがない** |

**問い D**: CCL に Effect System を導入せよ

---

### 🔵 Layer 5: 存在論 — 根本的問い

| 問い | 現状 | 欠落 |
|:-----|:-----|:-----|
| CCL は「言語」か「記法」か？ | 記法寄り | **実行可能性が言語の本質** |
| 非決定性は許容？ | 許容 | **決定論的エンジンがない** |
| CCL の「正しさ」の定義は？ | FEP 接地 | **形式的仕様・証明がない** |

**問い E**: CCL の操作的意味論/表示的意味論を定式化せよ

---

## 2. /noe 対象候補

| # | 問い | 特徴 | 難易度 | 優先度 |
|:--|:-----|:-----|:-------|:-------|
| **A** | 正式文法 (EBNF/PEG) の定義 | 基盤、他の全てに必須 | 中 | ⭐⭐⭐ |
| **B** | 型システム/契約の導入 | 安全性向上 | 高 | ⭐⭐ |
| **C** | CCL インタプリタ/VM | 実行保証の核心 | 高 | ⭐⭐⭐ |
| **D** | Effect System | 副作用管理 | 中 | ⭐ |
| **E** | 形式的意味論 | 理論的完成度 | 最高 | ⭐ |

---

## 3. 推奨アプローチ

### 段階的実装 (A → C)

1. **文法定義 (A)**: EBNF/PEG で CCL を形式化
2. **パーサー生成**: Lark (Python) / PEG.js 使用
3. **インタプリタ (C)**: AST → 実行

**根拠**: Python の歴史的発展と同様

### 実行保証の三本柱

```
[文法]  →  [パーサー]  →  [インタプリタ]
  ↓            ↓              ↓
構文検証    AST生成       決定論的実行
```

---

## 4. 現在の CCL 実装マップ

現存ファイル (`mekhane/ccl/`):

| ファイル | 機能 | カバー範囲 |
|:---------|:-----|:-----------|
| `syntax_validator.py` | 基本構文チェック | Layer 1 (部分) |
| `executor.py` | Zero-Trust 実行 | Layer 3 (事後検証) |
| `spec_injector.py` | 仕様注入 | Layer 1 補助 |
| `output_schema.py` | 出力構造強制 | Layer 3 補助 |
| `tracer.py` | 実行トレース | Layer 4 (部分) |
| `semantic_validator.py` | 意味検証 | Layer 2 (部分) |

**欠落コンポーネント**:

- [ ] `grammar.peg` — 正式文法
- [ ] `parser.py` — 真のパーサー
- [ ] `type_checker.py` — 型システム
- [ ] `interpreter.py` — 実行エンジン
- [ ] `effect_tracker.py` — 副作用管理

---

## 5. まとめ

> **CCL を「言語」から「実行可能言語」にするには、記号システムから計算システムへの飛躍が必要である。**

---

*Generated by O3 Zētēsis /zet+ (2026-01-31)*
