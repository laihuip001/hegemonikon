# プロンプトに「数式」を導入する — CCL: Cognitive Control Language

> **想定媒体**: Zenn（技術記事）
> **想定読者**: プロンプトエンジニア、AI 研究者、LangChain/LangGraph ユーザー
> **フック**: 「プロンプトのコピペ地獄」から脱出する構造化言語

---

## リード文（案）

プロンプトエンジニアリングの現状を一言で言えば、「コピペ & 祈り」だ。

- 長いシステムプロンプトをコピペする
- 微妙に変えて試す
- 動いたら「なぜ動いたか」わからない
- 動かなくても「なぜ動かないか」わからない

これは、プログラミングで言えば「関数もクラスも変数もない」状態で
全てをベタ書きしているのと同じだ。

**CCL (Cognitive Control Language)** は、プロンプトの「構造化」を試みる小さな言語。
プロンプトのチェーニング・分岐・反復・検証を、数式のように書ける。

---

## 本文構成（案）

### 1. プロンプトの構造的問題

```
従来: 「以下の論文を読んで、要約して、批判的に分析して、最後に3つの質問を考えて」

問題: 
- 「批判的に」の定義が曖昧
- 各ステップの品質が見えない
- 再利用不可能
- 組み合わせ不可能
```

### 2. CCL の基本構文

```ccl
# 順序実行
/noe _ /dia _ /pis
# = 認識 → 判断 → 確信度測定

# 深化
/noe+   # 深い認識
/noe-   # 軽い認識

# 融合
/bou * /noe   # 意志 × 認識 の融合

# 揺動（往復思考）
/noe ~ /dia   # 認識 ↔ 判断 を往復
```

### 3. 実例: 論文消化パイプライン

```ccl
# 消化マクロ — 外部論文を内部知識に変換
@chew = /s-_/pro_F:[×3]{/eat+~(/noe*/dia)}_~(/h*/k)_@proof_/pis_/dox-
```

展開すると:

| ステップ | 意味 |
|:---------|:-----|
| `/s-` | 軽いスキーマ分析（概要把握） |
| `/pro` | 前感情（第一印象） |
| `F:[×3]{/eat+~(/noe*/dia)}` | 3回反復: 消化 ↔ (認識×判断) |
| `~(/h*/k)` | 動機×文脈で揺動検証 |
| `@proof` | 存在証明 |
| `/pis` | 確信度測定 |
| `/dox-` | 軽量の信念記録 |

### 4. なぜ「数式」にする価値があるか

1. **再現性**: 同じ CCL 式 → 同じ認知プロセス
2. **組み合わせ可能性**: `@weigh = /bou*%/noe` を別のマクロに埋め込める
3. **品質可視化**: 各ステップの出力を個別に検証できる
4. **共有可能性**: 「この CCL 式でやってみて」と言えば認知プロセスが伝わる

### 5. 読者が試せるミニ CCL

（3-5 行の簡単な CCL 式と、それを通常のプロンプトに展開した例を提示）

### 6. 限界と課題

- 学習コスト: 新しい記法を覚える必要がある
- ランタイム依存: パーサーがないと「記法を書いただけ」になる
- 汎用性: 現時点では Claude に最適化されている

---

## まとめ

プロンプトは「自然言語で書くもの」という前提を疑う時期に来ている。
構造化、型付け、テスト可能性 — プログラミングが歩んだ道を、
プロンプトエンジニアリングもこれから歩む。

CCL はその一つの試み。

---

*ステータス: たたき台 / 未完成*
