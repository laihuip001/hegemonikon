# アフィン認知 — 線形型とリソースの一回使用

> **CCL**: `/gno+{source=rust.affine_types >> ccl.resource_model}`
> **消化タイプ**: T4 (概念輸入 — 要慎重)
> **Date**: 2026-02-15
> **前提**: operator_semantics.md, [kernel/horme.md](../../kernel/horme.md)
> **注意**: T4 は kernel 拡張に及ぶ。慎重に進める。

---

## 1. Rust の線形型 / アフィン型とは

### 線形型 (Linear Type)

> 値は正確に**一度だけ**使われなければならない。

```rust
// FnOnce — 一度しか呼べないクロージャ
let closure = || {
    let data = expensive_computation();
    data  // data の所有権が移動。もう使えない
};
closure();   // ✅ 一度目
// closure();  ❌ コンパイルエラー: value used after move
```

### アフィン型 (Affine Type)

> 値は**最大一度**使われる。使わなくても良い (drop)。

Rust の所有権は実質的に**アフィン型**:

- 値は最大一度だけ消費される (move)
- 使わずに drop しても良い
- 二度使うことは構造的に不可能

### なぜ重要か

> **一回使用 = 認知リソースの有限性モデル**
>
> 人間の注意力、セッションのコンテキスト、Creator の時間 — 全て有限。
> 「何度でも使える」という前提は、リソースの浪費を招く。

---

## 2. HGK における「一回使用」の現存例

すでに HGK には「一回使用」パターンが暗黙的に存在する:

| パターン | 説明 | 一回使用の性質 |
|:---------|:-----|:-------------|
| **セッション** | `/boot` → 作業 → `/bye` | セッションは再利用しない。使い終わったら終了 |
| **Handoff** | `/bye` で生成 | 次の `/boot` で**一度**読まれ、統合されたら不要 |
| **WF の `>>` (射)** | `/noe >> /dia` | `/noe` の出力は `/dia` に移動し、戻れない |
| **`I:[cond]{A} E:{B}`** | 条件分岐 | A か B のどちらか**一方だけ**実行される |
| **`F:[×N]{WF}`** | 反復 | 各イテレーションの中間結果は次に**消費**される |

---

## 3. アフィン認知の 3 原則

### 原則 1: 認知リソースは消費される

> **文脈 (context) は無限に参照できるものではない。**
> 使うたびに劣化する (Context Rot = BC-18)。

```
セッション開始: context 品質 = 1.0
  30 steps: context 品質 = 0.8   (🟡 注意)
  50 steps: context 品質 = 0.5   (🟠 危険)
  70 steps: context 品質 = 0.2   (🔴 劣化)
```

**アフィン型の視点**: コンテキストは `Rc<T>` (参照カウント) ではなく、
`Box<T>` (所有) に近い。一度読んだ情報は劣化していく。

### 原則 2: 出力は一度だけ消費される

> **WF の出力は、受け取った WF が責任を持つ。**
> 二つの WF が同じ出力を「所有」することはない。

これは `operator_semantics.md` の `_` (move) と整合する:

- `/noe _ /dia`: `/noe` の出力は `/dia` へ。両方が持つことはない
- 分岐が必要なら `%` (clone) で明示的に複製する

### 原則 3: 注意は排他的資源

> **深い思考 (`+`) は、一度に一つの対象にしか向けられない。**

`operator_semantics.md` で定義:

- `+` = `&mut` — 排他的変更権
- `/noe+ * /dia+` は理論上コンフリクト

心理学的にも裏付けがある: **注意のボトルネック** (Broadbent, 1958)。
複数の対象に同時に深い注意を向けることは、人間にもできない。

---

## 4. FnOnce — 一回実行 WF

### Rust の FnOnce

```rust
fn execute_once<F: FnOnce()>(f: F) {
    f();  // 実行後、f は消費される。再利用不可
}
```

### CCL への適用

WF に「一回だけ実行」制約を付ける場面:

| 場面 | 理由 | 既存構文 |
|:-----|:-----|:---------|
| `/bye` | セッションは一度だけ終了する | 慣例的に最後 |
| `@proof` | 存在証明は一度生成したら変更しない | `@proof` マクロ |
| 破壊的操作 | `rm` は一度だけ。取り消せない | BC-5 (Proposal First) |

**FnOnce の CCL 表現**: 既存の `_` (move) が本質的に FnOnce。
`_` で繋いだ WF は出力を消費するので、同じ出力で再実行することは構造的にできない。

→ **新しい構文は不要**。`_` の移動セマンティクスが FnOnce を表現している。

---

## 5. kernel 拡張の検討

### 拡張すべきか？

| 候補 | 検討結果 | 判断 |
|:-----|:---------|:----:|
| 新公理の追加 | 不要。FEP + 既存座標で表現可能 | ❌ |
| 新定理の追加 | 不要。既存定理のメタ性質として表現 | ❌ |
| BC の追加 | 不要。BC-18 (Context Rot) が既にアフィン的 | ❌ |
| 設計原則の追加 | **あり**。CCL 設計原則に「消費意識」を追加 | ✅ |

### 追加する設計原則

> **CCL アフィン原則**: 認知リソース (コンテキスト、注意、出力) は
> デフォルトで**アフィン** (最大一回使用) と見なす。
> 再利用が必要な場合は `*` (borrow) または `%` (clone) で**明示する**。

これは Rust の「移動がデフォルト、借用は明示」の直接的な消化。

---

## 6. 既存体系との整合性チェック

| 既存概念 | アフィン認知との関係 | 整合性 |
|:---------|:-------------------|:------:|
| Context Rot (BC-18) | コンテキストの劣化 = アフィン的消費 | ✅ |
| `_` (move) | 消費的シーケンス = FnOnce | ✅ |
| `*` (borrow) | 非消費的参照 = &T | ✅ |
| `%` (clone) | 明示的複製 = Clone | ✅ |
| `/bye` | セッションの一回使用 | ✅ |
| Handoff | 読み込みで消費 | ✅ |

**矛盾なし**。アフィン認知は既存体系の**メタ性質を明文化**したもの。

---

## 7. Kalon テスト

| 概念 | Rust 用語 | HGK 用語 | Kalon |
|:-----|:----------|:---------|:-----:|
| 一回使用 | FnOnce / Affine | 消費的実行 | ✅ |
| 移動がデフォルト | move semantics | `_` の不可逆性 | ✅ |
| 借用は明示 | borrow | `*` で明示 | ✅ |
| リソース劣化 | lifetime | Context Rot | ✅ |

**全て HGK の語彙で表現可能。Rust の語彙を必要としない。** ✅

---

## 8. まとめ

### 消化された原則

> **アフィン原則**: リソースはデフォルトで一度消費。再利用は明示。
>
> **注意の排他性**: `+` (深化) は一度に一対象。`_` で移動後は戻れない。
>
> **Context Rot = アフィン劣化**: セッションのコンテキストは参照するたびに劣化する。
> これはアフィン型の時間的側面。

### 消化されなかったもの

- Rust のライフタイム注釈 (`'a`)。CCL には明示的なライフタイムパラメータは不要
  - 理由: セッション = ライフタイムであり、`/boot` → `/bye` が境界を定める
- 線形型の「正確に一度」制約。CCL ではアフィン (最大一度) で十分

### 新構文: なし

全てが既存の CCL 演算子と BC で表現可能。
アフィン認知は**新しい概念ではなく、既存体系の性質の再発見**。

---

*Pepsis Rust Phase 3 | Affine Cognition Design (2026-02-15)*
