# Channels — 声を渡す、手は出さない

> **CCL**: `/gno+{source=rust.channels}`
> **消化タイプ**: T2 (再発見)
> **Date**: 2026-02-15
> **Kalon テスト**: ✅

---

## 1. Rust のチャネルとは何か

```rust
use std::sync::mpsc;  // multiple producer, single consumer

let (tx, rx) = mpsc::channel();

// スレッド A: 送信
thread::spawn(move || {
    tx.send("分析完了").unwrap();
    tx.send("結論: X は正しい").unwrap();
});

// メインスレッド: 受信
for msg in rx {
    println!("受信: {}", msg);
}
```

**核心**: 共有メモリではなく**メッセージパッシング**で通信する。
Go のスローガン: *"Don't communicate by sharing memory; share memory by communicating."*

| チャネル種別 | 特徴 |
|:-----------|:-----|
| `mpsc::channel()` | 無限バッファ。送信側はブロックしない |
| `mpsc::sync_channel(n)` | n 個バッファ。満杯で送信側がブロック |
| `crossbeam::channel` | MPMC (多対多) |

---

## 2. CCL の並行 WF 通信 = チャネル

### 2.1 `||` + `_` = チャネルパターン

```ccl
# A と B が並行実行し、結果を C に渡す
(A || B) _ C
```

```
A ──→ ┐
       ├──→ C が A と B の結果を受け取る
B ──→ ┘
```

| Rust | CCL | 動作 |
|:-----|:----|:-----|
| `tx.send(msg)` | A の出力 | WF が結果を生成 |
| `rx.recv()` | `_ C` | 後続 WF が結果を受信 |
| mpsc (多→1) | `(A \|\| B \|\| C) _ D` | 複数 WF → 1 つの WF |
| channel buffer | `_` のセマンティクス | All join: 全員完了後に次へ |

### 2.2 どこにチャネルを使っているか

```ccl
# /ccl-dig: 掘る
/pro _ /s+~(/p*/a) _ /ana _ /dia*/o+ _ /pis _ /dox-
#
# 各 _ がチャネル: 前の WF の出力を次の WF に渡す
# /pro → {出力} → /s+ → {出力} → /ana → ...
```

**全ての `_` (シーケンス) がチャネル**。
CCL は最初からメッセージパッシング・アーキテクチャで設計されている。

---

## 3. 深い洞察: 共有メモリ vs メッセージパッシング

### Rust の二択

| 方法 | Rust | リスク |
|:-----|:-----|:------|
| 共有メモリ | `Arc<Mutex<T>>` | デッドロック、競合状態 |
| メッセージパッシング | `mpsc::channel` | 安全。所有権が移動する |

### HGK でも同じ二択

| 方法 | CCL | リスク |
|:-----|:----|:------|
| 共有コンテキスト | `(A+{ctx} \|\| B+{ctx})` | **dispatch エラー** (安全条件違反) |
| メッセージパッシング | `(A \|\| B) _ C` | 安全。各 WF が独立に動く |

**HGK は Rust と同じ結論に到達している**:
共有状態を直接変更するのは危険。メッセージパッシングが安全。

> **認知的意味**: 二人の専門家が同じ文書を同時に編集するのは危険。
> 各自が分析結果を報告し、第三者がまとめるのが安全。

---

## 4. sync_channel と CCL のバックプレッシャー

```rust
let (tx, rx) = mpsc::sync_channel(1);
// バッファ 1: 受信側が消費するまで、送信側は次を送れない
```

CCL の `_` は**暗黙の sync_channel(0)**:
前の WF が完了するまで、次の WF は開始しない。
これはバッファなしの同期チャネルと等価。

```ccl
/noe+ _ /dia+ _ /ene+
# /noe+ が完了するまで /dia+ は待つ
# /dia+ が完了するまで /ene+ は待つ
# = sync_channel(0) の連鎖
```

**CCL は最も安全な通信モデルを採用している**: 完全同期。

---

## 5. Kalon テスト

| チェック | 結果 |
|:--------|:-----|
| Rust を知らなくても理解できるか | ✅ 「結果を渡す」は普遍的 |
| 新しい構文が必要か | ❌ 不要。`_` と `\|\|` で表現済み |
| HGK に既に存在していたか | ✅ `_` がメッセージパッシングチャネル |
| 消化で何を学んだか | CCL は sync_channel(0) = 最も安全な通信モデル |

---

*Pepsis Rust T2 | Channels — 声を渡す、手は出さない (2026-02-15)*
