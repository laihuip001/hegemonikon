# 網羅的検証 — Rust の exhaustive match → /dia+ 強化

> **CCL**: `/gno+{source=rust.pattern_matching >> ccl.dia_exhaustiveness}`
> **消化タイプ**: T3 (機能消化) — /dia+ の検証力強化
> **Date**: 2026-02-15
> **前提**: [kernel/akribeia.md](../../kernel/akribeia.md), operator_semantics.md

---

## 1. Rust の網羅的パターンマッチとは

```rust
enum Direction {
    North,
    South,
    East,
    West,
}

fn describe(d: Direction) -> &str {
    match d {
        Direction::North => "上",
        Direction::South => "下",
        Direction::East  => "右",
        // Direction::West  → ❌ コンパイルエラー: non-exhaustive patterns
    }
}
```

**核心**: 全ケースを処理しない限り、コンパイラが許さない。「忘れ」を構造的に不可能にする。

### なぜ強力か

1. **忘却を環境が防ぐ** — 第零原則「意志より環境」の直接実装
2. **`_` (ワイルドカード) に頼ると危険** — 新しいバリアントの追加を見逃す
3. **存在証明** — 全ケースを処理した = 漏れがないことの証明

---

## 2. HGK に何が不足しているか

### /dia+ の現状

`/dia+` (Krisis 深化) は「批判的評価」を行う WF だが、
**何を評価すべきか**のチェックリストは WF 定義内の静的なリスト。

```
/dia+ のフェーズ:
  1. 論理的整合性
  2. 前提の検証
  3. 反例の探索
  4. 代替案の検討
  5. トレードオフの明示
```

問題: **新しい評価軸が追加されたとき、/dia+ が自動で対応しない**。
Python で言えば `if/elif/.../else` で新しい条件を忘れるのと同じ。

### 具体的な漏れの事例

| 場面 | 漏れた評価軸 | 結果 |
|:-----|:-----------|:-----|
| CCL 演算子の設計 | 既存演算子との意味衝突 | `>>` と Race の衝突 (parallel_model.md) |
| 新 WF の追加 | X-series 関係の影響 | 新 WF が既存関係を壊す可能性を見逃す |
| kernel 変更 | PROOF.md の更新 | 定理変更後に証明が古いまま |

---

## 3. 消化: /dia+ の網羅性強制

### 3.1 Series 完全性チェック

/dia+ が「定理」や「Series」に対して判定を行うとき、**全 Series を明示的に処理する**:

```
/dia+ の Series チェック:
  O-series: [判定]
  S-series: [判定]
  H-series: [判定]
  P-series: [判定]
  K-series: [判定]
  A-series: [判定]
  ─────────────────
  = 全 6 Series 処理済み ✅
```

**反パターン**:

```
/dia+ の判定:
  O-series: 問題なし
  S-series: 問題なし
  (他は省略)      ← ❌ 非網羅的。3/6 が未検証。
```

### 3.2 層完全性チェック

CCL 演算子を追加・変更するとき、**全 6 層を確認する**:

| 層 | チェック項目 |
|:---|:-----------|
| 骨格 (`+`, `-`) | 新演算子は深化/縮約を持つか？ |
| 次元 (`^`, `√`) | 次元変換が必要か？ |
| 合成 (`*`, `%`, `_`) | 既存合成演算子との関係は？ |
| 射 (`>>`, `>*`) | 構造的変換との整合性は？ |
| 位相 (`/`, `\`) | Limit/Colimit への影響は？ |
| プロセス (`~`, `~*`, `||`) | 並行・振動への影響は？ |

### 3.3 BC 影響チェック

新しいルールや WF を追加するとき、**影響する BC を列挙する**:

```
新規 WF 追加時の BC チェックリスト:
  BC-1  (流し読み禁止):  影響なし
  BC-3  (WF 実体読込):   [該当 WF 定義パスを登録]
  BC-5  (Proposal First): [破壊的操作があるか？]
  BC-8  (射出力義務):     [提案すべき射はあるか？]
  BC-10 (道具利用):       [既存 PJ で代替可能か？]
  BC-11 (CCL 実行義務):   [CCL 式に含まれるか？]
  BC-12 (PJ 自動登録):    [新ディレクトリを作るか？]
  ...
```

---

## 4. 実装: Hermēneus への組み込み

### dispatch() の exhaustive check (第零原則実装)

```
dispatch() 拡張:
  1. AST 解析 (現行)
  2. WF 展開 (現行)
  3. exhaustive_check:  ← NEW
     a. CCL 式内の全 WF が定義済みか？
     b. 条件分岐 (I:/EI:/E:) が全ケースをカバーしているか？
     c. 並行 (||) の安全条件は満たされているか？ (parallel_model.md)
  4. plan_template 生成 (現行)
```

### 出力フォーマット

```
[Exhaustive Check]
  WF 定義:     ✅ 全 WF が workflow_registry に存在
  条件分岐:    ⚠️ I:[cond]{A} に E:{} なし → 失敗時の動作が未定義
  並行安全:    ✅ || の両辺が Independent
  Series 完全:  ⚠️ O, S, H のみ処理。P, K, A が未処理
```

---

## 5. Kalon テスト

| 概念 | Rust 用語 | HGK 用語 | Kalon |
|:-----|:----------|:---------|:-----:|
| 列挙の全ケース処理 | exhaustive match | 網羅的検証 | ✅ |
| ワイルドカードの危険性 | `_` pattern | 「他は省略」の禁止 | ✅ |
| コンパイラによる強制 | rustc | Hermēneus dispatch() | ✅ |

**Kalon 判定**: 「網羅的に確認する」は普遍的な概念。
Rust の `match` を知らなくても「全ケースを確認する」は理解できる。✅

---

## 6. 消化の要約

### 消化された設計原則

> **網羅性原則**: /dia+ の評価は、対象の全要素を明示的に処理しなければならない。
> 「他は省略」は BC-1 (流し読み禁止) の /dia+ 版。
>
> **環境による強制**: 網羅性チェックは Hermēneus dispatch() に組み込む。
> エージェントの注意力に依存しない (第零原則)。
>
> **ワイルドカード禁止**: `_` (全キャッチ) 的な判定は、新要素の追加を見逃すリスクがある。
> 安全な省略は `-` (縮約) で行い、省略範囲を明示する。

### 消化されなかったもの

- Rust の代数的データ型 (enum) 自体。CCL にはそのレベルの型システムがない
- コンパイル時の完全な静的解析。Hermēneus は簡易チェッカーであり、Rust のような完全な型推論は持たない

---

*Pepsis Rust Phase 2 | Exhaustive Check Design (2026-02-15)*
