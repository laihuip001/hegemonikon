# CCL 演算子の所有権意味拡張

> **CCL**: `/gno+{source=rust.ownership >> ccl.operators}`
> **消化タイプ**: T2 深化 (既存構造の意味拡張)
> **Date**: 2026-02-15
> **前提**: [ccl/operators.md](../../ccl/operators.md) v7.4

---

## 要旨

Rust の所有権モデルは、CCL 演算子に**新しい構文を追加しない**。
代わりに、既存の演算子が**すでに所有権モデルを体現していた**ことを発見する。

これは消化の理想形: 外部の知識が、内部の既存構造の「再発見」を引き起こす。

---

## 二項演算子の所有権解釈

### `_` (シーケンス) = **Move**

```
/noe _ /dia _ /ene
```

**既存定義**: 射の合成 (g∘f)。思考の連鎖。

**所有権の視点**: 各 WF が前の WF の出力の**所有権を受け取る**。
`/noe` の出力は `/dia` に move される。`/noe` はもうその出力を持たない。

| 性質 | 意味 |
|:-----|:-----|
| 不可逆 | `/noe _ /dia` の後、`/noe` の出力には戻れない |
| 線形消費 | 各 WF の出力は**一度だけ**次の WF に消費される |
| 所有権移転 | 左の WF → 右の WF へ責任が移る |

**帰結**: `_` で繋いだ後に「やっぱり戻る」は設計違反。戻るなら `~` を使え。

---

### `>>` (射) = **Move with Transformation**

```
/noe >> /dia
```

**既存定義**: X-series 構造的変換。A が B に**変わる**。

**所有権の視点**: `_` が「渡す」なら `>>` は「変わる」。
所有権の移転に加え、主体そのものが変容する。

| `_` vs `>>` | `_` (シーケンス) | `>>` (射) |
|:-------------|:-----------------|:----------|
| Rust 対応 | `let b = a;` (move) | `let b: B = a.into();` (into) |
| 主体の変化 | 出力は変わるが主体は同じ | 主体自体が変容する |
| 復元可能性 | 出力は消えるが WF は残る | WF 自体が変わる |

---

### `*` (融合) = **Shared Borrow**

```
/noe * /dia
```

**既存定義**: 精度加重された統合。⟨A,B⟩_π

**所有権の視点**: 両者が互いの出力を**借用**し、融合する。
どちらの WF も消費されない。両方が存続し続ける。

| 性質 | 意味 |
|:-----|:-----|
| 非消費的 | 両 WF の出力は融合後も参照可能 |
| 対称的 | 指向性あり (左が主) だが、どちらも消えない |
| 同時参照 | `&A` + `&B` → 新しい値を生成 |

**Rust 対応**: `fn merge(a: &A, b: &B) -> C` — 両方を不変借用して新しい値を返す。

---

### `%` (展開) = **Clone + Distribute**

```
/noe % /dia
```

**既存定義**: 外積。全次元の組み合わせを保持。

**所有権の視点**: 各次元を**複製 (Clone)** して全組み合わせに配布する。
情報の損失がない = lossless。

| `*` vs `%` | `*` (融合) | `%` (展開) |
|:------------|:-----------|:-----------|
| Rust 対応 | `&A + &B → C` | `A.clone() × B.clone() → Matrix` |
| 情報 | lossy (収束) | lossless (保存) |
| コスト | 低 (1 出力) | 高 (N×M 出力) |

---

### `~` (振動) = **Mutable Borrow の交互取得**

```
/noe ~ /dia
```

**既存定義**: 余帰納的振動。動的な往復。

**所有権の視点**: 二つの WF が**交互に mutable borrow** を取得する。
Rust の借用規則: 「`&mut` は一度に一つだけ」。振動はこれを時間で解決する。

```
ターン 1: /noe が &mut context を持つ → 出力を書き込む
ターン 2: /dia が &mut context を持つ → 出力を書き込む
ターン 3: /noe が &mut context を持つ → ...
```

| 性質 | 意味 |
|:-----|:-----|
| 排他的変更権 | 同時に二つの WF が context を変更することはない |
| 時間的分離 | `&mut` の排他性を時間的交替で実現 |
| データ競合なし | 各ターンで一つの WF だけが書き込む |

**帰結**: `~` が安全なのは、各ターンの WF が排他的にコンテキストを変更するから。
これは Rust の `&mut` 規則と構造的に同型。

---

### `~*` (収束振動) = **Interior Mutability パターン**

```
/noe ~* /dia
```

**所有権の視点**: `RefCell<T>` + ループ。実行時に借用チェックしながら収束。

- 内部で `&mut` を動的に取得
- 不動点 (Fixed Point) に達したら返す
- terminal coalgebra = `Rc<RefCell<T>>` の認知版

---

### `>*` (射的融合) = **Backward Channel**

```
/noe >* /dia
```

**既存定義**: Lax Actegory。A が B の視点で変容。

**所有権の視点**: 逆方向の所有権移転。「B の視点で A を書き換える」。
`>>` が forward (予測) なら `>*` は backward (推論更新)。

**Rust 対応**: `impl From<B> for A` — B から A への変換トレイトの実装。
`>>` = `Into<B>`, `>*` = `From<B>`。

---

## 単項演算子の所有権解釈

### `+` (深化) = **Mutable Reference**

```
/noe+
```

**所有権の視点**: WF の出力を**変更可能な状態**で拡張する。
`+` を付けた WF は、出力に書き込む権限を持つ。

| `+` vs `-` | `+` (深化) | `-` (縮約) |
|:------------|:-----------|:-----------|
| Rust 対応 | `&mut T` | `&T` |
| 操作 | 出力に情報を**追加** | 出力から情報を**取得** |
| コスト | 高 (排他的) | 低 (共有可能) |

**帰結**: `+` は高コスト。一度に一つの WF だけが `+` で深化できる。
`/noe+ _ /dia+` は OK (シーケンシャル)。
`/noe+ * /dia+` は理論上コンフリクト (同時に両方が書き込む)。

### `-` (縮約) = **Immutable Reference**

```
/noe-
```

読み取りのみ。複数の WF が同時に `-` を使える。

---

## 六層とリソース管理

| 層 | 所有権モデル | 安全保証 |
|:---|:------------|:---------|
| **骨格** (`+`, `-`) | `&mut T` / `&T` | 排他的変更 / 共有読取 |
| **次元** (`^`, `√`) | 型レベル変換 | コンパイル時の型安全 |
| **合成** (`*`, `%`, `_`) | borrow / clone / move | 借用の種類で安全性が決まる |
| **射** (`>>`, `>*`) | Into / From | 変換方向の型安全 |
| **位相** (`/`, `\`) | Limit / Colimit | 収束 = Drop, 展開 = Clone |
| **プロセス** (`~`, `~*`, `~!`) | `&mut` の時間的交替 | データ競合なし |

---

## 発見のまとめ

### 新しい構文は不要だった

Rust の所有権モデルが教えてくれたのは、CCL の既存演算子が**なぜ安全なのか**:

1. `_` が**不可逆**なのは、move だから
2. `*` が**安全**なのは、shared borrow だから
3. `~` が**データ競合しない**のは、`&mut` の時間的交替だから
4. `+` が**高コスト**なのは、排他的変更権だから

### 設計原則への昇格

> **CCL 所有権原則**: 演算子の選択は、認知リソースの所有権型を決定する。
>
> - 消費するなら `_` / `>>`
> - 借用するなら `*`
> - 変更するなら `+` (一度に一つ)
> - 読むだけなら `-` (同時に複数可)
> - 交互に変更するなら `~`

---

*Pepsis Rust Phase 2 | Operator Semantics Extension (2026-02-15)*
