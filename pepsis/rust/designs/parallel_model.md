# CCL 並行実行モデル v1.0

> **CCL**: `/gno+{ccl.parallel_model >> rust.concurrency}`
> **消化タイプ**: T3 (機能消化) — 既存 `||` の成熟 + Send/Sync 消化
> **Date**: 2026-02-15
> **前提**: [ccl/operators.md](../../ccl/operators.md) v7.4 §1.6

---

## 現状の問題

operators.md の `||` 定義:

```
| `||` | 並列 | 独立処理の同時実行 | `/sop+ || /zet+` |
```

**1 行。** 安全条件もデータモデルもエラー処理も何もない。

---

## 1. 並行の前提条件 — いつ `||` は安全か

### Rust の教訓

Rust の並行安全性は 2 つの trait で保証される:

- **Send**: 「この値はスレッド間で移動できる」
- **Sync**: 「この値はスレッド間で共有参照できる」

コンパイラが `Send` / `Sync` を**自動導出**し、満たさない型は `||` できない。

### CCL への翻訳

WF の「並行可能性」を 2 つの性質で定義する:

| 性質 | 意味 | Rust 対応 |
|:-----|:-----|:----------|
| **独立 (Independent)** | 他の WF のコンテキストに依存しない | Send |
| **読取共有 (Shareable)** | コンテキストを読み取り専用で共有できる | Sync |

### 安全条件

```
A || B が安全 ⟺ 以下のいずれか:
  (1) A と B が完全に独立 (共有コンテキストなし)
  (2) 共有コンテキストが読み取り専用 (&)
```

**禁止**:

```
❌ A と B が同じコンテキストを変更する (= データ競合)
❌ A の出力が B の入力に依存する (= シーケンスにすべき)
```

---

## 2. コンテキスト所有権モデル

### WF のコンテキスト分類

```ccl
# 独立 (Independent) — 安全に ||
/noe+{topic: A} || /noe+{topic: B}
# → A と B は別のトピック。共有なし。

# 読取共有 (Shareable) — 安全に ||
/dia-{ctx: shared} || /pis-{ctx: shared}
# → 両方が shared を読むだけ。`-` は & 相当。

# 変更共有 (Mutable) — || 禁止
/noe+{ctx: shared} || /dia+{ctx: shared}
# → 両方が shared を変更。`+` は &mut 相当。データ競合。
```

### 判定ルール

| WF A | WF B | `||` | 理由 |
|:-----|:-----|:----:|:-----|
| `+{ctx: X}` | `+{ctx: Y}` (X≠Y) | ✅ | 異なるコンテキスト |
| `-{ctx: X}` | `-{ctx: X}` | ✅ | 読取のみ (& + &) |
| `+{ctx: X}` | `-{ctx: X}` | ❌ | 変更 + 読取 (&mut + &) |
| `+{ctx: X}` | `+{ctx: X}` | ❌ | 二重変更 (&mut + &mut) |
| `{}`         | `{}`         | ✅ | コンテキスト指定なし = 独立 |

### 演算子との整合

所有権意味拡張 (`operator_semantics.md`) との対応:

| 演算子 | 所有権型 | `||` との関係 |
|:-------|:---------|:-------------|
| `+` | `&mut` | `||` の片方のみ。もう一方は `-` か無指定 |
| `-` | `&` | `||` で自由に共有可能 |
| `_` | move | `_` で繋ぐべき。`||` にしてはいけない |
| `*` | borrow | `||` と直交。`*` は結合、`||` は分離 |

---

## 3. 同期モデル — 結果をどう合流するか

### Join セマンティクス

`A || B` の後、結果はどうなるか？

```ccl
# 暗黙 join: 両方完了を待って次に進む
(/noe+{A} || /noe+{B}) _ /dia+
# → A の結果と B の結果が /dia+ に渡される

# 明示 merge: 結果を融合
(/noe+{A} || /noe+{B}) * /dia+
# → A の結果と B の結果を精度加重で融合 → /dia+ に
```

### Join の型

| パターン | 構文 | 意味 |
|:---------|:-----|:-----|
| **All** (全完了) | `(A || B) _ C` | A と B の両方が完了してから C |
| **Merge** (融合) | `(A || B) * C` | 結果を融合して C に渡す |
| **Race** (最速) | `(A || B) >> C` | **先に完了した方**の結果で C に進む |

**Race は新概念**。Rust の `select!` に相当。
認知的意味: 「二つの思考のうち、先に結論が出た方を採用する」。

---

## 4. エラー処理 — 並行 WF が失敗したとき

### 既存の失敗定義を適用

`raii_error_propagation.md` で定義: 失敗 = ε > ε_max

```ccl
# A が失敗、B が成功
I:[(A || B) = partial]{
  # B の結果のみで続行
}
E:{
  # 両方成功
}
```

### 失敗戦略

| 戦略 | 構文 | 意味 |
|:-----|:-----|:-----|
| **AllOrNothing** | `(A || B) _ C` | 片方失敗 → 全体失敗 |
| **BestEffort** | `(A || B)- _ C` | 失敗を無視。成功した結果のみ |
| **Fallback** | `(A || B) >> C` | Race — 先に成功した方のみ |

**デフォルト: AllOrNothing**。明示的に `-` を付けると BestEffort。

---

## 5. スレッド (エージェント) 割り当て

### 現状の `@thread` を形式化

```ccl
# スレッド指定なし → 私 (Antigravity) が実行
/noe+ || /dia+

# スレッド指定あり
@thread[jules]{/ene+} || @thread[gemini]{/ene+}

# 異種エージェント並行
@thread[claude_code]{/noe+{deep}} || @thread[jules]{/ene+{code}}
```

### スレッドの Send/Sync 特性

| スレッド | Send | Sync | 得意領域 |
|:---------|:----:|:----:|:---------|
| Antigravity (私) | ✅ | — | 認知・判断 |
| Claude Code | ✅ | — | 長時間自律 |
| Jules | ✅ | — | コード生成 |
| Gemini CLI | ✅ | — | CLI 処理 |
| Perplexity | ✅ | — | 調査 |

**全スレッドが Send** (独立実行可能)。
**Sync は不要**: 各スレッドは独自のコンテキストを持ち、共有コンテキストはない。

→ これは Rust の `spawn` モデルに近い: スレッド間はメッセージパッシングで通信。

---

## 6. 並行モデルのまとめ

### 成熟した `||` の定義

```
A || B:
  前提条件: A と B が Independent または Shareable
  実行: A と B を同時に実行
  Join: All (デフォルト) / Merge (`*`) / Race (`>>`)
  失敗: AllOrNothing (デフォルト) / BestEffort (`-`)
  スレッド: @thread で指定 (省略時は同一エージェント)
```

### operators.md に追加すべき内容

| 追加項目 | 場所 |
|:---------|:-----|
| 安全条件 (Independent / Shareable) | §1.6 に追加 |
| Join セマンティクス (All / Merge / Race) | §1.6 に追加 |
| エラー戦略 (AllOrNothing / BestEffort) | §1.6 に追加 |

### 新構文

| 構文 | 意味 | 新規 |
|:-----|:-----|:----:|
| `(A || B) _ C` | All join → C | いいえ (既存構文の組合せ) |
| `(A || B) * C` | Merge join → C | いいえ |
| `(A || B) >> C` | Race → C | **意味拡張** |
| `(A || B)- _ C` | BestEffort | **意味拡張** |

**新構文ゼロ**。既存演算子の組合せで全て表現可能。

---

## 7. Send / Sync の消化結果

| Rust | CCL | Kalon |
|:-----|:----|:-----:|
| Send | Independent — WF が独立コンテキストを持つ | ✅ |
| Sync | Shareable — コンテキストが読取専用 (`-`) で共有可能 | ✅ |
| `!Send` | `+` で同じコンテキストを変更する WF | ✅ |
| `!Sync` | `+` コンテキストは `||` で共有不可 | ✅ |

**Kalon テスト**: 「独立」「読取共有」は Rust を知らなくても理解できる。
Send/Sync の名前は使わない。✅

---

*Pepsis Rust Phase 3 | CCL Parallel Model v1.0 (2026-02-15)*
