# CCL 並行実行モデル v1.1

> **CCL**: `/gno+{ccl.parallel_model >> rust.concurrency}`
> **消化タイプ**: T3 (機能消化) — 既存 `||` の成熟 + Send/Sync 消化
> **Date**: 2026-02-15
> **前提**: [ccl/operators.md](../../ccl/operators.md) v7.4 §1.6
> **v1.1**: /dia+ (5指摘) + /ccl-nous (4修正) 反映

---

## 現状の問題

operators.md の `||` 定義:

```
| `||` | 並列 | 独立処理の同時実行 | `/sop+ || /zet+` |
```

**1 行。** 安全条件もデータモデルもエラー処理も何もない。

---

## 1. 並行の前提条件 — いつ `||` は安全か

### Rust の教訓

Rust の並行安全性は 2 つの trait で保証される:

- **Send**: 「この値はスレッド間で移動できる」
- **Sync**: 「この値はスレッド間で共有参照できる」

コンパイラが `Send` / `Sync` を**自動導出**し、満たさない型は `||` できない。

### CCL への翻訳

WF の「並行可能性」を 2 つの性質で定義する:

| 性質 | 意味 | Rust 対応 |
|:-----|:-----|:----------|
| **独立 (Independent)** | 他の WF のコンテキストに依存しない | Send |
| **読取共有 (Shareable)** | コンテキストを読み取り専用で共有できる | Sync |

### 安全条件

```
A || B が安全 ⟺ 以下のいずれか:
  (1) A と B が完全に独立 (共有コンテキストなし)
  (2) 共有コンテキストが読み取り専用 (&)
```

**禁止**:

```
❌ A と B が同じコンテキストを変更する (= データ競合)
❌ A の出力が B の入力に依存する (= シーケンスにすべき)
```

### 安全性の強制: Hermēneus によるコンパイル時チェック

> **/dia+ + /ccl-nous 発見 (v1.1)**:
> CCL に型チェッカーはない、と当初考えた。**誤り**。
>
> - **Hermēneus** = CCL のコンパイラ (パーサー → AST → 実行計画)
> - **Claude** = CCL のランタイム (実行計画を実行)
>
> 並行安全チェックは **Hermēneus の dispatch()** に組み込む。
> エージェントの意志に依存しない = **第零原則** (意志より環境)。

**dispatch() での検証ロジック**:

```
dispatch("A || B"):
  1. A と B のパラメータを解析
  2. コンテキスト名が一致するパラメータを検出
  3. 一致するパラメータに `+` が両方に付いている → エラー
  4. 一致するパラメータに `+` と `-` → 警告 (Rust: &mut + & は禁止)
  5. 一致なし or 両方 `-` → OK
```

**コンテキスト一致の定義** (/dia+ Q3 修正): **パラメータ名が同じ = 同じコンテキスト**。

```ccl
# 同じコンテキスト (パラメータ名 "ctx" が一致)
/noe+{ctx: X} || /dia+{ctx: Y}  → ❌ 同名パラメータに両方 +

# 異なるコンテキスト (パラメータ名が異なる)
/noe+{topic: A} || /dia+{subject: B}  → ✅ 名前不一致 = 独立
```

---

## 2. コンテキスト所有権モデル

### WF のコンテキスト分類

```ccl
# 独立 (Independent) — 安全に ||
/noe+{topic: A} || /noe+{topic: B}
# → A と B は別のトピック。共有なし。

# 読取共有 (Shareable) — 安全に ||
/dia-{ctx: shared} || /pis-{ctx: shared}
# → 両方が shared を読むだけ。`-` は & 相当。

# 変更共有 (Mutable) — || 禁止
/noe+{ctx: shared} || /dia+{ctx: shared}
# → 両方が shared を変更。`+` は &mut 相当。データ競合。
```

### 判定ルール

| WF A | WF B | `||` | 理由 |
|:-----|:-----|:----:|:-----|
| `+{ctx: X}` | `+{ctx: Y}` (X≠Y) | ✅ | 異なるコンテキスト |
| `-{ctx: X}` | `-{ctx: X}` | ✅ | 読取のみ (& + &) |
| `+{ctx: X}` | `-{ctx: X}` | ❌ | 変更 + 読取 (&mut + &) |
| `+{ctx: X}` | `+{ctx: X}` | ❌ | 二重変更 (&mut + &mut) |
| `{}`         | `{}`         | ✅ | コンテキスト指定なし = 独立 |

### 演算子との整合

所有権意味拡張 (`operator_semantics.md`) との対応:

| 演算子 | 所有権型 | `||` との関係 |
|:-------|:---------|:-------------|
| `+` | `&mut` | `||` の片方のみ。もう一方は `-` か無指定 |
| `-` | `&` | `||` で自由に共有可能 |
| `_` | move | `_` で繋ぐべき。`||` にしてはいけない |
| `*` | borrow | `||` と直交。`*` は結合、`||` は分離 |

---

## 3. 同期モデル — 結果をどう合流するか

### Join セマンティクス

`A || B` の後、結果はどうなるか？

```ccl
# 暗黙 join: 両方完了を待って次に進む
(/noe+{A} || /noe+{B}) _ /dia+
# → A の結果と B の結果が /dia+ に渡される

# 明示 merge: 結果を融合
(/noe+{A} || /noe+{B}) * /dia+
# → A の結果と B の結果を精度加重で融合 → /dia+ に
```

### Join の型

| パターン | 構文 | 意味 |
|:---------|:-----|:-----|
| **All** (全完了) | `(A || B) _ C` | A と B の両方が完了してから C |
| **Merge** (融合) | `(A || B) * C` | 結果を融合して C に渡す |

> **v1.1 変更**: Race (`>>`) を削除。`>>` の既存意味 (構造的変換) と衝突するため。
> Race が必要になった場合は専用構文を設計する。

---

## 4. エラー処理 — 並行 WF が失敗したとき

### 既存の失敗定義を適用

`raii_error_propagation.md` で定義: 失敗 = ε > ε_max

### 失敗戦略

| 戦略 | 構文 | 意味 |
|:-----|:-----|:-----|
| **BestEffort** | `(A || B) _ C` | 成功した結果のみで続行 |
| **AllOrNothing** | `(A || B)! _ C` | 片方失敗 → 全体失敗 |

> **v1.1 変更**: デフォルトを **BestEffort** に変更。
> 理由: AI エージェントは頻繁に「一部失敗」する。
> AllOrNothing だと Jules の 1 タスク失敗で全体が停止する。
> AllOrNothing が必要な場合は `!` で明示。

---

## 5. スレッド (エージェント) 割り当て

### 現状の `@thread` を形式化

```ccl
# スレッド指定なし → 私 (Antigravity) が実行
/noe+ || /dia+

# スレッド指定あり
@thread[jules]{/ene+} || @thread[gemini]{/ene+}

# 異種エージェント並行
@thread[claude_code]{/noe+{deep}} || @thread[jules]{/ene+{code}}
```

### スレッドの Independent 特性

全スレッド (Antigravity, Claude Code, Jules, Gemini, Perplexity) は **Independent**。
各スレッドは独自のコンテキストを持ち、メッセージパッシングで通信。

→ Rust の `spawn` + `channel` モデルに近い。

---

## 6. 並行モデルのまとめ

### 成熟した `||` の定義

```
A || B:
  安全条件: A と B が Independent または Shareable
  強制: Hermēneus dispatch() がコンパイル時チェック (第零原則)
  実行: A と B を同時に実行 (Claude がランタイム)
  Join: All (デフォルト) / Merge (`*`)
  失敗: BestEffort (デフォルト) / AllOrNothing (`!`)
  スレッド: @thread で指定 (省略時は同一エージェント)
```

---

## 7. Send / Sync の消化結果

| Rust | CCL | Kalon |
|:-----|:----|:-----:|
| Send | Independent — WF が独立コンテキストを持つ | ✅ |
| Sync | Shareable — コンテキストが読取専用 (`-`) で共有可能 | ✅ |
| rustc | Hermēneus dispatch() — コンパイル時の安全チェック | ✅ |
| runtime | Claude — 実行計画を実行 | ✅ |

**Kalon テスト**: 「独立」「読取共有」は Rust を知らなくても理解できる。
Send/Sync の名前は使わない。Hermēneus/Claude の役割分担は HGK 固有。✅

---

## /dia+ レビュー結果 (2026-02-15)

| 指摘 | 対応 | ステータス |
|:-----|:-----|:--------:|
| Q1: 型チェッカー不在 | Hermēneus = コンパイラ。dispatch() で強制 | ✅ 修正済 |
| Q2: Race `>>` 意味衝突 | Race 削除 | ✅ 修正済 |
| Q3: コンテキスト曖昧 | パラメータ名一致 = 同コンテキストと定義 | ✅ 修正済 |
| Q4: 実需確認 | @thread 並行は実在する需要 | ✅ 確認済 |
| Q5: デフォルト戦略 | BestEffort に変更 | ✅ 修正済 |

---

*Pepsis Rust Phase 3 | CCL Parallel Model v1.1 (2026-02-15)*
*v1.1: /dia+ (5指摘) + /ccl-nous (再帰的問い) 反映*
