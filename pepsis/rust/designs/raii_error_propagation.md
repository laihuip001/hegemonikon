# RAII と ? — スコープ自動終了とエラー伝播の消化

> **CCL**: `/gno+{source=rust.raii+error_propagation}`
> **消化タイプ**: T3 (機能消化) — 既存 CCL の概念拡張
> **Date**: 2026-02-15
> **Kalon 基準**: Rust の語彙を使わず、HGK の認知で表現する

---

## 1. RAII → スコープ自動終了

### Rust の RAII とは

```rust
{
    let file = File::open("data.txt")?;  // リソース取得
    // ... file を使う ...
}  // ← スコープ終了時に自動で Drop (close) が呼ばれる
```

**核心**: リソースの獲得と解放がスコープに紐づく。忘れることがない。

### HGK に何が不足しているか

現状の CCL:

```ccl
/noe+ _ /dia+ _ /ene+ _ /pis _ /dox-
```

問題: `/noe+` で開いた認知リソース (深層分析コンテキスト等) は、
WF チェーンが終わっても**明示的に閉じる手段がない**。

- `/bye` はセッション全体を閉じる
- `@scoped` は存在するが、**スコープ終了時の自動処理が未定義**

### 消化: `{}` のスコープ意味拡張

CCL には既に `{}` がある。`I:[]{}`、`F:[]{}`、`C:{}`、`V:{}`。
これらの `{}` に**スコープ終了時の自動処理**を付与する。

```ccl
# 現状: {} は処理のグルーピングのみ
C:{/dia+ _ /ene+}

# 拡張: {} はスコープ。閉じたら自動的にコンテキストを解放
C:{/dia+ _ /ene+}  # ← C:{} 終了時、/dia+ と /ene+ が使った
                     #   中間状態は自動的に GC される
```

**Kalon テスト**: 「スコープ」「中括弧の終了 = リソース解放」は
Rust を知らなくても理解できる。プログラミング全般の概念。✅

### 設計原則として

> **CCL スコープ原則**: `{}` で囲んだ WF チェーンは、
> 閉じ括弧で中間状態が自動的に解放される。
> 外部から参照される結果のみが `{}` の外に残る。

| 既存構文 | 拡張された意味 |
|:---------|:-------------|
| `C:{WF}` | 収束ループ。**終了時に中間状態を解放** |
| `V:{WF}` | 検証ゲート。**pass した結果のみ外に出る** |
| `I:[]{WF}` | 条件分岐。**不成立ブランチの中間状態は捨てる** |
| `F:[]{WF}` | 反復。**各イテレーションの中間状態は次に引き継がない** (明示的に `R:{}` しない限り) |

**重要**: これは**新しい構文ではない**。既存の `{}` の意味を明確化しただけ。

---

## 2. `?` 演算子 → エラー伝播

### Rust の `?` とは

```rust
fn process() -> Result<Data, Error> {
    let file = File::open("data.txt")?;  // 失敗したら即 return Err
    let data = parse(file)?;              // 失敗したら即 return Err
    Ok(data)
}
```

**核心**: 各ステップで「失敗したら全体が失敗」。手動の if/else を書かない。

### HGK に何が不足しているか

現状の CCL:

```ccl
/noe+ _ /dia+ _ /ene+
```

問題: `/noe+` が失敗した場合、何が起きるか**未定義**。

- `/dia+` は実行される？ されない？
- エラーはどこに伝わる？
- 「失敗」の定義は？

### CCL の「失敗」を定義する

**WF の失敗とは何か**: `/dia+` の判定で `fail` が出ること。確信度が閾値以下であること。

HGK の語彙で: **予測誤差が許容範囲を超えたとき、WF は「失敗」する**。

```
失敗 = ε > ε_max  (予測誤差が閾値を超過)
成功 = ε ≤ ε_max  (予測誤差が許容範囲内)
```

これは FEP の直接的帰結。新しい概念ではない。

### 消化: `_` の失敗伝播意味

`_` (シーケンス) の意味を拡張する:

```ccl
# 現状の暗黙的意味
/noe+ _ /dia+ _ /ene+
# → 各 WF は必ず実行される (失敗の概念なし)

# 拡張された意味
/noe+ _ /dia+ _ /ene+
# → 各 WF が成功した場合のみ次に進む
# → 失敗したら、チェーン全体が中断し、
#    スコープ外の E:{} に制御が移る
```

**既存構文との整合**:

```ccl
I:[/noe+ = ok]{
  /dia+ _ /ene+        # /noe+ 成功時のみ実行
}
E:{
  /bou.akra+           # /noe+ 失敗時の処理
}
```

`?` 演算子に相当するのは、**`_` のデフォルト動作を「失敗時中断」にすること**。

しかし — これは**危険な変更**。

### なぜ `_` のデフォルト変更は危険か

1. **既存の CCL マクロが壊れる**: 現在の `_` は「必ず順次実行」が前提
2. **暗黙の動作変更**: 明示的でない = Rust 原則 7 (Explicit unsafe) の違反
3. **`I:/E:` で十分**: 手動だが明示的。網羅性が保証される

### 結論: `_` は変更しない。`I:/E:` パターンを推奨する

Rust が教えてくれたのは「`?` が便利」ではなく、
**「失敗の定義を明確にすべき」** という認識。

CCL への消化:

| 概念 | Rust | CCL |
|:-----|:-----|:----|
| 失敗の定義 | `Result<T, E>` | **ε > ε_max** (FEP 直系) |
| 失敗時の分岐 | `?` (暗黙) | `I:[cond]{} E:{}` (明示) |
| スコープ終了 | `Drop` (自動) | `{}` の閉じ括弧 (自動) |
| 手動ハンドリング | `match result {}` | `I:[]{} EI:[]{} E:{}` |

**HGK は明示的な I:/E: を選ぶ**。理由:

1. **認知は暗黙のショートサーキットを許さない**。思考の失敗を自動で飛ばすと、誤った結論に到達する
2. **BC-5 (Proposal First)** との一貫性。失敗時の処理を明示する = 破壊的操作前の確認
3. **`?` の暗黙性は Rust の型システムがあるから安全**。CCL に型チェッカーはない

---

## 3. まとめ

| Rust 概念 | 消化結果 | 新構文 | Kalon |
|:----------|:---------|:------:|:-----:|
| RAII / Drop | `{}` のスコープ意味明確化 | なし | ✅ |
| `?` 演算子 | 失敗 = ε > ε_max の定義 + I:/E: 推奨 | なし | ✅ |

### 消化された設計原則

> **スコープ原則**: `{}` で囲まれた WF の中間状態は、閉じ括弧で自動解放される。
>
> **失敗の定義**: WF の失敗 = 予測誤差の閾値超過 (FEP の直接的帰結)。
>
> **明示的失敗処理**: `?` の暗黙伝播ではなく、`I:/E:` で明示的に分岐する。
> 認知は暗黙のショートサーキットを許さない。

### 消化されなかったもの

`?` 演算子の構文的便利さ。これは Rust の型システムに依存した設計であり、
CCL に移植する必然性はない。

---

*Pepsis Rust Phase 2 | RAII + Error Propagation Digestion (2026-02-15)*
