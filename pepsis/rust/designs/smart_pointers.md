# Smart Pointers — 所有の多様な形態

> **CCL**: `/gno+{source=rust.smart_pointers}`
> **消化タイプ**: T2 (再発見)
> **Date**: 2026-02-15
> **Kalon テスト**: ✅

---

## 1. Rust のスマートポインタとは何か

通常のポインタはアドレスだけ。スマートポインタは**追加の機能を持つ**:

```rust
// Box<T> — ヒープに置く。単一所有。
let boxed = Box::new(42);
// boxed が drop されたら、中身も解放される

// Rc<T> — Reference Counted。共有所有。単スレッド。
let shared = Rc::new(42);
let clone1 = Rc::clone(&shared);  // 参照カウント: 2
let clone2 = Rc::clone(&shared);  // 参照カウント: 3
// 全ての Rc が drop されたら、中身が解放される

// Arc<T> — Atomic Reference Counted。共有所有。マルチスレッド。
let arc = Arc::new(42);
let arc_clone = Arc::clone(&arc);
thread::spawn(move || {
    println!("{}", arc_clone);  // 別スレッドでも安全に読める
});
```

| ポインタ | 所有権 | スレッド | コスト |
|:--------|:------|:--------|:------|
| `Box<T>` | 単一所有 | 制限なし | ゼロ (コンパイル時解決) |
| `Rc<T>` | 共有所有 | 単一スレッド | 参照カウント |
| `Arc<T>` | 共有所有 | マルチスレッド | 原子的参照カウント |

---

## 2. HGK の所有権モデルとの対応

### 2.1 Box = 通常の WF (デフォルト)

```ccl
/noe+{topic: X}
# /noe+ は topic: X を「所有」している
# /noe+ が終了したら、この分析コンテキストは解放される (RAII)
# 他の WF は topic: X にアクセスできない (排他的)
```

Box は Rust のデフォルトの所有権モデル。CCL でも WF はデフォルトで単一所有。
**Box に対応する特殊な構文は不要。これがデフォルト。**

### 2.2 Rc = `*` (結合)

```ccl
# 複数の WF が同じ知識を共有参照するケース
/noe-{context: shared} * /dia-{context: shared}
# /noe- も /dia- も同じ context を読み取る (不変参照)
# どちらかが終わっても、もう一方がまだ使っているので解放しない
```

| Rc | CCL `*` |
|:---|:--------|
| `Rc::clone()` — 参照カウント++  | `* /wf` — 同じコンテキストへの参照を追加 |
| 全 Rc が drop → 解放 | 全 WF が完了 → コンテキスト解放 |
| 単一スレッド限定 | `*` は順次実行 (単一エージェント) |

### 2.3 Arc = `||` + `-`

```ccl
# 複数エージェントが同じ知識を安全に共有
(/noe-{ctx: knowledge} || /dia-{ctx: knowledge})
# 並行実行。両方とも読み取り専用 (`-`) なので安全
# → parallel_model.md の Shareable 条件
```

| Arc | CCL `||` + `-` |
|:----|:--------------|
| `Arc::clone()` — 原子的カウント++ | `||` — 並行実行スレッド追加 |
| スレッドセーフ | `-` (読み取り) で安全性保証 |
| `Mutex<Arc<T>>` で可変アクセス | `||` + `+` → 安全条件違反 (dispatch エラー) |

---

## 3. 深い洞察:  所有権の濃度

> **所有権は 0/1 ではなく、グラデーションがある。**

| 濃度 | Rust | CCL | 日常の例 |
|:-----|:-----|:----|:--------|
| **排他的所有** | `Box<T>` / `T` | デフォルト | 日記。自分だけが読み書き |
| **共有読取** | `Rc<T>` / `Arc<T>` | `*` / `||` + `-` | 図書館の本。みんなが読める |
| **排他的変更** | `&mut T` | `+` | レポート執筆中のロック |
| **共有変更** | `Rc<RefCell<T>>` | Interior Mutability | 共有ドキュメントの編集 (要調整) |

CCL の演算子で全ての濃度を表現できる:

```
排他的所有:   /wf{ctx: X}           # デフォルト
共有読取:     /wf1-{ctx: X} * /wf2-{ctx: X}  # 結合 + 読取
排他的変更:   /wf+{ctx: X}           # + は排他的
共有変更:     → 設計的に禁止 (BC / dispatch)
```

**Rust が型で表現するグラデーションを、CCL は演算子 (+/-/*/||) で表現する。**

---

## 4. Weak\<T\> — 弱い参照

```rust
// Weak<T>: 所有権を持たない参照。循環参照を防ぐ。
let strong = Rc::new(42);
let weak = Rc::downgrade(&strong);
// strong が drop → weak は無効になる (dangling しない)
```

HGK 対応: **Handoff の参照**

```
# セッション A で /noe+ を実行
# セッション B で Handoff を通じてセッション A の結論を参照
# セッション A のコンテキストは既に解放されている
# → Handoff は Weak 参照: 元のコンテキストがなくても安全に読める
#   (結論は記録されているが、推論過程へのアクセスはない)
```

| Rust | HGK |
|:-----|:----|
| `Weak<T>` → `upgrade()` で `Option<Rc<T>>` | Handoff → 参照先が存在すれば読める |
| `upgrade()` → `None` | Handoff の参照先が古すぎて無効 |
| 循環参照の防止 | セッション間の循環依存の防止 |

---

## 5. Kalon テスト

| チェック | 結果 |
|:--------|:-----|
| Rust を知らなくても理解できるか | ✅ 「所有の形態」は直感的 |
| 新しい構文が必要か | ❌ 不要。+/-/*/|| で表現済み |
| HGK に既に存在していたか | ✅ 演算子が所有権のグラデーションを表現 |
| 消化で何を学んだか | Weak参照 = Handoff。所有権はグラデーション |

---

*Pepsis Rust T2 | Smart Pointers — 所有の多様な形態 (2026-02-15)*
